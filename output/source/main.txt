Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

update-axois/
├── benefitposting.txt
├── document.txt
├── email.txt
├── employeeinfo.txt
├── emptostaffprofile.txt
├── izignapi.txt
├── pahadvanceapi.txt
├── payrollposting.txt
└── payrolltojoget.txt

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] benefitposting.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

benefitposting/
├── dbprocess.js
├── main.js
├── outputstructure.js
├── serviceapi.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const Sequelize = require('sequelize');
const reqContext = require('../../../../utils/requestcontext');
const db = require('../../../../config/sequelize/sequelize').getConfig();

class DbProcess {

    async getEmployeeData(condition) {

        const personalData = db[reqContext.getTenantCode()].PersonalData;
        const personalAssignment = db[reqContext.getTenantCode()].PersonalAssignment;

        return personalData.findAll({
            raw: true,
            attributes: [
                'empCode',
                ['firstFName', 'thFirstName'],
                ['secondFName', 'enFirstName'],
                ['firstLName', 'thLastName'],
                ['secondLName', 'enLastName'],
                ['firstMName', 'thMiddleName'],
                ['secondMName', 'enMiddleName'],
                'PersonalAssignments.persAreaCode',
                'PersonalAssignments.persSubAreaCode',
                'PersonalAssignments.comCode',
                'PersonalAssignments.empGroupCode',
            ],
            include: [{
                required: true,
                model: personalAssignment,
                attributes: [],
                where: condition.personalAssignmentCondition
            }],
            where: condition.personalDataCondition,
            order: [
                ['empCode', 'ASC']
            ]
        })

    }

    getPayrollDirectory(condition) {

        return db[reqContext.getTenantCode()].PayrollResultDirectory.findAll({
            raw: true,
            attributes: [
                'empCode',
                'id',
                'seqNo',
                'paymentDate',
                'forPeriod',
                'forYear',
                'inPeriod',
                'inYear',
                'resultIndicator'
            ],
            where: condition,
            order: [
                ['empCode', 'ASC']
            ]
        })

    }

    getRecordPayrollDirectory(condition) {
        return db[reqContext.getTenantCode()].PayrollResultDirectory.findAll({
            raw: true,
            attributes: [
                'id'
            ],
            where: condition,
            order: [
                ['seqNo', 'DESC']
            ]
        })
    }

    getRT(condition) {

        return db[reqContext.getTenantCode()].RT.findAll({
            raw: true,
            attributes: [
                'rgdirID',
                'wtCode',
                'amount',
                'quantity',
                'rate',
                'costDistributionNo',
                'forPeriod',
                'forYear',
                'costAssignmentNo'
            ],
            where: condition,
            order: [
                ['rgdirID', 'ASC'],
                ['wtCode', 'ASC']
            ]
        })

    }

    getRTRetroWT(condition) {
        const rt = db[reqContext.getTenantCode()].RT;
        const wageType = db[reqContext.getTenantCode()].WageType;
        return rt.findAll({
            raw: true,
            attributes: [
                'rgdirID',
                'wtCode',
                'amount',
                'quantity',
                'rate'
            ],
            include: [{
                required: true,
                model: wageType,
                attributes: [],
                where: condition.wageTypeCondition
            }],
            where: condition.rtCondition,
            order: [
                ['rgdirID', 'ASC'],
                ['wtCode', 'ASC']
            ]
        })

    }

    getPayrollPeriod(condition) {

        return db[reqContext.getTenantCode()].PayrollPeriod.findAll({
            raw: true,
            attributes: [
                'payrollPeriodCode',
                'period',
                'year',
                'startDate',
                'endDate',
                'paymentDate',
                'payrollAreaCode'
            ],
            where: condition
        })

    }

    getOnePayrollPeriod(condition) {

        return db[reqContext.getTenantCode()].PayrollPeriod.findOne({
            raw: true,
            attributes: [
                'payrollPeriodCode',
                'period',
                'year',
                'startDate',
                'endDate',
                'paymentDate',
                'payrollAreaCode'
            ],
            where: condition
        })

    }

    getPYAccountMapping(condition) {
        const pyAccountMap = db[reqContext.getTenantCode()].PYAccountMapping;
        return pyAccountMap.findAll({
            raw: true,
            attributes: [
                "wtCode",
                "accountGroupCode",
                "ignoreCostDistribution",
            ],
            where: condition
        })
    }

    getWageType(condition) {
        const wageType = db[reqContext.getTenantCode()].WageType;
        return wageType.findAll({
            raw: true,
            attributes: [
                "wtCode",
                "recWTCode",
            ],
            where: condition
        })
    }

    getPYAccountDetail(condition) {
        const pyAccountDetail = db[reqContext.getTenantCode()].PYAccountDetail;
        return pyAccountDetail.findAll({
            raw: true,
            attributes: [
                "company",
                "accEmpGroupCode",
                "accountGroupCode",
                "debit",
                "credit",
                "reclassFlag",
                "reclassDebit",
                "debitChargeExpenseCode",
                "creditChargeExpenseCode"
            ],
            where: condition
        })
    }

    getPYAccount(condition) {
        const pyAccount = db[reqContext.getTenantCode()].PYAccount;
        return pyAccount.findAll({
            raw: true,
            attributes: [
                "accountCode",
                "pyAccType",
                "rate",
                [Sequelize.col('ConfigText.description'), 'accountCodeDesc'],
            ],
            include: [{
                required: false,
                model: db[reqContext.getTenantCode()].ConfigText,
                attributes: [],
                where: {
                    configTableCode: 'PYAccount',
                    langKeyCode: reqContext.getLanguage()
                }
            }],
            where: condition
        })
    }

    getPYAccountEmpGroupingDetail(condition) {
        const pyAccountEmpGrouping = db[reqContext.getTenantCode()].PYAccountEmpGrouping;
        return pyAccountEmpGrouping.findAll({
            raw: true,
            where: condition,
        })
    }

    getPYCostDistribution(condition) {
        const pyCostDistribution = db[reqContext.getTenantCode()].PYCostDistribution;
        return pyCostDistribution.findAll({
            raw: true,
            attributes: [
                "comCode",
                "costCenterCode",
                "rgdirID",
                "percent",
                "orderNumber",
                "sequenceNo"
            ],
            where: condition
        })
    }

    getPYWPBP(condition) {
        const pyWPBP = db[reqContext.getTenantCode()].PYWPBP;
        return pyWPBP.findAll({
            raw: true,
            attributes: [
                "comCode",
                "empGroupCode",
                "costCenter",
                "rgdirID",
                "orgCode",
                "posCode"
            ],
            where: condition
        })
    }

    getAllPYWPBP(condition) {
        const pyWPBP = db[reqContext.getTenantCode()].PYWPBP;
        return pyWPBP.findAll({
            raw: true,
            where: condition
        })
    }


    //Update posting
    getCGPAYROLLMergeDoc(condition) {
        const mergeDoc = db[reqContext.getTenantCode()].CGPAYROLLMergeDoc;
        return mergeDoc.findAll({
            raw: true,
            where: condition,
        })
    }

    createCGPAYROLLMergeDoc(data, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLMergeDoc.create(data, {
            transaction: transaction
        });
    }

    updateCGPAYROLLMergeDoc(data, condition, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLMergeDoc.update(
            data, {
            where: condition,
            transaction: transaction
        });
    }

    creatBulkeCGPAYROLLSouceDoc(params, transaction) {
        const tenant = reqContext.getTenantCode();
        return db[tenant].CGPAYROLLSouceDoc.bulkCreate(params, { transaction: transaction });
    };

    creatBulkeCGPAYROLLPostDetail(params, transaction) {
        const tenant = reqContext.getTenantCode();
        return db[tenant].CGPAYROLLPostDetail.bulkCreate(params, { transaction: transaction });
    };

    deletePostDetail(condition, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLPostDetail.destroy({
            where: condition,
            transaction: transaction
        })

    }

    getParameter(condition) {
        const parameter = db[reqContext.getTenantCode()].Parameter;
        return parameter.findAll({
            raw: true,
            attributes: [
                'id',
                'paramGroup',
                'paramName',
                'lowValue',
                'remark',
                'paramExt'
            ],
            where: condition
        })
    }

    getNumberRangeDetail(condition) {
        const numberRangeDetail = db[reqContext.getTenantCode()].NumberRangeDetail;
        return numberRangeDetail.findOne({
            raw: true,
            where: condition
        })
    }

    updateNumberRangeDetail(data, condition, transaction) {
        const numberRangeDetail = db[reqContext.getTenantCode()].NumberRangeDetail;
        return numberRangeDetail.update(
            data, {
            where: condition,
            transaction: transaction
        });
    }

    getPosition(condition = {}) {
        const position = db[reqContext.getTenantCode()].Position;
        return position.findAll({
            raw: true,
            where: condition
        })
    }

    getPYCostAssignment(condition = {}) {
        const pyCostAssignment = db[reqContext.getTenantCode()].PYCostAssignment;
        return pyCostAssignment.findAll({
            raw: true,
            where: condition
        })
    }

    getBenefitPay(condition = {}) {
        const benefitPay = db[reqContext.getTenantCode()].BenefitPay;
        return benefitPay.findAll({
            raw: true,
            where: condition
        })
    }

    getPersonalBank(condition = {}) {
        const personalBank = db[reqContext.getTenantCode()].PersonalBank;
        return personalBank.findAll({
            raw: true,
            where: condition,
        });
    }

    createASWBenefitsPosting(dataList, transaction) {
        const aswBenefitsPosting = db[reqContext.getTenantCode()].ASWBenefitsPosting;
        return aswBenefitsPosting.bulkCreate(dataList,{ transaction: transaction });
    }

    getPYAccountGrouping(condition) {
        const pyAccountGrouping = db[reqContext.getTenantCode()].PYAccountGrouping;
        return pyAccountGrouping.findAll({
            raw: true,
            where: condition
        })
    }

    getCostCenter(condition) {
        const costCenter = db[reqContext.getTenantCode()].CostCenter;
        return costCenter.findAll({
            raw: true,
            where: condition
        })
    }

    getBNClaimType(condition) {
        const BNClaimType = db[reqContext.getTenantCode()].BNClaimType;
        return BNClaimType.findAll({
        raw: true,
        attributes: {
            include: [
                'claimTypeCode',
                'wtCode',
                [Sequelize.col('ConfigText.description'), 'description']
            ],
        },
        include: [
            {
            required: false,
            attributes: [],
            model: db[reqContext.getTenantCode()].ConfigText,
            where: {
                configTableCode: 'BNClaimType',
                langKeyCode: reqContext.getLanguage(),
            },
            },
        ],
        where: condition,
        order: [['wtCode', 'ASC']],
        });
    }
    getCostAssignment(condition = {}) {
        const costAssignment = db[reqContext.getTenantCode()].CostAssignment;
        return costAssignment.findAll({
            raw: true,
            where: condition
        })
    }

    getASWBenefitsPosting(condition = {}) {
        const aswBenefitsPosting = db[reqContext.getTenantCode()].ASWBenefitsPosting;
        return aswBenefitsPosting.findAll({
            raw: true,
            where: condition
        })
    }
}

module.exports = DbProcess;
[File Ends] dbprocess.js

[File Begins] main.js
const path = require("path");

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');

const BGProcess = require('../../../../utils/bgprocess').BGProcess;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const BenefitPostingProcessingUtil = require('./util').BenefitPostingProcessingUtil;

const program = 'TNT_ASSETWISE02';
const globalConstant = require('../../../../config/constant');

exports.initPage = async (req, res, next) => {
    let functionReturn = new FunctionReturn();

    try {

        let util = new BenefitPostingProcessingUtil();
        functionReturn = await util.initPage();

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/main - initPage', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn);
}

exports.main = async (req, res, next) => {
    if (!req.body.bgProcess.isProcess) {

        let appExecutionID = await helper.logAppExecution({
            programCode: program,
            isBGProcess: false,
            selection: req.body,
            event: globalConstant.logAppUsageEvent.start
        });

        await execute(req.body, new BGProcess(program), res, next);

        await helper.logAppExecution({
            appExecutionID: appExecutionID,
            event: globalConstant.logAppUsageEvent.finish
        });

    } else {
        let controller = path.resolve(__dirname) + '/main'
        let functionReturn = await new BGProcess(program).start(controller, req.body)
        res.json(functionReturn)
    }
}

exports.onInputChange = async (req, res) => {

    let functionReturn = new FunctionReturn();

    try {

        let params = req.body;
        let util = new BenefitPostingProcessingUtil();
        functionReturn = await util.onInputChange(params);

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/main - onInputChange', '', '', '', '');
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn)
}

exports.onCompanyChange = async (req, res) => {

    let functionReturn = new FunctionReturn();

    try {

        let params = req.body;
        let util = new BenefitPostingProcessingUtil();
        functionReturn = await util.onCompanyChange(params);

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/main - onCompanyChange', '', '', '', '');
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn)
}

exports.jobSchedule = async (req) => {
    let controller = path.resolve(__dirname) + '/main'

    req.body.empStatusList = req.body.empStatus;
    req.body.persAreaList = req.body.personnelArea;
    req.body.persSubAreaList = req.body.personnelSubArea;
    req.body.empGroupList = req.body.empGroup;
    req.body.empSubGroupList = req.body.empSubGroup;

    let functionReturn = await new BGProcess(program).start(controller, req.body)
    return functionReturn
}

process.on('message', async (bgProcess) => {
    bgProcess = Object.assign(new BGProcess(), bgProcess)
    bgProcess.startAt = new Date(bgProcess.startAt)
    bgProcess.functionReturn = new FunctionReturn()
    await execute(bgProcess.selection, bgProcess)

})

const execute = async (selection, bgProcess, res = null, next = null) => {

    let functionReturn = new FunctionReturn()
    try {

        let param = {
            selection: selection.data,
            bgProcess: bgProcess,
            res: res
        }
        let util = new BenefitPostingProcessingUtil();
        functionReturn = await util.execute(param);

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/main - execute', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
        bgProcess.handleError(functionReturn, res);
    }
}

[File Ends] main.js

[File Begins] outputstructure.js
exports.createOutputStructure = () => {
    let outputStructure = {};
    outputStructure["separateIndicator"] = "";
    outputStructure["documentDate"] = "";
    outputStructure["documentType"] = "";
    outputStructure["companyCode"] = "";
    outputStructure["postingDate"] = "";
    outputStructure["period"] = "";
    outputStructure["currency"] = "";
    outputStructure["exchangeRate"] = "";
    outputStructure["translationDate"] = "";
    outputStructure["reference"] = "";
    outputStructure["documentHeaderText"] = "";
    outputStructure["refKeyHeader1"] = "";
    outputStructure["refKeyHeader2"] = "";
    outputStructure["branchNumber"] = "";
    outputStructure["extraBranchCode"] = "";
    outputStructure["extraTAXID"] = "";
    outputStructure["extraTEXT"] = "";
    outputStructure["reversalReasonAccrued"] = "";
    outputStructure["reversalDateAccrued"] = "";
    outputStructure["postingKey"] = "";
    outputStructure["accountSAP"] = "";
    outputStructure["specialGLIndicator"] = "";
    outputStructure["alternativeReconciliationAccount"] = "";
    outputStructure["taxBaseAmountinDocumentCurrency"] = "";
    outputStructure["taxBaseAmountinLocalCurrency"] = "";
    outputStructure["amtindoccurr"] = "";
    outputStructure["amtinlocalcurr"] = "";
    outputStructure["taxAmount"] = "";
    outputStructure["autoCalVAT"] = "";
    outputStructure["taxCode"] = "";
    outputStructure["indicatorDeterminetaxbase"] = "";
    outputStructure["branchCode"] = "";
    outputStructure["termsofpayment"] = "";
    outputStructure["baselinedateforduedatecalculation"] = "";
    outputStructure["paymentBlockKey"] = "";
    outputStructure["invRefDoc"] = "";
    outputStructure["invRefFiscalYear"] = "";
    outputStructure["invRefLineitem"] = "";
    outputStructure["paymentCurrency"] = "";
    outputStructure["paymentCurrencyAmount"] = "";
    outputStructure["paymentMethod"] = "";
    outputStructure["paymentReference"] = "";
    outputStructure["assignmentnumber"] = "";
    outputStructure["text"] = "";
    outputStructure["tradingPartner"] = "";
    outputStructure["refKeyLineItem1"] = "";
    outputStructure["refKeyLineItem2"] = "";
    outputStructure["refKeyLineItem3"] = "";
    outputStructure["valuedate"] = "";
    outputStructure["bankPartnerType"] = "";
    outputStructure["houseBank"] = "";
    outputStructure["accountID"] = "";
    outputStructure["costCenter"] = "";
    outputStructure["order"] = "";
    outputStructure["profitCenter"] = "";
    outputStructure["wBSElement"] = "";
    outputStructure["earmarkFund"] = "";
    outputStructure["quantity"] = "";
    outputStructure["baseUnitofMeasure"] = "";
    outputStructure["poNo"] = "";
    outputStructure["poItem"] = "";
    outputStructure["indicatorforwithholdingtaxtype1"] = "";
    outputStructure["withholdingtaxcode1"] = "";
    outputStructure["withholdingtaxbaseamountindocumentcurrency1"] = "";
    outputStructure["enterwithholdingtaxamountindocumentcurrency"] = "";
    outputStructure["indicatorforwithholdingtaxtype2"] = "";
    outputStructure["withholdingtaxcode2"] = "";
    outputStructure["withholdingtaxbaseamountindocumentcurrency2"] = "";
    outputStructure["enterwithholdingtaxamountindocumentcurrency"] = "";
    outputStructure["indicatorforwithholdingtaxtype3"] = "";
    outputStructure["withholdingtaxcode3"] = "";
    outputStructure["withholdingtaxbaseamountindocumentcurrency3"] = "";
    outputStructure["enterwithholdingtaxamountindocumentcurrency"] = "";
    outputStructure["payeePayerCode"] = "";
    outputStructure["individualPayeeinDocument"] = "";
    outputStructure["name1"] = "";
    outputStructure["name2"] = "";
    outputStructure["name3"] = "";
    outputStructure["name4"] = "";
    outputStructure["street"] = "";
    outputStructure["city"] = "";
    outputStructure["postalCode"] = "";
    outputStructure["country"] = "";
    outputStructure["language"] = "";
    outputStructure["bankKey"] = "";
    outputStructure["bankAccount"] = "";
    outputStructure["bankCountry"] = "";
    outputStructure["taxno3"] = "";
    outputStructure["taxno5"] = "";
    outputStructure["typeofBusiness"] = "";
    outputStructure["typeofIndustry"] = "";
    outputStructure["longText1"] = "";
    outputStructure["longText2"] = "";
    outputStructure["longText3"] = "";
    outputStructure["longText4"] = "";
    outputStructure["longText5"] = "";
    return outputStructure;
}

exports.outputStructureOrder = () => {
    return [
        "separateIndicator",
        "documentDate",
        "documentType",
        "companyCode",
        "postingDate",
        "period",
        "currency",
        "exchangeRate",
        "translationDate",
        "reference",
        "documentHeaderText",
        "refKeyHeader1",
        "refKeyHeader2",
        "branchNumber",
        "extraBranchCode",
        "extraTAXID",
        "extraTEXT",
        "reversalReasonAccrued",
        "reversalDateAccrued",
        "postingKey",
        "accountSAP",
        "specialGLIndicator",
        "alternativeReconciliationAccount",
        "taxBaseAmountinDocumentCurrency",
        "taxBaseAmountinLocalCurrency",
        "amtindoccurr",
        "amtinlocalcurr",
        "taxAmount",
        "autoCalVAT",
        "taxCode",
        "indicatorDeterminetaxbase",
        "branchCode",
        "termsofpayment",
        "baselinedateforduedatecalculation",
        "paymentBlockKey",
        "invRefDoc",
        "invRefFiscalYear",
        "invRefLineitem",
        "paymentCurrency",
        "paymentCurrencyAmount",
        "paymentMethod",
        "paymentReference",
        "assignmentnumber",
        "text",
        "tradingPartner",
        "refKeyLineItem1",
        "refKeyLineItem2",
        "refKeyLineItem3",
        "valuedate",
        "bankPartnerType",
        "houseBank",
        "accountID",
        "costCenter",
        "order",
        "profitCenter",
        "wBSElement",
        "earmarkFund",
        "quantity",
        "baseUnitofMeasure",
        "poNo",
        "poItem",
        "indicatorforwithholdingtaxtype1",
        "withholdingtaxcode1",
        "withholdingtaxbaseamountindocumentcurrency1",
        "enterwithholdingtaxamountindocumentcurrency",
        "indicatorforwithholdingtaxtype2",
        "withholdingtaxcode2",
        "withholdingtaxbaseamountindocumentcurrency2",
        "enterwithholdingtaxamountindocumentcurrency",
        "indicatorforwithholdingtaxtype3",
        "withholdingtaxcode3",
        "withholdingtaxbaseamountindocumentcurrency3",
        "enterwithholdingtaxamountindocumentcurrency",
        "payeePayerCode",
        "individualPayeeinDocument",
        "name1",
        "name2",
        "name3",
        "name4",
        "street",
        "city",
        "postalCode",
        "country",
        "language",
        "bankKey",
        "bankAccount",
        "bankCountry",
        "taxno3",
        "taxno5",
        "typeofBusiness",
        "typeofIndustry",
        "longText1",
        "longText2",
        "longText3",
        "longText4",
        "longText5"
    ];
}

exports.titleGroup = () => {
    // return ["documentDate", "documentType", "companyCode", "postingDate", "period", "currency", "refKeyHeader1", "branchNumber"];
    return [];
}

exports.createASWBenefitsPostingSchema = {
    "sepIndicator": "",
    "docDate": "",
    "docType": "",
    "compCode": "",
    "postDate": "",
    "currency": "",
    "reference": "",
    "refKey": "",
    "branchNumber": "",
    "postKey": "",
    "account": "",
    "alternativeReconcile": "",
    "amtInDocCurr": "",
    "amtInLocalCurr": "",
    "taxCode": "",
    "branchCode": "",
    "termOfPay": "",
    "baselineDate": "",
    "assignmentNumber": "",
    "text": "",
    "costCenter": "",
    "longText1": "",
    "longText2": "",
    "longText3": "",
    "changedAt": "",
    "changedBy": ""
};
[File Ends] outputstructure.js

[File Begins] serviceapi.js
const lodash = require("lodash");
const axios = require('axios');

const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const services = require("../../../../utils/interface/services");
const env = require('../../../../config/environment/environment').getConfig();
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const grantType = "client_credentials";
const pyPostingTriggeConnCode = "PYPOSTINGTRIGGER";
const pyPostingTokenRequestConnCode = "PYPOSTINGTOKENREQUES";
const headers = { "Content-Type": "application/x-www-form-urlencoded" };

class ServiceApi {

    constructor() {}


    async apiTokenRequest() {
        let functionReturn = new FunctionReturn();

        try {

            let serverConn = await services.getServerConnctionByConnCode(pyPostingTokenRequestConnCode);

            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let clientID = lodash.get(serverConn, 'result[0].username', '');
            let encryptClientSecret = lodash.get(serverConn, 'result[0].password', '');
            let host = lodash.get(serverConn, 'result[0].host', '');

            let encryptPath = env[reqContext.getTenantCode()].serverConnSecretKey;
            let clientSecret = helper.decrypt(encryptClientSecret, encryptPath);

            if (!clientSecret.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let authParam = new URLSearchParams({
                grant_type: grantType,
                client_id: clientID,
                client_secret: lodash.get(clientSecret, 'result', ''),
            });

            try {
                
                let response = await axios.post(host, authParam, { headers: headers });
                functionReturn.result = lodash.get(response, 'data.access_token', '');
                
            } catch (error) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('tenant.assetwise.benefitPosting.error.apiTokenRequest')
                return functionReturn;
            }

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/serviceapi - apiTokenRequest', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');  
        }

        return functionReturn;
    }

    async submitApiTriggers(fileName) {

        let functionReturn = new FunctionReturn();

        try {

            let resultToken = await this.apiTokenRequest();

            if (!resultToken.success) {
                functionReturn = resultToken;
                return functionReturn;
            }

            let serverConn = await services.getServerConnctionByConnCode(pyPostingTriggeConnCode);
            
            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }
            
            try {
                
                let host = lodash.get(serverConn, 'result[0].host', '');
                let irpaApiKey = lodash.get(serverConn, 'result[0].username', '');
                let data = JSON.stringify({ input: { ipFileName: fileName } });
                let authorization = lodash.get(resultToken, 'result', '');
                  
                let config = {
                    method: 'post',
                    url: host,
                    headers: { 
                        'irpa-api-key': irpaApiKey,
                        'Authorization': `Bearer ${authorization}`, 
                        'Content-Type': 'application/json'
                    },
                    data : data
                };

                let response = await axios(config);
                let messageText = lodash.get(response, 'statusText', '');
                functionReturn.message = messageText;
                  
            } catch (error) {
                helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/serviceapi - submitApiTriggers', '', '', '', '');
                functionReturn.message = translation.getTranslateText('tenant.assetwise.benefitPosting.error.submitApiTriggers');
                functionReturn.success = false;
            }

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/serviceapi - submitApiTriggers', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');  
        }
        return functionReturn;
    }

}

exports.ServiceApi = ServiceApi;
[File Ends] serviceapi.js

[File Begins] util.js
const Sequelize = require('sequelize');
const moment = require("moment");
const fs = require("fs");
const lodash = require('lodash');
const JSZip = require('jszip');

const outputStructure = require('./outputstructure');
const arrayUtil = require('../../../../utils/array');
const constant = require('../../../../config/constant');
const sh = require("../../../../utils/searchhelp");
const helper = require('../../../../utils/helper');
const jsonUtil = require('../../../../utils/json');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const reqContext = require('../../../../utils/requestcontext');
const services = require("../../../../utils/interface/services");
const itftemplate = require("../../../../utils/interface/dbprocess/itftemplate");
const userUtil = require('../../../../utils/user');
const documentManagers = require("../../../../utils/interface/document");
const textFile = require("../../../../utils/interface/exportfile/interfaceout/textfile");

const env = require("../../../../config/environment/environment").getConfig();

const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const Permission = require('../../../../utils/authorization/permission/permission').Permission;
const ServiceApi = require('./serviceapi').ServiceApi;
const DBProcess = require('./dbprocess');

const payrollType = {
    normal: "NORMAL",
    special: "SPECIAL"
};

const postingKeyType = {
    debit: '40',
    credit: '50'
}

const accountReClass = '5';

const roleAttributePYSpecial = "POSTING_PYTYPE_SPECIAL";
const interfaceType = 'PY_BENEFIT_POSTING';
const separator = ",";
const contraAccountLabel = "Contra Acccount";
const numberRangePrefix = "IP-";
const numberRangeDetailNRCode = "POST";
const fileNamePrefix = "ZGLI001_";
const parameterName = "PY_ACCOUNT_POST";
const utf8WithBOMHeader = "\ufeff";
const accountGroupCodePrefix = 'BN';
const documentType = "3A";
const currency = "THB";
const branchNumber = '0000';
const postingKeyDR = 40;
const postingKeyCR = 31;
const alternativeReconciliationAccount = '2020115080';
const taxCode = "VX";
const branchCode = "NVAT";
const termsofpayment = "0000";
const benefitRemarkEnd = 72;
const debit = "DR";
const credit = "CR";
const benefitSeparateIndicatorNumber = 2;
const ignoreCostAssignmentNoRT = 0;
const costAssignmentNoRTTarget = 1;
const Op = Sequelize.Op;
const PAYROLL_PERIOD_MONTHLY_CODE = "M01";
const zipFileNamePrefix = "benefit_posting";
const pyParamGroup = 'PY';
const accountPayeeMappingParamName = 'AccountPayeeMappingCostCenter';
const accountPayeeParamName = 'AccountPayee';

class BenefitPostingProcessingUtil {

    constructor() {

    }

    replaceAll(target, search, replacement) {
        return target.split(search).join(replacement);
    }

    replaceCSVReservedKeywords(word) {
        try {
            if (!word) return word;
            word = this.replaceAll(word, ",", " ");
            word = this.replaceAll(word, "\n", " ");
            word = this.replaceAll(word, ";", " ");
            word = this.replaceAll(word, "\t", " ");
            word = this.replaceAll(word, "|", " ");
            word = this.replaceAll(word, ":", " ");
            word = this.replaceAll(word, "~", " ");
            word = this.replaceAll(word, "^", " ");
            word = this.replaceAll(word, "&", " ");
            word = this.replaceAll(word, "*", " ");
            return word;
        } catch (error) {
            return word;
        }
    }

    async initPage() {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            functionReturn.result = {
                payrollAreaSH: await sh.getPayrollArea(),
            };

            let companyList = await sh.getCompany();
            let payrollPeriodList = await sh.getPayrollPeriodList();

            functionReturn.result.startDate = moment().startOf('months');
            functionReturn.result.endDate = moment().endOf('months');

            functionReturn.result.companySH = companyList;

            //Default com code
            functionReturn.result.comCode = [];

            // functionReturn.result.employeeSH = await sh.getAvailableEmpList();
            let paramSHEmp = {
                condition: {},
                checkPerAssign: true
            };
            functionReturn.result.employeeSH = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

            functionReturn.result.selectEmpType = "ALL";

            //Check permission
            let permsParam = {
                replaceEmptyList: false,
                checkObjectList: [
                    {
                        objectType: globalConstant.permissionObjectType.company,
                        objectList: functionReturn.result.companySH,
                        codeColumn: 'comCode'

                    },
                    {
                        objectType: globalConstant.permissionObjectType.employee,
                        objectList: functionReturn.result.employeeSH,
                        codeColumn: 'key'
                    },
                ]
            };

            let permission = new Permission();
            let permsReturn = await permission.checkObjectPermission(permsParam);
            if (permsReturn.success) {
                functionReturn.result.companySH = permsReturn.result.checkResult.companyList;
                functionReturn.result.employeeSH = permsReturn.result.checkResult.empList;
            } else {
                functionReturn.result.companySH = [];
                functionReturn.result.employeeSH = [];
            }

            //Check POSTING_PY_TYPE_SPECIAL
            let specialOnly = false;
            const roleAttributes = await userUtil.getUserRoleAttribute({ username: await reqContext.getCurrentUsername() });
            specialOnly = roleAttributes.some((ra) => ra.attributeCode === roleAttributePYSpecial);

            functionReturn.result.specialOnly = specialOnly;

            if (functionReturn.result.specialOnly === true) {
                functionReturn.result.payrollType = payrollType.special;
            } else {
                functionReturn.result.payrollType = payrollType.normal;
            }

            functionReturn.result.putFileToSFTP = true;

            //Set default payroll period
            let payrollArea = functionReturn.result.payrollAreaSH[0].payrollAreaCode;

            let pyPeriodCode;
            let pyPeriod = functionReturn.result.payrollAreaSH.find(elem => elem.payrollAreaCode == payrollArea)
            if (!jsonUtil.isEmpty(pyPeriod)) {
                pyPeriodCode = pyPeriod.payrollPeriodCode;
            }
            let payrollPeriod = payrollPeriodList.find(elem =>
                elem.payrollPeriodCode === pyPeriodCode &&
                elem.startDate <= new Date() &&
                elem.endDate >= new Date() &&
                elem.payrollArea === payrollArea
            );

            if (!jsonUtil.isEmpty(payrollPeriod)) {
                let paymentDate = lodash.get(payrollPeriod, 'paymentDate', '');
                functionReturn.result.paymentDate = paymentDate;
                functionReturn.result.payrollPeriod = payrollPeriod.period;
                functionReturn.result.payrollYear = moment().format('YYYY');
            }

            let parameterCondition = {
                paramGroup: 'PY',
                paramName: 'AccountPayee',
            };
            let accountPayeeResult = await dbProcess.getParameter(parameterCondition);
            let bnClaimTypeCondition = {
                wtCode: { [Op.in]: accountPayeeResult.map((val) => val.lowValue) }
            };

            let bnClaimResult = await dbProcess.getBNClaimType(bnClaimTypeCondition);
            bnClaimResult.map(val => {
                val.description = `${val.claimTypeCode} - ${val.description}`;
                return val;
            });
            functionReturn.result.bnClaimType = bnClaimResult;

            functionReturn.result.putFileToSFTP = false;
            functionReturn.result.includeAllTransactions = false;

            if (functionReturn.result) {
                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("common.error.exception");
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/main - initPage', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }

        return functionReturn;
    }

    async onCompanyChange(param) {
        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {
            let comCode = lodash.get(param, 'params.company.comCode', '');
            let condition = { comCode: comCode };
            let pyPeriodCondition = {
                period: lodash.get(param, 'params.payrollPeriod', ''),
                year: lodash.get(param, 'params.payrollYear', '')
            }
            let periodResult = await dbProcess.getPayrollPeriod(pyPeriodCondition);
            let pyWPBP = await dbProcess.getAllPYWPBP(condition);
            let storePeriodResult = [];
            for (const periodItem of periodResult) {
                if (pyWPBP.length > 0) pyWPBP = lodash.uniqBy(pyWPBP, (val) => val.payrollAreaCode);
                let item = lodash.find(pyWPBP, (val) => val.payrollAreaCode === periodItem.payrollAreaCode);
                if (!lodash.isEmpty(item)) storePeriodResult.push(periodItem);
            }

            if (storePeriodResult.length > 0) {
                storePeriodResult = lodash.map(storePeriodResult, (val) => {
                    // val.paymentDate = moment(val.paymentDate).add(7, 'days');
                    return val;
                });
            }

            functionReturn.result = storePeriodResult;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util onCompanyChange', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async onInputChange(param) {
        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {
            let params = lodash.get(param, 'params', '');
            let payrollAreaList = lodash.get(params, 'payrollAreaCodeList', []);
            let payrollPeriodSelection = lodash.get(params, 'payrollPeriod', '');
            let payrollYear = lodash.get(params, 'payrollYear', '');

            if (lodash.isEmpty(payrollAreaList)) return functionReturn;

            let monthlyCode = lodash.find(payrollAreaList, (val) => val.payrollPeriodCode === PAYROLL_PERIOD_MONTHLY_CODE);
            let payrollPeriodCode = "";
            let payrollAreaCode = "";
            if (!lodash.isEmpty(monthlyCode)) {
                payrollPeriodCode = lodash.get(monthlyCode, 'payrollPeriodCode', '');
                payrollAreaCode = lodash.get(monthlyCode, 'payrollAreaCode', '');
            } else {
                payrollPeriodCode = lodash.get(payrollAreaList, '[0].payrollPeriodCode', '');
                payrollAreaCode = lodash.get(payrollAreaList, '[0].payrollAreaCode', '');
            }

            let condition = {
                payrollPeriodCode: payrollPeriodCode,
                period: payrollPeriodSelection,
                year: payrollYear,
                payrollAreaCode: payrollAreaCode
            }

            let payrollPeriodResult = await dbProcess.getOnePayrollPeriod(condition);

            if (payrollPeriodResult) {
                if (payrollPeriodResult.paymentDate) {
                    // payrollPeriodResult.paymentDate = moment(payrollPeriodResult.paymentDate).add(7, 'days');
                }
            }

            functionReturn.result = payrollPeriodResult;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util onInputChange', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async uploadFileToSFTP(outputPath, fileName) {
        let functionReturn = new FunctionReturn();
        try {

            const sftpConfig = await services.getSFTPConnectorConfig(interfaceType);

            let outputFilePath = "";
            let pathFile = "";
            let connConfig = "";

            if (sftpConfig.success) {
                outputFilePath = lodash.get(sftpConfig, "result[0].connConfig.outputPath", "");
                pathFile = `${outputFilePath}/${fileName}`;
                connConfig = lodash.get(sftpConfig, "result[0].connConfig", "");
            }

            const uploadFileParam = { outputPath, pathFile, connConfig };
            const response = await documentManagers.uploadFile(uploadFileParam);
            functionReturn = response;
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util uploadFileToSFTP', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async createNewASWBenefitsPosting(params, putFileToSFTP) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let transaction = null;

        try {

            if (params.length < 1) {
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.benefitsPosting");    //'Please enter Payroll Month'

                return functionReturn;
            }

            let storeNewBenefitPosting = [];
            for (const benefitsPostingItem of params) {
                let benefitsPostingItemObj = {};

                let benefitPayStartDate = lodash.get(benefitsPostingItem, 'benefitPayStartDate', '')

                benefitsPostingItemObj.sepIndicator = lodash.get(benefitsPostingItem, 'SeparateIndicator', '');
                benefitsPostingItemObj.docDate = lodash.get(benefitsPostingItem, 'DocumentDate', '')
                benefitsPostingItemObj.docType = lodash.get(benefitsPostingItem, 'DocumentType', '');
                benefitsPostingItemObj.compCode = lodash.get(benefitsPostingItem, 'CompanyCode', '');
                benefitsPostingItemObj.postDate = lodash.get(benefitsPostingItem, 'PostingDate', '');
                benefitsPostingItemObj.currency = lodash.get(benefitsPostingItem, 'Currency', '');
                benefitsPostingItemObj.reference = lodash.get(benefitsPostingItem, 'Reference', '');
                benefitsPostingItemObj.refKey = lodash.get(benefitsPostingItem, 'RefKeyHeader1', '');
                benefitsPostingItemObj.branchNumber = lodash.get(benefitsPostingItem, 'BranchNumber', '');
                benefitsPostingItemObj.postKey = lodash.get(benefitsPostingItem, 'PostingKey', '');
                benefitsPostingItemObj.account = lodash.get(benefitsPostingItem, 'AccountSAP', '');
                benefitsPostingItemObj.alternativeReconcile = lodash.get(benefitsPostingItem, 'AlternativeReconciliationAccount', '');
                benefitsPostingItemObj.amtInDocCurr = lodash.get(benefitsPostingItem, 'Amtindoccurr', '');
                benefitsPostingItemObj.amtInLocalCurr = lodash.get(benefitsPostingItem, 'Amtinlocalcurr', '');
                benefitsPostingItemObj.taxCode = lodash.get(benefitsPostingItem, 'TaxCode', '');
                benefitsPostingItemObj.branchCode = lodash.get(benefitsPostingItem, 'BranchCode', '');
                benefitsPostingItemObj.termOfPay = lodash.get(benefitsPostingItem, 'Termsofpayment', '');
                benefitsPostingItemObj.baselineDate = lodash.get(benefitsPostingItem, 'Baselinedateforduedatecalculation', '');
                benefitsPostingItemObj.assignmentNumber = lodash.get(benefitsPostingItem, 'Assignmentnumber', '');
                benefitsPostingItemObj.text = lodash.get(benefitsPostingItem, 'Text', '');
                benefitsPostingItemObj.costCenter = lodash.get(benefitsPostingItem, 'CostCenter', '');
                benefitsPostingItemObj.longText1 = lodash.get(benefitsPostingItem, 'LongText1', '');
                benefitsPostingItemObj.longText2 = lodash.get(benefitsPostingItem, 'LongText2', '');
                benefitsPostingItemObj.longText3 = lodash.get(benefitsPostingItem, 'LongText3', '');

                benefitsPostingItemObj.benefitPayId = lodash.get(benefitsPostingItem, 'benefitPayId', '');
                benefitsPostingItemObj.empCode = lodash.get(benefitsPostingItem, 'empCode', '');
                benefitsPostingItemObj.month = moment(benefitPayStartDate).format('MM');
                benefitsPostingItemObj.year = moment(benefitPayStartDate).format('YYYY');
                benefitsPostingItemObj.numOfTime = lodash.get(benefitsPostingItem, 'numOfTime', '');
                benefitsPostingItemObj.posted = putFileToSFTP;

                benefitsPostingItemObj.changedAt = moment();
                benefitsPostingItemObj.changedBy = reqContext.getLoginUsername();
                storeNewBenefitPosting.push(benefitsPostingItemObj);
            }

            transaction = await services.getTransaction();
            let newBenefit = await dbProcess.createASWBenefitsPosting(storeNewBenefitPosting, transaction);
            if (newBenefit) {
                await transaction.commit();
            }

            functionReturn.success = true;

        } catch (error) {
            await transaction.rollback();
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - createNewASWBenefitsPosting', '', 'user', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("common.error.exception");
            bgProcess.handleError(functionReturn, res);
        } finally {
            if (transaction) {
                if (!transaction.finished) {
                    await transaction.rollback();
                }
            }
        }

        return functionReturn;
    }


    async execute(param) {

        let functionReturn = new FunctionReturn();
        let serviceApi = new ServiceApi();
        let zip = new JSZip();

        try {

            let bgProcess = param.bgProcess;
            let res = param.res;
            let putFileToSFTP = lodash.get(param, 'selection.putFileToSFTP', true);

            functionReturn = await this.validateSelection(param);
            if (functionReturn.success) {

                let keyDate = functionReturn.result.keyDate;

                functionReturn = await this.getResultPosting(param, keyDate);
                if (!functionReturn.success) {
                    bgProcess.handleError(functionReturn, res);
                    return functionReturn;
                }

                let resultData = functionReturn.result;
                for (let companyCode in resultData) {
                    if (Object.hasOwnProperty.call(resultData, companyCode)) {

                        let companyItem = resultData[companyCode];

                        let dateFormat = moment().format('YYYYMMDD');
                        let timeFormat = moment().format('HHMMSS');
                        let fileName = ``;

                        let createNewBenefit = await this.createNewASWBenefitsPosting(companyItem, putFileToSFTP);
                        if (!createNewBenefit.success) {
                            functionReturn = createNewBenefit;
                            bgProcess.handleError(functionReturn, res);
                            return functionReturn;
                        }

                        const getConfigDecryptDoc = await itftemplate.getInterfaceTemplateByInterfaceType(interfaceType);
                        const encryption = lodash.get(getConfigDecryptDoc, 'encryption', '');

                        if (encryption === 'pgp') {
                            fileName = `${fileNamePrefix}${dateFormat}_${timeFormat}.csv.pgp`;
                        } else {
                            fileName = `${fileNamePrefix}${dateFormat}_${timeFormat}.csv`;
                        }

                        let outputPath = env[reqContext.getTenantCode()].bgFileDocumentPath + fileName;

                        let newDetailList = [...companyItem].map(obj => {
                            delete obj.benefitPayId;
                            delete obj.empCode;
                            delete obj.benefitPayStartDate;
                            delete obj.numOfTime;
                            return obj;
                        });
                        const csvConfig = {
                            fileName,
                            header: await textFile.generateHeader(interfaceType, separator),
                            detailList: newDetailList,
                            bgProcess,
                        };

                        const workbook = await textFile.main(csvConfig, separator);

                        if (encryption === 'pgp') {
                            let encryptPayload = documentManager.encryptDocument(workbook.result.content, getConfigDecryptDoc);
                            let encryptResult = await encryptPayload;
                            zip.file(fileName, `${utf8WithBOMHeader}${encryptResult}`);
                            fs.writeFileSync(outputPath, `${utf8WithBOMHeader}${encryptResult}`, "utf8");
                        } else {
                            zip.file(fileName, `${utf8WithBOMHeader}${workbook.result.content}`);
                            fs.writeFileSync(outputPath, `${utf8WithBOMHeader}${workbook.result.content}`, "utf8");
                        }

                        if (putFileToSFTP) {
                            let uploadFileResponse = await this.uploadFileToSFTP(outputPath, fileName);
                            if (!uploadFileResponse.success) {
                                functionReturn = uploadFileResponse;
                                await bgProcess.handleOutputMessage(functionReturn, res);
                                return functionReturn;
                            }

                            let triggerApiResponse = await serviceApi.submitApiTriggers(fileName);

                            if (!triggerApiResponse.success) {
                                functionReturn = triggerApiResponse;
                                await bgProcess.handleOutputMessage(functionReturn, res);
                                return functionReturn;
                            }
                        }
                    }
                }

                let fileNameZip = `${zipFileNamePrefix}_${moment().format(globalConstant.dbDateFormat)}.zip`;
                let arrayBuffer = await zip.generateAsync({ type: 'arraybuffer' });
                let buffer = Buffer.from(arrayBuffer)
                await bgProcess.handleOutputFile(buffer, fileNameZip, 'application/zip', res, null)
            } else {
                functionReturn.clear();
                functionReturn.success = true;
                await bgProcess.handleOutputMessage(functionReturn, res);
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - execute', '', 'user', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("common.error.exception");
            bgProcess.handleError(functionReturn, res);
        }

        return functionReturn;
    }

    async validateSelection(param) {

        let functionReturn = new FunctionReturn();

        try {
            let selection = param.selection;
            let bgProcess = param.bgProcess;
            let res = param.res;
            let paymentDate = lodash.get(param, 'selection.paymentDate', '');
            let keyDate = moment(paymentDate).format();
            let payrollArea;
            let payrollPeriod;

            //Check permission
            functionReturn.clear();
            functionReturn = await this.adjustSelection(selection);
            if (!functionReturn.success) {
                bgProcess.handleError(functionReturn, res);
                return;
            }
            functionReturn.clear();

            //Validate payroll area input
            // functionReturn = await this.validatePayrollArea(selection.payrollArea);
            // if (functionReturn.success) {
            //     payrollArea = functionReturn.result;
            //     functionReturn.clear();

            //     if(selection.payrollType === payrollType.normal) {
            //         //Validate payroll period and payment date
            //         functionReturn = await this.validatePayrollPeriod(selection, payrollArea);
            //         if (functionReturn.success) {
            //             payrollPeriod = functionReturn.result;
            //             keyDate = payrollPeriod[0].paymentDate;
            //             functionReturn.clear();
            //         } else {
            //             bgProcess.handleError(functionReturn, res);
            //             return;
            //         }
            //     } else {
            //         keyDate = new Date(selection.paymentDate);
            //         let getPayrollAreaCodeList = lodash.map(payrollArea, (o) => o.payrollAreaCode);

            //         // if (keyDate != 'Invalid Date') {
            //         if (keyDate instanceof Date) {
            //             payrollPeriod = {
            //                 year: keyDate.getFullYear(),
            //                 period: 0,
            //                 paymentDate: keyDate,
            //                 payrollAreaCode: getPayrollAreaCodeList
            //             };
            //         } else {
            //             functionReturn.success = false;
            //             functionReturn.message = translation.getTranslateText('common.error.invalidPaymentDate'); //'Invalid payment date'
            //             bgProcess.handleError(functionReturn, res);
            //             return functionReturn;
            //         }
            //     }
            // } else {
            //     bgProcess.handleError(functionReturn, res);
            //     return functionReturn;
            // }

            functionReturn.success = true;
            functionReturn.result.keyDate = keyDate;
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - validateSelection', '', 'user', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }

        return functionReturn;

    }

    async adjustSelection(selection) {

        let functionReturn = new FunctionReturn();

        try {

            let permsParam = {
                replaceEmptyList: true,
                checkObjectList: [{
                    objectType: globalConstant.permissionObjectType.company,
                    objectList: selection.comCode
                },
                {
                    objectType: globalConstant.permissionObjectType.employee,
                    objectList: selection.empCodeList
                }]
            }

            let permission = new Permission();
            let permsReturn = await permission.checkObjectPermission(permsParam);
            if (permsReturn.success) {
                if (!arrayUtil.isEmpty(permsReturn.result.checkResult.companyList)) {
                    selection.comCode = permsReturn.result.checkResult.companyList;
                } else {
                    selection.comCode = [];
                }

                if (!arrayUtil.isEmpty(permsReturn.result.checkResult.empList)) {
                    selection.empCodeList = permsReturn.result.checkResult.empList;
                } else {
                    selection.empCodeList = [];
                }

                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = permsReturn.message;
            }
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - adjustSelection', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;

    }

    async validatePayrollArea(payrollArea) {

        let functionReturn = new FunctionReturn();
        let condition = {};

        try {

            //Check if payroll area is enter
            if (!payrollArea) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("common.error.pleaseEnterPayrollGroup"); //'Please enter Payroll Group'
            } else {

                //Set where condition for payroll area
                condition = {
                    payrollAreaCode: payrollArea
                };

                //Check if payroll area is valid
                functionReturn.result = await sh.getPayrollArea(condition);
                if (!arrayUtil.isEmpty(functionReturn.result)) {
                    functionReturn.success = true;
                } else {
                    functionReturn.success = false
                    functionReturn.message = translation.getTranslateText("common.error.noPayrollGroupFound"); //'No Payroll Group found'
                }

            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - validatePayrollArea', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;

    }

    async validatePayrollPeriod(selection, payrollPeriodCode) {

        let functionReturn = new FunctionReturn();
        const dbProcess = new DBProcess();
        let payrollPeriod = 1;
        let payrollYear = 1;
        let paymentDate = '';
        let condition = {};

        try {

            //Validate payroll month
            if (!selection.payrollPeriod) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.enterPayrollMonth");    //'Please enter Payroll Month'
                return functionReturn;
            }

            payrollPeriod = payrollPeriod * selection.payrollPeriod;

            if (isNaN(payrollPeriod)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.invalidPayrollMonth");    //'Invalid Payroll Month'
                return functionReturn;
            }

            //Validate payroll year
            if (!selection.payrollYear) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.enterPayrollYear");  //'Please enter Payroll Year'
                return functionReturn;
            }

            payrollYear = payrollYear * selection.payrollYear

            if (isNaN(payrollYear)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.invalidPayrollYear"); //'Invalid Payroll Year'
                return functionReturn;
            }

            let payrollPeriodCodeList = [];
            if (payrollPeriodCode.length > 0) {
                payrollPeriodCodeList = lodash.map(payrollPeriodCode, (o) => lodash.get(o, "payrollPeriodCode", ""));
                payrollPeriodCodeList = lodash.uniq(payrollPeriodCodeList);
            }

            //Set where condition for normal period
            condition = {
                payrollPeriodCode: {
                    [Op.in]: payrollPeriodCodeList,
                },
                period: payrollPeriod,
                year: payrollYear,
                payrollAreaCode: selection.payrollArea
            }

            if (selection.paymentDate !== null && selection.paymentDate !== '') {
                paymentDate = new Date(selection.paymentDate)
                if (paymentDate !== 'Invalid Date') {
                    condition.paymentDate = paymentDate;
                }
            }

            functionReturn.result = await dbProcess.getPayrollPeriod(condition);
            if (functionReturn.result) {
                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.invalidPayrollPeriod");   //'Invalid Payroll Period'
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - validatePayrollPeriod', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;

    }

    adjustRTRecWT(paramRTRec) {

        let rtList = paramRTRec.rtList;
        let wageTypeList = paramRTRec.wageTypeList;

        for (let wageType of wageTypeList) {
            let recList = rtList.filter(elem => elem.wtCode === wageType.recWTCode);
            if (!arrayUtil.isEmpty(recList)) {
                for (let rec of recList) {
                    let indexRec = rtList.findIndex(elem => elem.wtCode === wageType.recWTCode && elem.rgdirID === rec.rgdirID);
                    let index = rtList.findIndex(elem => elem.wtCode === wageType.wtCode && elem.rgdirID === rec.rgdirID);
                    if (index >= 0 && indexRec >= 0) {
                        rtList[index].amount = rtList[index].amount + rtList[indexRec].amount;
                        rtList.splice(indexRec, 1);
                    }
                }

            }
        }
        return rtList;
    }

    searchPYAccountEmpGrpDetail(pyAccEmpGrpDetail, comCode, empGroupCode) {

        let accEmpGrp = [];
        for (let pyAccEmpGrp of pyAccEmpGrpDetail) {
            let comCodeList = pyAccEmpGrp.comCode;
            let empGroupList = pyAccEmpGrp.empGroupCode;

            //Find comCode
            let comCodeResult = comCodeList.find(elem => elem === comCode);
            if (jsonUtil.isEmpty(comCodeResult)) {
                continue;
            }

            //Find empGroupCode
            let empGroupCodeResult = empGroupList.find(elem => elem === empGroupCode);
            if (jsonUtil.isEmpty(empGroupCodeResult) && empGroupList.length !== 0) {
                continue;
            }

            accEmpGrp.push(pyAccEmpGrp.accEmpGroupCode);
            // break;
        }

        return accEmpGrp;
    }

    async getPYAccountEmpGroupingDetail() {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let pyAccEmpGrpDetailList = await dbProcess.getPYAccountEmpGroupingDetail({});
            if (!jsonUtil.isEmpty(pyAccEmpGrpDetailList)) {

                for (let pyAccEmpGrpDetail of pyAccEmpGrpDetailList) {
                    let objDetail = JSON.parse(pyAccEmpGrpDetail.accEmpGroupDetail);
                    if (!jsonUtil.isEmpty(objDetail)) {
                        pyAccEmpGrpDetail.positionList = lodash.get(objDetail, 'positionList', []);
                        pyAccEmpGrpDetail.incSubOrg = objDetail.incSubOrg;
                        pyAccEmpGrpDetail.comCode = objDetail.companyList;
                        pyAccEmpGrpDetail.persAreaCode = objDetail.persAreaList;
                        pyAccEmpGrpDetail.persSubAreaCode = objDetail.persSubAreaList;
                        pyAccEmpGrpDetail.empGroupCode = objDetail.empGroupList;
                        pyAccEmpGrpDetail.empSubGroupCode = objDetail.empSubGroupList;
                        pyAccEmpGrpDetail.payrollAreaCode = objDetail.payrollAreaList;
                        pyAccEmpGrpDetail.orgCode = objDetail.orgList;
                        pyAccEmpGrpDetail.incEmpCode = objDetail.incEmpList;
                        pyAccEmpGrpDetail.excEmpCode = objDetail.excEmpList;
                    }
                }

                functionReturn.success = true;
                functionReturn.result = pyAccEmpGrpDetailList;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - getPYAccountEmpGroupingDetail', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async getEmployeeData(payrollDirectoryList, keyDate, selection) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let empList = [];
        let condition = {};
        let comCode = selection.comCode;

        try {

            //Get employee list from the payroll directory
            for (let payrollDirectory of payrollDirectoryList) {
                empList.push(payrollDirectory.empCode);
            }

            let storeKeyDateParam = [];
            let storeKeyDateConditon = {};
            if (lodash.isArray(keyDate)) {
                for (const keyItem of keyDate) {
                    const getEndDate = lodash.get(keyItem, "endDate", "");
                    let keyDateParam = {
                        startDate: {
                            [Op.lte]: getEndDate,
                        },
                        endDate: {
                            [Op.gte]: getEndDate,
                        },
                    };
                    storeKeyDateParam.push(keyDateParam);
                }
                storeKeyDateConditon = {
                    [Op.or]: storeKeyDateParam
                }
            } else {
                storeKeyDateConditon = {
                    startDate: {
                        [Op.lte]: keyDate
                    },
                    endDate: {
                        [Op.gte]: keyDate
                    }
                }
            }

            //Set condition for PersonalData, PersonalAssignment, BasicPay, PersonalBank
            condition = {
                personalDataCondition: {
                    empCode: empList,
                    ...storeKeyDateConditon,
                },
                personalAssignmentCondition: {
                    ...storeKeyDateConditon,
                    empCode: empList,
                },
            }

            if (comCode) {
                condition.personalAssignmentCondition.comCode = comCode
            }

            functionReturn.result = await dbProcess.getEmployeeData(condition);
            if (!arrayUtil.isEmpty(functionReturn.result)) {
                functionReturn.success = true
                empList = functionReturn.result;
            } else {
                functionReturn.success = false
                functionReturn.message = translation.getTranslateText("common.error.noEmployeeDataFound");  //'No Employee Data found'
                return functionReturn;
            }

            functionReturn.result = empList;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - getEmployeeData', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    clone(src) {
        return Object.assign({}, src)
    }

    async getPayrollResult(selection) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        let costAssignment = [];
        let costCenterList = [];
        let employeeDataList = [];
        let pyAccountDetail = [];
        let pyAccountGrouping = [];
        let pyAccountMapping = [];
        let pyAccountEmpGroupingList = [];
        let benefitPay = [];
        let pyAccount = [];
        let personalBank = [];
        let parameterList = [];
        let accountPayeeParameterList = [];
        let aswBenefitsPosting = [];
        let aswBenefitsPostingList = [];

        try {

            let includeAllTransactions = lodash.get(selection, 'includeAllTransactions', false);

            let parameterResult = await dbProcess.getParameter({
                paramGroup: pyParamGroup,
                paramName: accountPayeeParamName
            });

            let benefitCondition = {
                startDate: { [Op.lte]: moment(selection.endDate).format(globalConstant.dbDateFormat) },
                endDate: { [Op.gte]: moment(selection.startDate).format(globalConstant.dbDateFormat) },
            };

            if (selection.empCodeList.length) {
                benefitCondition = {
                    ...benefitCondition,
                    empCode: { [Op.in]: selection.empCodeList }
                };
            }

            if (parameterResult.length > 0) {
                benefitCondition = {
                    ...benefitCondition,
                    wtCode: { [Op.in]: parameterResult.map(val => val.lowValue) }
                };
            }

            if (!includeAllTransactions) {
                aswBenefitsPosting = await dbProcess.getASWBenefitsPosting({
                    posted: { [Op.ne]: 0 },
                });
            }

            if (aswBenefitsPosting.length > 0) {
                benefitCondition = {
                    ...benefitCondition,
                    id: { [Op.notIn]: lodash.uniq(aswBenefitsPosting.map(val => val.benefitPayId)) },
                };
            }

            if (selection.claimTypeCode.length > 0) {
                benefitCondition = {
                    ...benefitCondition,
                    claimTypeCode: { [Op.in]: selection.claimTypeCode }
                };
            }

            benefitPay = await dbProcess.getBenefitPay(benefitCondition);

            if (benefitPay.length === 0) {
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.dataNotFound");
                functionReturn.success = false;
                return functionReturn;
            }

            let monthYearCondition = benefitPay.map(val => {
                return {
                    month: moment(val.startDate).format('MM'),
                    year: moment(val.startDate).format('YYYY'),
                }
            });
            monthYearCondition = lodash.uniqBy(monthYearCondition, JSON.stringify);
            let benefitsPostingCondition = {
                // benefitPayId: {
                //     [Op.in]: benefitPay.map(val => val.id),
                // },
                [Op.or]: monthYearCondition
            };
            aswBenefitsPostingList = await dbProcess.getASWBenefitsPosting(benefitsPostingCondition);

            //Get PYCostAssignment
            let costAssignmentNoList = lodash.map(benefitPay, (val) => val.costAssignmentID);
            costAssignment = await dbProcess.getCostAssignment({
                id: {
                    [Op.in]: costAssignmentNoList
                }
            });


            let wbsElementList = lodash.map(costAssignment, (val) => val.wbsElement);
            wbsElementList = lodash.uniq(lodash.compact(wbsElementList));
            let costCenterConditon = {
                costCenterCode: {
                    [Op.in]: wbsElementList
                }
            };
            costCenterList = await dbProcess.getCostCenter(costCenterConditon);

            let empCodeList = lodash.map(benefitPay, (val) => val.empCode);
            empCodeList = lodash.uniq(lodash.compact(empCodeList));
            let employeeCondition = {
                personalDataCondition: {
                    empCode: {
                        [Op.in]: empCodeList
                    },
                    startDate: { [Op.lte]: moment().format(globalConstant.dbDateFormat) },
                    endDate: { [Op.gte]: moment().format(globalConstant.dbDateFormat) },
                },
                personalAssignmentCondition: {
                    empCode: {
                        [Op.in]: empCodeList
                    },
                    startDate: { [Op.lte]: moment().format(globalConstant.dbDateFormat) },
                    endDate: { [Op.gte]: moment().format(globalConstant.dbDateFormat) },
                },
            }
            employeeDataList = await dbProcess.getEmployeeData(employeeCondition);

            let companyList = lodash.map(employeeDataList, (val) => val.comCode);
            companyList = lodash.uniq(lodash.compact(companyList));
            let conditionPYAccDetail = {
                company: {
                    [Op.in]: companyList
                },
                accountGroupCode: { [Op.like]: `%${accountGroupCodePrefix}%` }
            };
            pyAccountDetail = await dbProcess.getPYAccountDetail(conditionPYAccDetail);


            let accEmpGroupCodeList = pyAccountDetail.map((val) => val.accEmpGroupCode);
            let pyAccountEmpGroupingCondition = {
                accEmpGroupCode: {
                    [Op.in]: accEmpGroupCodeList
                },
                accEmpGroupCode: { [Op.like]: `%${accountGroupCodePrefix}%` }
            };
            pyAccountEmpGroupingList = await dbProcess.getPYAccountEmpGroupingDetail(pyAccountEmpGroupingCondition);

            let accountGroupCodeList = pyAccountDetail.map((val) => val.accountGroupCode);
            let pyAccGroupingCondition = {
                accountGroupCode: {
                    [Op.in]: accountGroupCodeList
                }
            };
            pyAccountGrouping = await dbProcess.getPYAccountGrouping(pyAccGroupingCondition);

            let wtCodeList = lodash.map(benefitPay, (val) => val.wtCode);
            let accountGroupList = lodash.map(pyAccountGrouping, (val) => val.accountGroupCode);
            let conditionPYWtWithDate = {
                wtCode: {
                    [Op.in]: wtCodeList
                },
                accountGroupCode: {
                    [Op.in]: accountGroupList
                }
            }
            pyAccountMapping = await dbProcess.getPYAccountMapping(conditionPYWtWithDate);


            //Collect accountCode
            let accountCodeList = [];
            for (let pyAccDet of pyAccountDetail) {

                if (pyAccDet.credit) {
                    accountCodeList.push(pyAccDet.credit);
                }

                if (pyAccDet.debit) {
                    accountCodeList.push(pyAccDet.debit);
                }
            }
            //Get PYAccount
            let conditionPYAccount = {
                accountCode: lodash.uniq(lodash.compact(accountCodeList))
            };

            pyAccount = await dbProcess.getPYAccount(conditionPYAccount);

            let personalBankCondition = {
                empCode: {
                    [Op.in]: empCodeList,
                },
                startDate: { [Op.lte]: moment() },
                endDate: { [Op.gte]: moment() },
            }
            personalBank = await dbProcess.getPersonalBank(personalBankCondition);

            let parameterCondition = {
                paramGroup: pyParamGroup,
                paramName: accountPayeeMappingParamName,
                paramExt: {
                    [Op.in]: companyList,
                }
            };
            parameterList = await dbProcess.getParameter(parameterCondition);

            let parameterAccountPayeeCondition = {
                paramGroup: pyParamGroup,
                paramName: accountPayeeParamName,
            };
            accountPayeeParameterList = await dbProcess.getParameter(parameterAccountPayeeCondition);

            functionReturn.result.costAssignment = costAssignment;
            functionReturn.result.costCenterList = costCenterList;
            functionReturn.result.employeeDataList = employeeDataList;
            functionReturn.result.pyAccountDetail = pyAccountDetail;
            functionReturn.result.pyAccountGrouping = pyAccountGrouping;
            functionReturn.result.pyAccountMapping = pyAccountMapping;
            functionReturn.result.pyAccountEmpGroupingList = pyAccountEmpGroupingList;
            functionReturn.result.benefitPay = benefitPay;
            functionReturn.result.pyAccount = pyAccount;
            functionReturn.result.personalBank = personalBank;
            functionReturn.result.parameterList = parameterList;
            functionReturn.result.accountPayeeParameterList = accountPayeeParameterList;
            functionReturn.result.aswBenefitsPostingList = aswBenefitsPostingList;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - getPayrollResult', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    sumAmountGroupByAccGroupCode(param = []) {
        let sumResponse = [];
        try {
            let sumNormalPostingResultAmount = [];
            if (param.length < 1) return param;
            let accGroupGrouping = lodash.groupBy(param, (val) => {
                let debitCreditValue = lodash.get(val, 'debitChargeExpenseCode', '') || lodash.get(val, 'creditChargeExpenseCode', '');
                return `${val.accountGroupCode}-${debitCreditValue}-${val.orderNumber}-${val.empCode}-${val.company}-${val.pyCostAssWBSElement}-${val.benefitPayInvoiceNo}-${val.wtCode}`
            });
            sumNormalPostingResultAmount = lodash.map(accGroupGrouping, (val) => {
                const reduceAmount = lodash.reduce(val, (sum, n) => {
                    return { ...n, amount: Number(sum.amount) + Number(n.amount) };
                }, { amount: 0 });
                return reduceAmount;
            });

            sumNormalPostingResultAmount = lodash.map(sumNormalPostingResultAmount, (val) => {
                return { ...val, status: debit };
            });

            let groupByEmpCode = lodash.groupBy(sumNormalPostingResultAmount, (val) => `${val.empCode}-${val.company}-${val.pyCostAssWBSElement}-${val.benefitPayInvoiceNo}-${val.wtCode}`);
            let sumCreditAmountByEmpCode = lodash.map(groupByEmpCode, (val) => {
                const reduceAmount = lodash.reduce(val, (sum, n) => {
                    return { ...n, amount: Number(sum.amount) + Number(n.amount) };
                }, { amount: 0 });
                return reduceAmount;
            });

            sumCreditAmountByEmpCode = lodash.map(sumCreditAmountByEmpCode, (val) => {
                return { ...val, status: credit };
            });

            for (const sumItem of sumCreditAmountByEmpCode) {
                let child = sumNormalPostingResultAmount.filter(val =>
                    `${val.empCode}-${val.company}-${val.pyCostAssWBSElement}-${val.benefitPayInvoiceNo}-${val.wtCode}` ===
                    `${sumItem.empCode}-${sumItem.company}-${sumItem.pyCostAssWBSElement}-${sumItem.benefitPayInvoiceNo}-${sumItem.wtCode}`
                )
                sumResponse.push(sumItem, ...child);
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - sumAmountGroupByAccGroupCode', '', '', '', '');
            return param;
        }
        return sumResponse;
    }

    sumAmountGroupByAccGroupCodeRgdirID(param = []) {
        let sumNormalPostingResultAmount = [];
        try {
            if (param.length < 1) return param;
            let accGroupGrouping = lodash.groupBy(param, (val) => `${val.accountGroupCode}${val.rgdirID}`);
            sumNormalPostingResultAmount = lodash.map(accGroupGrouping, (val) => {
                const reduceAmount = lodash.reduce(val, (sum, n) => {
                    return { ...n, amount: Number(sum.amount) + Number(n.amount) };
                }, { amount: 0 });
                return reduceAmount;
            });
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - sumAmountGroupByAccGroupCodeRgdirID', '', '', '', '');
            return param;
        }
        return sumNormalPostingResultAmount;
    }

    async numberRangeManagers() {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let transaction = null;

        try {

            let currentYear = moment().format('YYYY');
            let condition = { year: currentYear, nrCode: numberRangeDetailNRCode };
            let numberRangResult = await dbProcess.getNumberRangeDetail(condition);

            if (lodash.isEmpty(numberRangResult)) {
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.noNumberRangeDetail");
                return functionReturn;
            }

            let currentNumber = lodash.get(numberRangResult, 'currentNumber', 0) || 0;
            let fromNumber = lodash.get(numberRangResult, 'fromNumber', 0) || 0;
            transaction = await services.getTransaction();

            if (currentNumber === 0) {
                currentNumber = fromNumber += 1;
            } else {
                currentNumber += 1;
            }

            let runningNumber = currentNumber.toString().padStart(6, '0');
            functionReturn.result = `${numberRangePrefix}${currentYear}${runningNumber}`;

            // update currentNumber
            let updateData = { ...numberRangResult, currentNumber: currentNumber };
            let updateCondition = {
                id: lodash.get(numberRangResult, 'id', ''),
                recordKey: lodash.get(numberRangResult, 'recordKey', '')
            };

            await dbProcess.updateNumberRangeDetail(updateData, updateCondition, transaction);
            await transaction.commit();

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - numberRangeManagers', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.readData");
        } finally {
            if (transaction) {
                if (!transaction.finished) {
                    await transaction.rollback();
                }
            }
        }
        return functionReturn;
    }

    async getResultPosting(param, keyDate) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let selection = param.selection;
            let bgProcess = param.bgProcess;
            let pyAccountList = [];
            let pyAccountDetailList = [];
            let pyAccountMappingList = [];
            let countProgress = 0;
            let outputResultFormat = [];
            let totalDatabase = 8;
            let outputStructureResult = outputStructure.createOutputStructure();
            let normalPostingResult = [];
            let benefitPay = [];
            let personalBank = [];
            let pyAccountGrouping = [];
            let costCenterList = [];
            let parameterList = [];
            let accountPayeeParameterList = [];
            let employeeDataList = [];
            let costAssignment = [];
            let pyCostAssignment = [];
            let parameterPyAccountPostList = [];
            let positionList = [];
            let aswBenefitsPostingList = [];

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            //Get Payroll Result
            functionReturn = await this.getPayrollResult(selection);
            if (functionReturn.success) {
                pyAccountMappingList = functionReturn.result.pyAccountMapping;
                pyAccountList = functionReturn.result.pyAccount;
                pyAccountDetailList = functionReturn.result.pyAccountDetail;
                pyCostAssignment = functionReturn.result.pyCostAssignment;
                benefitPay = functionReturn.result.benefitPay;
                personalBank = functionReturn.result.personalBank;
                pyAccountGrouping = functionReturn.result.pyAccountGrouping;
                costCenterList = functionReturn.result.costCenterList;
                employeeDataList = functionReturn.result.employeeDataList;
                parameterList = functionReturn.result.parameterList;
                costAssignment = functionReturn.result.costAssignment;
                accountPayeeParameterList = functionReturn.result.accountPayeeParameterList;
                aswBenefitsPostingList = functionReturn.result.aswBenefitsPostingList;
                functionReturn.clear();
            } else {
                return functionReturn;
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            //Get Parameter
            let parameterCondition = { paramName: parameterName };
            parameterPyAccountPostList = await dbProcess.getParameter(parameterCondition);

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            let positionCondition = {
                startDate: { [Op.lte]: moment().format(globalConstant.dbDateFormat) },
                endDate: { [Op.gte]: moment().format(globalConstant.dbDateFormat) },
            };
            positionList = await dbProcess.getPosition(positionCondition);

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            // บัญชีที่มี รายการปกติ
            for (const pyAccountItem of pyAccountMappingList) {

                let storeResult = [];
                let accountGroupCode = lodash.get(pyAccountItem, 'accountGroupCode', '');
                let pyAccountDetail = pyAccountDetailList.filter(val => val.accountGroupCode === accountGroupCode);
                for (const pyAccountDetailItem of pyAccountDetail) {
                    if (pyAccountDetailItem.reclassDebit === null && pyAccountDetailItem.reclassFlag === 1) continue;
                    let pyAccountResult = { ...pyAccountItem, ...pyAccountDetailItem };
                    storeResult.push(pyAccountResult);
                }

                for (const resultItem of storeResult) {
                    for (const benefitPayItem of benefitPay) {

                        if (benefitPayItem.wtCode !== resultItem.wtCode) continue;

                        let empCode = lodash.get(benefitPayItem, 'empCode', '');
                        let wtCode = lodash.get(resultItem, 'wtCode', '');

                        let costAssignmentID = lodash.get(benefitPayItem, 'costAssignmentID', '');

                        let costAssignmentItem = costAssignment.find((val) => {
                            return val.id === costAssignmentID
                        });

                        let wbsElement = lodash.get(costAssignmentItem, 'wbsElement', '');
                        let costAssignmentComCode = lodash.get(costAssignmentItem, 'comCode', '');
                        let pyCostAssignComCode = '';

                        let costCenterCodeWBSElement = '';
                        let costCenterCodeParameter = '';
                        let costCenterGroupCode = '';
                        let assignmentNumber = '';

                        let isWtCodeExisting = accountPayeeParameterList.find((val) => val.lowValue === wtCode);
                        if (!isWtCodeExisting) continue;

                        if (wbsElement) {
                            let costCenterTarget = lodash.find(costCenterList, (val) => val.costCenterCode === wbsElement);
                            costCenterCodeWBSElement = wbsElement;
                            pyCostAssignComCode = lodash.get(costCenterTarget, 'comCode', '');
                            costCenterGroupCode = lodash.get(costCenterTarget, 'costCenterGroupCode', '');
                            assignmentNumber = lodash.get(costCenterTarget, 'costCenterGroupCode', '');
                        }


                        if (!wbsElement) {
                            let comCodeTarget = parameterList.find(val => {
                                return lodash.get(costAssignmentItem, 'comCode', '') === val.paramExt
                            });
                            pyCostAssignComCode = lodash.get(comCodeTarget, 'paramExt', '');
                        }

                        if (costAssignmentComCode) {
                            assignmentNumber = '';
                            let costCenterTarget = parameterList.find(val => {
                                return costAssignmentComCode === val.paramExt
                            });
                            costCenterCodeParameter = lodash.get(costCenterTarget, 'lowValue', '');
                        }

                        let accountNumber = {};
                        if (empCode) accountNumber = personalBank.find(val => val.empCode === empCode);

                        let resultItemObj = {};
                        let accountCode = lodash.get(resultItem, 'debit', '') || lodash.get(resultItem, 'credit', '');
                        let pyAccountDesc = pyAccountList.find(val => val.accountCode === accountCode);
                        let pyAccountGroupingItem = pyAccountGrouping.find(val => val.accountGroupCode === lodash.get(pyAccountDetail, '[0].accountGroupCode', ''));

                        // กรองเอาเฉพาะ company ที่เลือกมาจากหน้า selection
                        let selectionComCode = lodash.get(selection, 'comCode', []);
                        if (selectionComCode.length > 0) {
                            if (selectionComCode.indexOf(pyCostAssignComCode) === -1) continue;
                        }

                        resultItemObj = {
                            ...resultItem,
                            ...benefitPayItem,
                            accountCodeDesc: lodash.get(pyAccountDesc, 'accountCodeDesc', ''),
                            separateIndicator: benefitSeparateIndicatorNumber,
                            benefitPayId: lodash.get(benefitPayItem, 'id', ''),
                            benefitPayRemarks: lodash.get(benefitPayItem, 'remarks', ''),
                            benefitPayInvoiceNo: lodash.get(benefitPayItem, 'invoiceNo', ''),
                            benefitPayWBSCode: lodash.get(benefitPayItem, 'wbsCode', ''),
                            benefitCostCenter: lodash.get(benefitPayItem, 'costCenterCode', ''),
                            accountNumber: lodash.get(accountNumber, 'accountNumber', ''),
                            bankKeyCode: lodash.get(accountNumber, 'bankKeyCode', ''),
                            accountName: lodash.get(accountNumber, 'accountName', ''),
                            pyAccountGroupingRemark: lodash.get(pyAccountGroupingItem, 'remark', ''),
                            empCode: empCode,
                            company: pyCostAssignComCode,
                            costAssignmentWBSElement: wbsElement,
                            costAssignmentComCode: costAssignmentComCode,
                            costCenterCodeWBSElement: costCenterCodeWBSElement,
                            costCenterCodeParameter: costCenterCodeParameter,
                            costCenterGroupCode: costCenterGroupCode,
                            assignmentNumber: assignmentNumber,
                            benefitPayStartDate: lodash.get(benefitPayItem, 'startDate', '')
                        };
                        normalPostingResult.push(resultItemObj);
                    }
                }
            }

            if (arrayUtil.isEmpty(normalPostingResult)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.noPyResultFound");  //'No Payroll Result found'
                return functionReturn;
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);


            // group + คำนวณ amount
            let normalAdminFilter = lodash.filter(normalPostingResult, (val) => val.reclassFlag === 0);
            let sumNormalPostingResultAmount = this.sumAmountGroupByAccGroupCode(normalAdminFilter);

            // map field obj result
            let currentComCode = '';
            let currentSeparateIndicator = '';
            let isShowTitleColumn = false;

            let groupCompany = lodash.groupBy(sumNormalPostingResultAmount, (val) => val.company);
            for (let comCode in groupCompany) {
                if (Object.hasOwnProperty.call(groupCompany, comCode)) {

                    let companyList = groupCompany[comCode];
                    let groupTemplate = lodash.groupBy(companyList, (val) =>
                        `${val.empCode}-${val.pyCostAssWBSElement}-${val.benefitPayInvoiceNo}-${val.wtCode}`
                    );

                    let currentEmpCode = 0;
                    let separateIndicator = benefitSeparateIndicatorNumber;
                    let aswBenefitsPostingListTarget = lodash.filter(aswBenefitsPostingList, val => val.refKey && val.compCode === comCode);

                    for (let templateKey in groupTemplate) {
                        if (Object.hasOwnProperty.call(groupTemplate, templateKey)) {

                            currentEmpCode += 1;
                            let element = groupTemplate[templateKey];
                            let invoiceNo = lodash.uniq(lodash.map(element, (val) => val.benefitPayInvoiceNo));

                            for (const [key, normalPostingItem] of Object.entries(element)) {

                                let index = Number(key);
                                let output = { ...outputStructureResult };
                                let company = lodash.get(normalPostingItem, 'company', '');
                                let currentYear = moment().format('YYYY');
                                let benefitRemark = lodash.get(normalPostingItem, 'benefitPayRemarks', '');
                                let longText1 = benefitRemark.substring(0, benefitRemarkEnd);
                                let longText2 = benefitRemark.substring(benefitRemarkEnd, benefitRemarkEnd * 2);
                                let bankKeyCode = lodash.get(normalPostingItem, 'bankKeyCode', '');
                                let accountName = lodash.get(normalPostingItem, 'accountName', '');
                                let pyAccGroupingRemark = lodash.get(normalPostingItem, 'pyAccountGroupingRemark', '');
                                let status = lodash.get(normalPostingItem, 'status', debit);
                                let benefitPayId = lodash.get(normalPostingItem, 'benefitPayId', '');
                                let aswBenefitsPostingItem = lodash.findLast(aswBenefitsPostingListTarget, val => {
                                    return (val.benefitPayId === benefitPayId && val.compCode === comCode)
                                });

                                if (aswBenefitsPostingItem) { // TODO Assign old refKey.
                                    separateIndicator = this.replaceAll(aswBenefitsPostingItem.refKey, 'IP-', '');
                                    separateIndicator = Number(separateIndicator.slice(6));
                                } else {                      // TODO Assign new refKey.
                                    let lastRefKey = lodash.get(lodash.last(aswBenefitsPostingListTarget), 'refKey', '');
                                    if (lastRefKey) {
                                        separateIndicator = this.replaceAll(lastRefKey, 'IP-', '');
                                        separateIndicator = Number(separateIndicator.slice(6));
                                    }
                                    separateIndicator += 1;
                                }

                                let postingCode = status === debit ? postingKeyDR : postingKeyCR;

                                if (!separateIndicator || !currentComCode || currentComCode !== company || currentSeparateIndicator !== separateIndicator) {
                                    currentComCode = company;
                                    isShowTitleColumn = true;
                                    currentSeparateIndicator = separateIndicator;
                                } else {
                                    isShowTitleColumn = false;
                                }

                                for (const outputKey of Object.keys(outputStructureResult)) {

                                    if (outputStructure.titleGroup().indexOf(outputKey) !== -1 && !isShowTitleColumn) {
                                        output[outputKey] = '';
                                        continue;
                                    }

                                    output.empCode = lodash.get(normalPostingItem, 'empCode', '');
                                    output.benefitPayId = lodash.get(normalPostingItem, 'benefitPayId', '');
                                    output.benefitPayStartDate = lodash.get(normalPostingItem, 'benefitPayStartDate', '');
                                    output.numOfTime = (lodash.get(lodash.maxBy(aswBenefitsPostingListTarget, (val) => val.numOfTime), 'numOfTime', 0) || 0) + 1;

                                    switch (outputKey) {
                                        case 'separateIndicator':
                                            output[outputKey] = currentEmpCode;
                                            break;
                                        case 'documentDate':
                                            output[outputKey] = index === 0 ? moment(keyDate) : '';
                                            break;
                                        case 'documentType':
                                            output[outputKey] = index === 0 ? documentType : '';
                                            break;
                                        case 'companyCode':
                                            output[outputKey] = lodash.get(normalPostingItem, 'company', '');
                                            break;
                                        case 'postingDate':
                                            output[outputKey] = index === 0 ? moment(keyDate) : '';
                                            break;
                                        case 'period':
                                            output[outputKey] = '';
                                            break;
                                        case 'currency':
                                            output[outputKey] = index === 0 ? currency : '';
                                            break;
                                        case 'reference':
                                            output[outputKey] = index === 0 ? this.replaceCSVReservedKeywords((invoiceNo || '').join(' ') || "") : '';
                                            break;

                                        case 'refKeyHeader1':
                                            let runningNumber = separateIndicator.toString().padStart(6, '0');
                                            let currentMonth = moment().format('MM');
                                            // output[outputKey] = index === 0 ? `${numberRangePrefix}${currentYear}${currentMonth}${runningNumber}` : '';
                                            output[outputKey] = index === 0 ? `${numberRangePrefix}${output.benefitPayId}` : '';
                                            break;

                                        case 'branchNumber':
                                            output[outputKey] = index === 0 ? branchNumber : '';
                                            break;
                                        case 'postingKey':
                                            output[outputKey] = status === debit ? postingKeyDR : postingKeyCR;
                                            break;

                                        case 'accountSAP':
                                            let accountSAPValue = "";
                                            let creditValue = lodash.get(normalPostingItem, 'credit', '');
                                            let empCode = lodash.get(normalPostingItem, 'empCode', '');

                                            if (status === credit && empCode) {
                                                let startEmpCode = empCode.substr(0, 2);
                                                let endEmpCode = empCode.substring(empCode.length - 3)
                                                accountSAPValue = `${creditValue}${startEmpCode}0${endEmpCode}`;
                                            } else {
                                                accountSAPValue = lodash.get(normalPostingItem, 'debit', '');
                                            }

                                            output[outputKey] = accountSAPValue;
                                            break;

                                        case 'alternativeReconciliationAccount':
                                            output[outputKey] = status === credit ? alternativeReconciliationAccount : '';
                                            break;
                                        case 'amtindoccurr':
                                            output[outputKey] = lodash.get(normalPostingItem, 'amount', '');
                                            break;
                                        case 'amtinlocalcurr':
                                            output[outputKey] = lodash.get(normalPostingItem, 'amount', '');
                                            break;
                                        case 'taxCode':
                                            output[outputKey] = taxCode;
                                            break;
                                        case 'branchCode':
                                            output[outputKey] = index === 0 ? branchCode : '';
                                            break;
                                        case 'termsofpayment':
                                            output[outputKey] = index === 0 ? termsofpayment : '';
                                            break;
                                        case 'baselinedateforduedatecalculation':
                                            output[outputKey] = index === 0 ? moment(keyDate) : '';
                                            break;

                                        case 'assignmentnumber':

                                            let assignmentNumberValue = "";

                                            if (postingCode === postingKeyCR) {
                                                assignmentNumberValue = bankKeyCode;
                                            } else {
                                                assignmentNumberValue = lodash.get(normalPostingItem, 'assignmentNumber', '');
                                            }

                                            output[outputKey] = assignmentNumberValue;
                                            break;

                                        case 'text':
                                            let textValue = "";

                                            if (status === credit) {
                                                textValue = accountName;
                                            } else {
                                                textValue = pyAccGroupingRemark;
                                            }
                                            output[outputKey] = this.replaceAll(textValue, ",", "");

                                            break;
                                        case 'costCenter':
                                            let costCenterResult = "";
                                            // checker
                                            let costAssignmentWBSElement = lodash.get(normalPostingItem, 'costAssignmentWBSElement', '');
                                            let costAssignmentComCode = lodash.get(normalPostingItem, 'costAssignmentComCode', '');

                                            // value
                                            let costCenterCodeWBSElement = lodash.get(normalPostingItem, 'costCenterCodeWBSElement', '');
                                            let costCenterCodeParameter = lodash.get(normalPostingItem, 'costCenterCodeParameter', '');
                                            if (postingCode === postingKeyCR) {
                                                costCenterResult = '';
                                            } else if (postingCode === postingKeyDR) {
                                                if (costAssignmentWBSElement) {
                                                    costCenterResult = costCenterCodeWBSElement;
                                                } else if (costAssignmentComCode) {
                                                    costCenterResult = costCenterCodeParameter;
                                                }
                                            }

                                            output[outputKey] = costCenterResult;

                                            break;

                                        case 'longText1':
                                            output[outputKey] = this.replaceCSVReservedKeywords(longText1);
                                            break;
                                        case 'longText2':
                                            output[outputKey] = this.replaceCSVReservedKeywords(longText2);
                                            break;
                                        case 'longText3':
                                            let accountNumber = lodash.get(normalPostingItem, 'accountNumber', '')
                                            output[outputKey] = this.replaceCSVReservedKeywords(accountNumber);
                                            break;
                                        default:
                                            break;
                                    }
                                }

                                let amtDocCurr = lodash.get(output, 'amtDocCurr', '');
                                let amtLocalCurr = lodash.get(output, 'amtLocalCurr', '');
                                let accountSAP = lodash.get(output, 'accountSAP', '').charAt(0);
                                if (amtDocCurr < 0 || amtLocalCurr < 0 && accountSAP === accountReClass) {
                                    output.amtDocCurr = Math.abs(amtDocCurr);
                                    output.amtLocalCurr = Math.abs(amtLocalCurr);
                                    output.postingKey = postingKeyType.credit;
                                }
                                outputResultFormat.push(output);
                            }
                        }
                    }
                }
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            // ปรับ template result
            let templateDetail = await services.getITemplateMapITemplateDetail(interfaceType);
            let { infFieldListIncludeDetail: detailList } = templateDetail.result;
            let formatGroup = {};

            for (let val of outputResultFormat) {

                let formatData = {
                    benefitPayId: val.benefitPayId,
                    empCode: val.empCode,
                    benefitPayStartDate: val.benefitPayStartDate,
                    numOfTime: val.numOfTime
                };
                let companyCode = lodash.get(val, 'companyCode', '');

                for (let detail of detailList) {
                    let { fieldMapping, fieldCode, dataType, infDataFormat } = detail;
                    let getValue = lodash.get(val, fieldMapping, "");

                    if (dataType === "DATE" && getValue !== '') {
                        getValue = moment(getValue).format(infDataFormat);
                    } else if (dataType === "DATE" && getValue === '') {
                        getValue = '';
                    }

                    if (fieldCode === "AmtDocCurr" || fieldCode === "AmtLocalCurr") {
                        let sign = Math.sign(getValue);
                        getValue = Number(Math.abs(getValue)).toFixed(2);
                        if (sign === -1) {
                            getValue = `${Number(Math.abs(getValue)).toFixed(2)}-`;
                        }
                    }

                    if (getValue) {
                        if (getValue[0] === '0' || getValue[0] === 0) {
                            getValue = `'${getValue}`;
                        }
                    }

                    formatData[fieldCode] = getValue;
                }

                // Group by Company
                if (!formatGroup[companyCode]) {
                    formatGroup[companyCode] = [];
                    formatGroup[companyCode].push(formatData);
                } else {
                    if (!formatData['RefKeyHeader1']) formatData.CompanyCode = "";
                    formatGroup[companyCode].push(formatData);
                }
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);
            functionReturn.success = true;
            functionReturn.result = formatGroup;
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/benefitposting/util - getResultPosting', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("tenant.assetwise.benefitPosting.error.readData");
        }
        return functionReturn;
    }
}

exports.BenefitPostingProcessingUtil = BenefitPostingProcessingUtil;
[File Ends] util.js


<-- File Content Ends


[File Ends] benefitposting.txt

[File Begins] document.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

document/
├── dbprocess.js
├── service.js
└── utils.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const db = require('../../../../config/sequelize/sequelize').getConfig();
const reqContext = require('../../../../utils/requestcontext');

class DBProcess {

  constructor() {}

  getServerConnection(condition = {}) {
      return db[reqContext.getTenantCode()].ServerConnection.findOne({
          raw: true,
          where: condition
      });
  }

  getTPTIZignDocumentList(condition = {}) {
      return db[reqContext.getTenantCode()].TPTIZignDocument.findAll({
          raw: true,
          where: condition
      });
  }

  getTPTIZignDocument(condition = {}) {
        return db[reqContext.getTenantCode()].TPTIZignDocument.findOne({
            raw: true,
            where: condition
        });
    }

  createTPTIZignDocument(data = {}, transaction) {
    return db[reqContext.getTenantCode()].TPTIZignDocument.create(data, {
        transaction: transaction
    });
  }

  createTPTIZignDocumentStatus(data = {}, transaction) {
    return db[reqContext.getTenantCode()].TPTIZignDocumentStatus.create(data, {
        transaction: transaction
    });
  }

}
exports.DBProcess = DBProcess;
[File Ends] dbprocess.js

[File Begins] service.js
const crypto = require('crypto');
const lodash = require('lodash');
const fs = require('fs');

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');
const env = require('../../../../config/environment/environment').getConfig();
const reqContext = require('../../../../utils/requestcontext');

const AWSS3 = require('../../../../utils/connection/awss3').AWSS3;
const DBProcess = require('./dbprocess').DBProcess;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

class DocumentService {

  constructor() { }

  async encryptDocumentFile(buffer, iv) {

      let functionReturn = new FunctionReturn();

      try {
          
          let encryptKey = env[reqContext.getTenantCode()].thirdParty.iZign.documentEncryptKey;
          let cipher = crypto.createCipheriv('aes-256-ctr', encryptKey, iv);
          let encryptBuffer = Buffer.concat([cipher.update(buffer), cipher.final()]);
          functionReturn.result = encryptBuffer;
          functionReturn.success = true;

      } catch (error) {
          helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - encryptDocumentFile', '', '', '', '');
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('common.error.exception');
      }
      return functionReturn;
  }

  async decryptDocumentFile(buffer, iv) {

      let functionReturn = new FunctionReturn();

      try {
          
          let encryptKey = env[reqContext.getTenantCode()].thirdParty.iZign.documentEncryptKey;
          let decipher = crypto.createDecipheriv('aes-256-ctr', encryptKey, iv);
          let decryptBuffer = Buffer.concat([decipher.update(buffer), decipher.final()]);
          functionReturn.result = decryptBuffer;
          functionReturn.success = true;

      } catch (error) {
          helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - decryptDocumentFile', '', '', '', '');
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('common.error.exception');
      }
      return functionReturn;
  }  

  async writeDocumentFile(params) {

      let functionReturn = new FunctionReturn();

      try {

          if (!params) {
              functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.document');
              return functionReturn;
          }
          
          if (!fs.existsSync(env[reqContext.getTenantCode()].thirdParty.iZign.documentPath)) {
              fs.mkdirSync(env[reqContext.getTenantCode()].thirdParty.iZign.documentPath)
          }

          let fileExt = lodash.get(params, 'fileExt', '');
          let fileBuffer = lodash.get(params, 'content', '');
          let outputIV = lodash.get(params, 'outputIV', '');
          let serverFileName = lodash.get(params, 'serverFileName', '');

          let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;
          let tempDocumentPath = env[reqContext.getTenantCode()].tempPath;

          let outputPath = `${documentPath}${serverFileName}.${fileExt}`;
          let tempOutputPath = `${tempDocumentPath}${serverFileName}.${fileExt}`;
          let buffer = await this.encryptDocumentFile(fileBuffer, outputIV);

          if (!buffer.success) {
              functionReturn = buffer;
              return functionReturn;
          }

          // Encrypt Document for Application
          fs.writeFileSync(outputPath, buffer.result);

          // Temp Document for upload to S3
          fs.writeFileSync(tempOutputPath, fileBuffer);

          functionReturn.success = true;
          functionReturn.result = {
              encryptDocumentPath: outputPath,
              tempDocumentPath: tempOutputPath
          };
          
      } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - writeDocumentFile', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
      }

      return functionReturn;
  }

  async deleteTempFile(path) {

    let functionReturn = new FunctionReturn()

    try {

        fs.unlinkSync(path);
        functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - deleteTempFile', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn
}

  async uploadFileS3(params, documentFile) {

      let functionReturn = new FunctionReturn();
      let dbProcess = new DBProcess();
      let s3 = new AWSS3();

      try {

          let tempPath = lodash.get(params, 'tempDocumentPath', '');
          let envIzign = env[reqContext.getTenantCode()].thirdParty.iZign;
          let fileExt = lodash.get(documentFile, 'fileExt', '');
          let serverFileName = lodash.get(documentFile, 'serverFileName', '');

          if (!params) {
              functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.parameter');
              return functionReturn;
          }

          if (!tempPath) {
              functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.tempPath');
              return functionReturn;
          }

          let file = fs.readFileSync(tempPath);          
          let condition = { connCode: envIzign.awsConnCode };
          let connConfig = await dbProcess.getServerConnection(condition);

          functionReturn = helper.decrypt(
              connConfig.password,
              env[reqContext.getTenantCode()].serverConnSecretKey
          )

          connConfig.password = functionReturn.result;
          let filePath = `${envIzign.awsS3Path}${serverFileName}.${fileExt}` //=>Random filename

          functionReturn = await s3.uploadFile({
              connConfig: connConfig,
              sourceFileContent: file,
              destFilePath: filePath
          })

          functionReturn = await s3.getPresignedUrl({
              connConfig: connConfig,
              filePath: filePath,
              // expires: 600 // e.g. Default 300
          })

      } catch (error) {
          helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - uploadFileS3', '', '', '', '');
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('common.error.exception');
      }
      return functionReturn;
  }

  async deleteFileS3(filePath) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();
    let s3 = new AWSS3();

    try {

        
        let envIzign = env[reqContext.getTenantCode()].thirdParty.iZign;

        if (!filePath) {
            functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.filePath');
            return functionReturn;
        }

        let condition = { connCode: envIzign.awsConnCode };
        let connConfig = await dbProcess.getServerConnection(condition);

        functionReturn = helper.decrypt(
            connConfig.password,
            env[reqContext.getTenantCode()].serverConnSecretKey
        );

        connConfig.password = functionReturn.result;

        functionReturn = await s3.deleteFile({        
            connConfig: connConfig,
            filePath: filePath
        });

    } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - uploadFileS3', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }
}

exports.DocumentService = DocumentService;

[File Ends] service.js

[File Begins] utils.js
const crypto = require('crypto');
const lodash = require('lodash');
const fs = require('fs');
const moment = require('moment');
const axios = require('axios');

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const reqContext = require('../../../../utils/requestcontext');
const db = require('../../../../config/sequelize/sequelize').getConfig();
const env = require('../../../../config/environment/environment').getConfig();

const DBProcess = require('./dbprocess').DBProcess;
const IZignApiUtils = require('../izignapi/util').Util;
const IZignService = require('../izignapi/service').IZignService;
const DocumentService = require('./service').DocumentService;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;


const ORIGINAL_FILE_NAME_PREFIX = "_CERT";
const IPOP_AUTO_DOC_PREFIX = "IPOP_";

class Util {

  constructor() { }

  getOutputIV() {
    // TODO ใช้ 10 bytes catch Invalid IV length
    return crypto.randomBytes(8).toString('hex');
  }

  getServerFileName() {
    return crypto.randomBytes(15).toString('hex');
  }

  async onCreateTPTIZignDocumentStatus(docStatusList, createDocResponse) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();
    let transaction = null;

    try {

          for (let docStatusItem of docStatusList) {
            transaction = await db[reqContext.getTenantCode()].conn.transaction();

            let newIZignDocStatusItem = {
              documentID: lodash.get(createDocResponse, 'result.id', ''),
              referenceNo: lodash.get(createDocResponse, 'result.referenceNo', ''),
              ...docStatusItem
            };

            let newIZignDocStatus = await dbProcess.createTPTIZignDocumentStatus(newIZignDocStatusItem, transaction);

            if (newIZignDocStatus) {
              await transaction.commit();
            } else {
              await transaction.rollback();
            }
          }

          functionReturn.success = true;

      } catch (error) {

        if (transaction) {
          await transaction.rollback();
        }

        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - voidDocument', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
      } finally {
        if (transaction) {
            if (!transaction.finished) {
                await transaction.rollback();
            }
        }
      }

      return functionReturn;
  }

  async iZignDocumentStatus(params) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let documentList = await dbProcess.getTPTIZignDocumentList(condition);

      for (let docItem of documentList) {

        let docStatus = lodash.get(docItem, 'status', '');
        switch (docStatus) {
          case globalConstant.iZign.ipopDocStatus.inProcess:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.inProcess');
              break;
          case globalConstant.iZign.ipopDocStatus.completed:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.completed');
              break;
          case globalConstant.iZign.ipopDocStatus.void:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.void');
              break;
          case globalConstant.iZign.ipopDocStatus.deleted:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.deleted');
              break;
          case globalConstant.iZign.ipopDocStatus.error:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.error');
              break;
          case globalConstant.iZign.ipopDocStatus.reject:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.reject');
              break;
        }
      }

    functionReturn.result = documentList;
    functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDocumentStatus', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async iZignDownloadDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let dbProcess = new DBProcess();
    let documentService = new DocumentService();

    try {

      let documentID = lodash.get(params, 'documentID', '');

      if (!documentID) {
        functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.documentID');
        return functionReturn;
      }

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignDocItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignDocItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentResult = await iZignApiUtils.downloadDocument(documentID);

      if (!documentResult.success) {
        functionReturn = documentResult;
        return functionReturn;
      }

      let serverFilename = lodash.get(iZignDocItem, 'serverFilename', '');
      let encryptIV = lodash.get(iZignDocItem, 'encryptIV', '');
      let fileUrl = lodash.get(documentResult, 'result.url', '');
      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;

      try {
        let response = await axios.get(fileUrl, { responseType: "arraybuffer" });
        functionReturn.result = lodash.get(response, 'data', '');
        functionReturn.success = true;
      } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocument (Call api iZignDownloadDocument) ', '', '', '', '');

        let errorMessage = '';
        let getENErrorMessage = lodash.get(error, 'response.data.message');
        let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

        if (reqContext.getLanguage() === 'TH') {
            errorMessage = getTHErrorMessage;
        } else {
            errorMessage = getENErrorMessage;
        }

        functionReturn.result = null;
        functionReturn.success = false;
        functionReturn.message = errorMessage;
      }

      let fileBuffer = functionReturn.result;
      let encryptBuffer = await documentService.encryptDocumentFile(fileBuffer, encryptIV);

      if (!encryptBuffer.success) {
        functionReturn = encryptBuffer;
        return functionReturn;
      }

      if (!functionReturn.success) {
        return functionReturn;
      }

      fs.writeFileSync(`${documentPath}${serverFilename}`, encryptBuffer.result);
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async iZignDownloadDocumentCertificate(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let documentService = new DocumentService();
    let dbProcess = new DBProcess();

    try {
      let documentID = lodash.get(params, 'documentID', '');

      if (!documentID) {
        functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.documentID');
        return functionReturn;
      }

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignDocItem = await dbProcess.getTPTIZignDocument(condition);
      let downloadParam = { documentId: documentID };
      let documentResult = await iZignApiUtils.downloadDocumentCertificate(downloadParam);
      if (!documentResult.success) {
        functionReturn = documentResult;
        return functionReturn;
      }

      let fileUrl = lodash.get(documentResult, 'result.url', '');
      let encryptIV = lodash.get(iZignDocItem, 'encryptIV', '');
      let docCertServerFilename = lodash.get(iZignDocItem, 'docCertServerFilename', '');
      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;

      try {
        let response = await axios.get(fileUrl, { responseType: "arraybuffer" });
        functionReturn.result = lodash.get(response, 'data', '');
        functionReturn.success = true;
      } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocumentCertificate (Call api iZignDownloadDocumentCertificate) ', '', '', '', '');
        functionReturn.result = null;
        functionReturn.success = false;
        functionReturn.message = error.message;
      }

      let fileBuffer = functionReturn.result;
      let encryptBuffer = await documentService.encryptDocumentFile(fileBuffer, encryptIV);

      if (!encryptBuffer.success) {
        functionReturn = encryptBuffer;
        return functionReturn;
      }

      if (!functionReturn.success) {
        return functionReturn;
      }

      fs.writeFileSync(`${documentPath}${docCertServerFilename}`, encryptBuffer.result);
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocumentCertificate', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async createDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let iZignService = new IZignService();
    let documentService = new DocumentService();
    let dbProcess = new DBProcess();
    let transaction = null;

    try {

        let documentFile = lodash.get(params, 'file', '');
        let docStatusList = lodash.get(params, 'docStatusList', []);

        if (!documentFile) {
            functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.document');
            return functionReturn;
        }

        let envIzign = env[reqContext.getTenantCode()].thirdParty.iZign;
        let outputIV = this.getOutputIV();
        let serverFileName = this.getServerFileName();
        let originalFileName = lodash.get(documentFile, 'fileName', '');
        let fileExt = lodash.get(documentFile, 'fileExt', '');

        // Write document file
        let writeDocParam = {
          ...documentFile,
          outputIV: outputIV,
          serverFileName: serverFileName,
          originalFileName: originalFileName,
        }
        let writeFileResponse = await documentService.writeDocumentFile(writeDocParam);

        if (!writeFileResponse.success) {
            functionReturn = writeFileResponse;
            return functionReturn;
        }

        // Upload file to S3
        let uploadFileS3 = await documentService.uploadFileS3(writeFileResponse.result, writeDocParam);

        if (!uploadFileS3.success) {
            functionReturn = uploadFileS3;
            return functionReturn;
        }

        let createDocumentParam = lodash.get(params, 'params', '');
        if (createDocumentParam) {

          let iZignIV = env[reqContext.getTenantCode()].thirdParty.iZign.iZignIV;

          let userSignerList = lodash.get(createDocumentParam, 'userSignerList', '');
          createDocumentParam.fileUrl = lodash.get(uploadFileS3, 'result.url', '');
          let enCryptKey = env[reqContext.getTenantCode()].thirdParty.iZign.iZignEncryptDataKey;

          for (const [index, userSignItem] of userSignerList.entries()) {
            let idCardNo = lodash.get(userSignItem, 'idCardNo', '');
            let encData = iZignService.encData(idCardNo, enCryptKey, iZignIV);
            userSignerList[index].idCardNo = encData;
          }

          createDocumentParam.userSignerList = userSignerList;

          // Calling iZign Api
          let createDocResponse = await iZignApiUtils.createDocument(createDocumentParam);
          transaction = await db[reqContext.getTenantCode()].conn.transaction();

          // Generate TPTIZignDocument documentID and referenceNo if create document fail
          if (createDocResponse.success === false) {
            createDocResponse.result = {
              id: `${IPOP_AUTO_DOC_PREFIX}${this.getServerFileName()}`,
              referenceNo: `${IPOP_AUTO_DOC_PREFIX}${this.getServerFileName()}`,
            }
          }

          let newTPTIZignDocument = {
            documentID: lodash.get(createDocResponse, 'result.id', ''),
            referenceNo: lodash.get(createDocResponse, 'result.referenceNo', ''),
            status: createDocResponse.success ? globalConstant.iZign.ipopDocStatus.inProcess : globalConstant.iZign.ipopDocStatus.error,
            serverFilename: `${serverFileName}.${fileExt}`,
            originalFilename: `${originalFileName}.${fileExt}`,
            encryptIV: outputIV,
            changedAt: moment(),
            changedBy: reqContext.getLoginUsername(),
            message: lodash.get(createDocResponse, 'message', ''),
            docCertServerFilename: this.getServerFileName(),
            docCertOriginalFilename: `${originalFileName}${ORIGINAL_FILE_NAME_PREFIX}.${fileExt}`,
          };

          let createIZignDoc = await dbProcess.createTPTIZignDocument(newTPTIZignDocument, transaction);
          if (createIZignDoc) {
            await transaction.commit();
          }

          // Delete file S3
          let filePath = `${envIzign.awsS3Path}${serverFileName}.${fileExt}`;
          let deleteFileS3 = await documentService.deleteFileS3(filePath);

          if (!deleteFileS3.success) {
            functionReturn = deleteFileS3;
          }

          // Delete temp file
          let tempDocumentPath = lodash.get(writeFileResponse, 'result.tempDocumentPath', '');
          await documentService.deleteTempFile(tempDocumentPath);

          // Create TPTIZignDocumentStatus
          let createDocStatus = await this.onCreateTPTIZignDocumentStatus(docStatusList, createDocResponse);
          if (!createDocStatus.success) {
            functionReturn = createDocStatus;
          }

          functionReturn = createDocResponse;

        } else {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.parameter');
        }

    } catch (error) {

      if (transaction) {
        await transaction.rollback();
      }

      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - createDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    } finally {
      if (transaction) {
          if (!transaction.finished) {
              await transaction.rollback();
          }
      }
    }

      return functionReturn;
  }

  async voidDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();

    try {

        let voidDocumentParams = {
          documentId: lodash.get(params, 'documentID', ''),
          userEmail: lodash.get(params, 'userEmail', ''),
          voidedReason: lodash.get(params, 'voidedReason', ''),
          deviceName: lodash.get(params, 'deviceName', ''),
        }

        functionReturn = await iZignApiUtils.voidDocument(voidDocumentParams);

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - voidDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async downloadDocument(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let documentService = new DocumentService();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;
      let serverFilename = lodash.get(iZignItem, 'serverFilename', '');
      let originalFilename = lodash.get(iZignItem, 'originalFilename', '');
      let iv = lodash.get(iZignItem, 'encryptIV', '');

      let outputPath = `${documentPath}${serverFilename}`;
      let buffer = fs.readFileSync(outputPath);
      let decryptBufferResult = await documentService.decryptDocumentFile(buffer, iv);

      if (!decryptBufferResult.success) {
        functionReturn = decryptBufferResult;
        return functionReturn;
      }

      functionReturn.result = {
        content: decryptBufferResult.result,
        fileName: originalFilename
      };

      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async downloadDocumentCertificate(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let documentService = new DocumentService();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;
      let docCertServerFilename = lodash.get(iZignItem, 'docCertServerFilename', '');
      let docCertOriginalFilename = lodash.get(iZignItem, 'docCertOriginalFilename', '');
      let iv = lodash.get(iZignItem, 'encryptIV', '');

      let outputPath = `${documentPath}${docCertServerFilename}`;
      let buffer = fs.readFileSync(outputPath);
      let decryptBufferResult = await documentService.decryptDocumentFile(buffer, iv);

      if (!decryptBufferResult.success) {
        functionReturn = decryptBufferResult;
        return functionReturn;
      }

      functionReturn.result = {
        content: decryptBufferResult.result,
        fileName: docCertOriginalFilename
      };

      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocumentCertificate', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async deleteDocument(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();

    try {

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let deleteDocumentParams = {
        documentId: lodash.get(params, 'documentID', ''),
        userEmail: lodash.get(params, 'userEmail', ''),
      };

      functionReturn = await iZignApiUtils.deleteDocument(deleteDocumentParams);

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }
}

exports.Util = Util;

[File Ends] utils.js


<-- File Content Ends


[File Ends] document.txt

[File Begins] email.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

email/
└── email.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] email.js
const FunctionReturn = require('../../models/common/FunctionReturn').FunctionReturn;
const db = require('../../config/sequelize/sequelize').getConfig();
const reqContext = require('../requestcontext');
const jsonUtil = require('../json');
const arrayUtil = require('../array');
const helper = require('../helper');
const cheerio = require('cheerio');
const nodemailer = require('nodemailer');
const env = require('../../config/environment/environment').getConfig();
const globalConstant = require('../../config/constant');
const fs = require('fs');
// const dbAuth = require('../controllers/auth/dbauth/dbauth');

const axios = require('axios');
const moment = require('moment');

// param = {
//   templateName,
//   templateType,
//   templateLanguage
// }
// exports.getEmailTemplateByName = async (name) => {
exports.getEmailTemplateByCondition = async (param) => {
  let functionReturn = new FunctionReturn();
  try {

    let condition = {};

    if (param.templateName) {
      condition.templateName = param.templateName;
    }

    if (param.templateType) {
      condition.templateType = param.templateType
    }

    let emailTemplateList = await db[reqContext.getTenantCode()].EmailTemplate.findAll({
      attributes: [
        'id',
        'templateName',
        'templateType',
        'templateLanguage',
        'defaultTemplate'
      ],
      raw: true,
      where: condition
    });

    if (arrayUtil.isEmpty(emailTemplateList)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }

    let emailTemplate = {};
    if (emailTemplateList.length > 1) {

      if (param.templateLanguage) {
        emailTemplate = emailTemplateList.find(elem => elem.templateLanguage == param.templateLanguage);
      }

      if (jsonUtil.isEmpty(emailTemplate)) {
        emailTemplate = emailTemplateList.find(elem => elem.defaultTemplate == true);
      }

      if (jsonUtil.isEmpty(emailTemplate)) {
        emailTemplate = emailTemplateList[0];
      }

    }
    else {
      emailTemplate = emailTemplateList[0];
    }

    if (jsonUtil.isEmpty(emailTemplate)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }

    functionReturn = await this.getEmailTemplate(emailTemplate.id);

    // let emailTemplate = await db[reqContext.getTenantCode()].EmailTemplate.findOne({
    //   attributes: [
    //     'id',
    //     'templateName',
    //     'templateType',
    //     'templateLanguage',
    //     'defaultLanguage'
    //   ],
    //   raw: true,
    //   where: {
    //     templateName: param.templateName
    //   }
    // });

    // if (jsonUtil.isEmpty(emailTemplate)) {
    //   functionReturn.success = false;
    //   functionReturn.message = 'Cannt find email template';
    //   return functionReturn;
    // }

    // functionReturn = await this.getEmailTemplate(emailTemplate.id);
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplateByCondition', 'E006', '?', param, '');
    functionReturn.success = false;
    functionReturn.message = 'Error in get email template';
  }
  return functionReturn;
}

exports.getEmailTemplate = async (id) => {

  let functionReturn = new FunctionReturn();

  try {
    let variableList = [];
    let variableGroupList = [];
    let emailTemplate = await db[reqContext.getTenantCode()].EmailTemplate.findOne({
      raw: true,
      where: {
        id: id
      }
    });

    if (jsonUtil.isEmpty(emailTemplate)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }


    if (emailTemplate.variableGroup) {
      variableGroupList = JSON.parse(emailTemplate.variableGroup);
    }

    if (!arrayUtil.isEmpty(variableGroupList)) {
      variableList = await getEmailTemplateVar(emailTemplate, variableGroupList);
    }

    functionReturn.success = true;
    functionReturn.result = {
      emailTemplate: emailTemplate,
      variableGroupList: variableGroupList,
      variableList: variableList,
    };
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplate', 'E001', '?', id, '');
    functionReturn.success = false;
    functionReturn.message = 'Error in get email template';
  }

  return functionReturn;
}

exports.getSelectedVarList = (html) => {

  let variableList = [];

  try {
    let $ = cheerio.load(html);

    $(".mention[data-value]").map(
      (index, element) => {
        let variable = {
          id: $(element).attr('data-id'),
          variableHolder: $(element).attr('data-value')
        };

        variableList.push(variable);
      }
    )
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getSelectedVarList', 'E002', '?', html, '');
  }

  return variableList;
}

const getEmailTemplateVar = async (emailTemplate, variableGroupList) => {

  let variableList = [];

  try {

    let templateVarList = await db[reqContext.getTenantCode()].TemplateVariable.findAll({
      raw: true,
      where: {
        groupCode: variableGroupList,
      }
    });

    let subjectVariableList = exports.getSelectedVarList(emailTemplate.subject);
    let bodyVariableList = exports.getSelectedVarList(emailTemplate.bodyMessage);


    for (let variable of subjectVariableList) {
      let existingVar = variableList.find(elem => elem.id == variable.id);
      if (jsonUtil.isEmpty(existingVar)) {
        variableList.push(variable);
      }
    }

    for (let variable of bodyVariableList) {
      let existingVar = variableList.find(elem => elem.id == variable.id);
      if (jsonUtil.isEmpty(existingVar)) {
        variableList.push(variable);
      }
    }

    for (let variable of variableList) {
      let templateVar = templateVarList.find(elem => elem.id == variable.id);

      if (!jsonUtil.isEmpty(templateVar)) {
        variable.groupCode = templateVar.groupCode;
        variable.variableName = templateVar.variableName;
        variable.technicalName = templateVar.technicalName;
        variable.langKeyCode = templateVar.langKeyCode;
      }
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplateVar', 'E003', '?', emailTemplate, '');
  }

  return variableList;
}


exports.replaceVariable = (html, variableList, convToText) => {

  let functionReturn = new FunctionReturn();

  try {

    let $ = cheerio.load(html, { decodeEntities: false, xmlMode: true });

    $(".mention[data-value]").map(
      (index, element) => {

        $(element).empty();
        $(element).removeAttr('class');

        let variableID = $(element).attr('data-id');
        let variableHolder = $(element).attr('data-value');

        let variable = variableList.find(elem => elem.id == variableID);
        if (!jsonUtil.isEmpty(variable)) {
          $(element).text(variable.replaceValue);
        }
        else {
          $(element).text('');
        }

      }
    )

    functionReturn.success = true;
    if (convToText) {
      functionReturn.result = $.text();
    }
    else {
      functionReturn.result = $.html();
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - replaceVariable', 'E004', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Error in replace variable';
  }

  return functionReturn;
}

// param = {
//  "subject",
//  "bodyMessage",
//  "toEmailList",
//  "ccEmailList",
//  "attachmentList"
//  "variableGroupList": [],
//  "senderDisplayName",
//  "variableList": [
//             {
//                 "id": template variable id,
//                 "variableHolder": template data-value,
//                 "groupCode",
//                 "variableName",
// 	               "replaceValue",
//             },            
//         ]
//  "transporter"
//}
exports.sendEmail = async (param) => {

  let functionReturn = new FunctionReturn();

  try {

    let subject = '';
    let bodyMessage = '';
    let emailFrom = {
      name: '',
      address: ''
    }

    // let emailAuthResult = exports.getEmailAuth(env[globalConstant.tenantCode.ipop].emailAuthSecretKey, env[globalConstant.tenantCode.ipop].emailAuthFile)

    // if (!emailAuthResult.success) {
    //   functionReturn.success = false;
    //   functionReturn.message = 'Email authentication error';
    //   return functionReturn;
    // }
    // let emailAuth = emailAuthResult.result;

    functionReturn = this.getEmailConfig();
    if (!functionReturn.success) {
      return functionReturn;
    }

    let emailConfig = functionReturn.result;

    let replaceVariableResult = exports.replaceVariable(param.subject, param.variableList, true);
    if (replaceVariableResult.success) {
      subject = replaceVariableResult.result;
    }

    replaceVariableResult = exports.replaceVariable(param.bodyMessage, param.variableList, false);
    if (replaceVariableResult.success) {
      bodyMessage = replaceVariableResult.result;
    }


    if (param.senderDisplayName) {
      emailFrom.name = param.senderDisplayName;
      // emailFrom = param.senderDisplayName + ' <' + emailConfig.senderAddress + '>';
    }
    else if (emailConfig.defaultSenderDisplayName) {
      emailFrom.name = emailConfig.defaultSenderDisplayName;
    }

    if (emailConfig.senderAddress) {
      emailFrom.address = emailConfig.senderAddress;
    }
    else {
      emailFrom.address = emailConfig.username;
    }

    let emailMessage = {
      from: emailFrom, //env[reqContext.getTenantCode()].email.senderAddress, // Sender address
      to: param.toEmailList,         // List of recipients
      cc: param.ccEmailList,
      subject: subject, // Subject line
      html: bodyMessage,
      attachments: param.attachmentList
    };

    if (emailConfig.service == globalConstant.emailService.smtp) {
      functionReturn = await sendEmail_SMTP({
        emailConfig: emailConfig,
        emailMessage: emailMessage,
        transporter: param.transporter
      })
    }
    else if (emailConfig.service == globalConstant.emailService.gmail) {
      functionReturn = await sendEmail_GMAIL({
        emailConfig: emailConfig,
        emailMessage: emailMessage,
        transporter: param.transporter
      })
    }
    else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
      functionReturn = await sendEmail_MICROSOFT_GRAPH({
        emailConfig: emailConfig,
        emailMessage: emailMessage
      })
    }

    // let transport = nodemailer.createTransport({
    //   host: emailConfig.host, //globalConstant.email.host,
    //   port: emailConfig.port, //587, //25,
    //   secure: emailConfig.secure,//false,
    //   auth: {
    //     user: emailConfig.username, //emailAuth.username,
    //     pass: emailConfig.password, //emailAuth.password
    //   },
    //   tls: { rejectUnauthorized: false }
    // });

    // let sendResult = await transport.sendMail(emailMessage);

    functionReturn.clear();
    functionReturn.success = true;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - sendEmail', 'E005', '?', param.toEmailList, '');
    functionReturn.success = false;
    functionReturn.message = 'Send email error'
  }

  return functionReturn;
}

exports.getEmailConfig = () => {

  let functionReturn = new FunctionReturn();

  try {
    let emailConfig = env[reqContext.getTenantCode()].email;

    //If not config email on tenant, get from IPOP for default
    if (jsonUtil.isEmpty(emailConfig)) {
      emailConfig = env[globalConstant.tenantCode.ipop].email;
    }

    if (jsonUtil.isEmpty(emailConfig)) {
      functionReturn.success = false;
      functionReturn.message = 'Get email config error';
      return functionReturn;
    }

    let encryptedData = fs.readFileSync(emailConfig.authFile).toString()

    functionReturn = helper.decryptToJson(encryptedData, emailConfig.authSecretKey)
    if (!functionReturn.success) {
      functionReturn.message = 'Email authentication error'
      return functionReturn
    }

    let jsonData = functionReturn.result;
    if (emailConfig.authType == globalConstant.emailAuthType.userPassword) {
      emailConfig.username = jsonData.username;
      emailConfig.password = jsonData.password;
    }
    else if (emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      // if (emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
      if (emailConfig.service == globalConstant.emailService.gmail) {
        emailConfig.username = jsonData.user;
        emailConfig.clientId = jsonData.clientId;
        emailConfig.clientSecret = jsonData.clientSecret;
        emailConfig.refreshToken = jsonData.refreshToken;
      }
      else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
        emailConfig.clientId = jsonData.clientId;
        emailConfig.clientSecret = jsonData.clientSecret;
        emailConfig.resource = jsonData.resource;
        emailConfig.grantType = jsonData.grantType;
        emailConfig.tenantId = jsonData.tenantId;
        emailConfig.username = jsonData.username;
        emailConfig.tokenUrl = jsonData.tokenUrl;
        emailConfig.sendMailUrl = jsonData.sendMailUrl;
      }
    }

    functionReturn.clear();
    functionReturn.success = true;
    functionReturn.result = emailConfig;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getEmailConfig', '', '?', '', '')
    functionReturn.success = false
    functionReturn.message = 'Get email config error'
  }

  return functionReturn

}

// // param = {
// //   emailConfig
// // }
// // exports.getEmailAuth = (authSecretKey, authFile) => {
// exports.getEmailAuth = (param) => {

//   let functionReturn = new FunctionReturn()

//   try {
//     let emailAuthResult = {};
//     let encryptedData = fs.readFileSync(param.emailConfig.authFile).toString()

//     functionReturn = helper.decrypt(encryptedData, param.emailConfig.authSecretKey)
//     if (!functionReturn.success) {
//       functionReturn.message = 'Email authentication error'
//       return functionReturn
//     }

//     let jsonData = JSON.parse(functionReturn.result);
//     functionReturn.clear();

//     if (param.emailConfig.authType == globalConstant.emailAuthType.userPassword) {
//       emailAuthResult = {
//         username: jsonData.username,
//         password: jsonData.password
//       }
//     }
//     else if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
//       if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
//         emailAuthResult = {
//           user: jsonData.user,
//           clientId: jsonData.clientId,
//           clientSecret: jsonData.clientSecret,
//           refreshToken: jsonData.refreshToken
//         }
//       }
//     }

//     functionReturn.clear();
//     functionReturn.success = true
//     functionReturn.result = emailAuthResult

//   }
//   catch (error) {
//     helper.logMessage('error', error.stack, 'email/getEmailAuth', 'E006', '?', '', '')
//     functionReturn.success = false
//     functionReturn.message = 'Email authentication error'
//   }

//   return functionReturn
// }

// param = {
//   emailConfig,
//   emailMessage,
//   transporter
// }
const sendEmail_SMTP = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;

    if (!param.transporter) {
      transporter = await getTransporter_SMTP({
        emailConfig: param.emailConfig
      })
      // transporter = nodemailer.createTransport({
      //   host: param.emailConfig.host,
      //   port: param.emailConfig.port,
      //   secure: param.emailConfig.secure,
      //   auth: {
      //     user: param.emailConfig.username,
      //     pass: param.emailConfig.password,
      //   },
      //   tls: { rejectUnauthorized: false }
      // });
    }
    else {
      transporter = param.transporter;
    }

    let sendResult = await transporter.sendMail(param.emailMessage);
    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_SMTP', '', '?', '', sendResult);
    functionReturn.clear();
    functionReturn.success = true;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_SMTP', '', '?', '', param.emailMessage.to);
    functionReturn.success = false;
    functionReturn.message = 'Send email error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   emailMessage,
//   transporter
// }
const sendEmail_GMAIL = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;

    if (!param.transporter) {

      transporter = await getTransporter_GMAIL({
        emailConfig: param.emailConfig
      });

      // let transportOption = {
      //   service: 'gmail',
      //   auth: {}
      // }

      // if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      //   transportOption.auth.type = 'OAuth2';
      //   if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
      //     transportOption.auth = {
      //       type: 'OAuth2',
      //       user: param.emailConfig.username,
      //       clientId: param.emailConfig.clientId,
      //       clientSecret: param.emailConfig.clientSecret,
      //       refreshToken: param.emailConfig.refreshToken
      //     }

      //     functionReturn = await getServiceToken({
      //       emailConfig: param.emailConfig
      //     });
      //     if (functionReturn.success) {
      //       if (functionReturn.result.accessToken) {
      //         transportOption.auth.accessToken = functionReturn.result.accessToken;
      //       }
      //     }
      //   }
      // }

      // transporter = nodemailer.createTransport(transportOption);

      // transporter.on('token', token => {

      //   updateServiceToken({
      //     service: 'gmail',
      //     authType: globalConstant.emailAuthType.oAuth2,
      //     user: token.user,
      //     accessToken: token.accessToken,
      //     tokenExpire: token.expires
      //   })

      //   helper.logMessage('info', 'A new gmail access token was generated', 'email/sendEmail_GMAIL', '', '?', '', '');
      //   helper.logMessage('info', token.user, 'email/sendEmail_GMAIL', '', '?', '', '');
      //   helper.logMessage('info', token.expires, 'email/sendEmail_GMAIL', '', '?', '', '');
      // });
    }
    else {
      transporter = param.transporter;
    }

    let sendResult = await transporter.sendMail(param.emailMessage);
    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_GMAIL', '', '?', '', sendResult);

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_GMAIL', '', '?', '', param.emailMessage.to);
    functionReturn.success = false;
    functionReturn.message = 'Send email error';

    // for(let tp of param.transporter.transporter._connections){

    // }
  }

  return functionReturn;
}

const getServiceToken = async (param) => {
  let functionReturn = new FunctionReturn();

  try {
    let accessToken = '';
    let expiredAtTimeStamp = null;
    let serviceToken = await db[reqContext.getTenantCode()].ServiceToken.findOne({
      attributes: [
        'accessToken',
        'expiredAtTimeStamp'
      ],
      raw: true,
      where: {
        serviceName: param.emailConfig.service,
        authType: param.emailConfig.authType,
        user: param.emailConfig.username
      },
      order: [
        ['expiredAtTimeStamp', 'DESC']
      ]
    });

    if (!jsonUtil.isEmpty(serviceToken)) {
      accessToken = serviceToken.accessToken;
      expiredAtTimeStamp = serviceToken.expiredAtTimeStamp;
    }

    functionReturn.success = true;
    functionReturn.result = {
      accessToken: accessToken,
      expiredAtTimeStamp: expiredAtTimeStamp
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getServiceToken', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get service token error';
  }

  return functionReturn;

}

const updateServiceToken = async (param) => {
  let functionReturn = new FunctionReturn();

  try {

    //Remove old token
    await db[reqContext.getTenantCode()].ServiceToken
      .destroy({
        where: {
          serviceName: param.service,
          authType: param.authType,
          user: param.user
        }
      });

    //Insert new token
    // let tokenExpire = parseInt(param.tokenExpire);
    await db[reqContext.getTenantCode()].ServiceToken.create({
      serviceName: param.service,
      authType: param.authType,
      user: param.user,
      accessToken: param.accessToken,
      expiredAtTimeStamp: param.tokenExpire
    });

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/updateServiceToken', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get service token error';
  }

  return functionReturn;

}

//Get own trasporter for pool connection
// param = {
//   poolConnection => true/false
// }
exports.getTransporter = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;
    let notUseTransporter = false;
    functionReturn = this.getEmailConfig();
    if (!functionReturn.success) {
      return functionReturn;
    }

    let emailConfig = functionReturn.result;
    functionReturn.clear();

    if (emailConfig.service == globalConstant.emailService.smtp) {
      transporter = await getTransporter_SMTP({
        emailConfig: emailConfig,
        poolConnection: param.poolConnection
      })
    }
    else if (emailConfig.service == globalConstant.emailService.gmail) {
      transporter = await getTransporter_GMAIL({
        emailConfig: emailConfig,
        poolConnection: param.poolConnection
      })
    }
    else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
      notUseTransporter = true;
    }

    functionReturn.clear();
    if (transporter || notUseTransporter) {
      functionReturn.success = true;
      functionReturn.result = {
        transporter: transporter,
        notUseTransporter: notUseTransporter
      }
    }
    else {
      functionReturn.success = false;
      functionReturn.message = 'Cannot get email transporter';
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get transporter error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getTransporter_SMTP = async (param) => {

  let transporter = null;

  try {

    let transportOption = {
      host: param.emailConfig.host,
      port: param.emailConfig.port,
      secure: param.emailConfig.secure,
      auth: {
        user: param.emailConfig.username,
        pass: param.emailConfig.password,
      },
      tls: { rejectUnauthorized: false }
    }

    if (param.poolConnection) {
      transportOption.pool = true;

      if (param.emailConfig.poolMaxMessages) {
        transportOption.maxMessages = param.emailConfig.poolMaxMessages;
      }
      else {
        transportOption.maxMessages = 10;
      }
    }

    transporter = nodemailer.createTransport(transportOption);

    // transporter = nodemailer.createTransport({
    //   host: param.emailConfig.host,
    //   port: param.emailConfig.port,
    //   secure: param.emailConfig.secure,
    //   auth: {
    //     user: param.emailConfig.username,
    //     pass: param.emailConfig.password,
    //   },
    //   tls: { rejectUnauthorized: false }
    // });



  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter_SMTP', '', '?', '', '');
  }

  return transporter;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getTransporter_GMAIL = async (param) => {

  let transporter = null;
  let functionReturn = new FunctionReturn();

  try {

    let transportOption = {
      service: 'gmail',
      auth: {}
    }

    if (param.poolConnection) {
      transportOption.pool = true;

      if (param.emailConfig.poolMaxMessages) {
        transportOption.maxMessages = param.emailConfig.poolMaxMessages;
      }
      else {
        transportOption.maxMessages = 100;
      }
    }

    if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      transportOption.auth.type = 'OAuth2';
      if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
        transportOption.auth = {
          type: 'OAuth2',
          user: param.emailConfig.username,
          clientId: param.emailConfig.clientId,
          clientSecret: param.emailConfig.clientSecret,
          refreshToken: param.emailConfig.refreshToken
        }

        if (!param.poolConnection) {
          functionReturn = await getServiceToken({
            emailConfig: param.emailConfig
          });
          if (functionReturn.success) {
            if (functionReturn.result.accessToken) {
              transportOption.auth.accessToken = functionReturn.result.accessToken;
            }
          }
        }
      }
    }

    transporter = nodemailer.createTransport(transportOption);

    transporter.on('token', token => {
      updateServiceToken({
        service: 'gmail',
        authType: globalConstant.emailAuthType.oAuth2,
        user: token.user,
        accessToken: token.accessToken,
        tokenExpire: token.expires
      })

      helper.logMessage('info', 'A new gmail access token was generated', 'email/sendEmail_GMAIL', '', '?', '', '');
      helper.logMessage('info', token.user, 'email/sendEmail_GMAIL', '', '?', '', '');
      helper.logMessage('info', token.expires, 'email/sendEmail_GMAIL', '', '?', '', '');
    });

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter_GMAIL', '', '?', '', '');
  }

  return transporter;
}

exports.closeTransporter = async (param) => {

  try {
    if (param.transporter) {
      param.transporter.close();
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/closeTransporter', '', '?', '', '');
  }
}


// param = {
//   emailConfig,
//   emailMessage,
// }
const sendEmail_MICROSOFT_GRAPH = async (param) => {

  let functionReturn = new FunctionReturn();

  try {

    let emailLog = '';

    functionReturn.clear();
    functionReturn = await getToken_MICROSOFT_GRAPH({
      emailConfig: param.emailConfig,
      emailMessage: param.emailMessage
    });
    if (!functionReturn.success) {
      return functionReturn;
    }

    let oAuthToken = functionReturn.result.oAuthToken;

    emailLog = 'To: '
    let toRecipients = [];
    for (let toEmail of param.emailMessage.to) {
      toRecipients.push({
        emailAddress: {
          address: toEmail
        }
      })

      emailLog += toEmail + ',';
    }

    emailLog += ' CC: '
    let ccRecipients = [];
    for (let ccEmail of param.emailMessage.cc) {
      ccRecipients.push({
        emailAddress: {
          address: ccEmail
        }
      })

      emailLog += ccEmail + ',';
    }

    let attachments = [];
    for (let attachment of param.emailMessage.attachments) {

      let contentBytes = Buffer.from(attachment.content).toString("base64");

      attachments.push({
        '@odata.type': '#microsoft.graph.fileAttachment',
        name: attachment.filename,
        contentType: attachment.contentType,
        contentBytes: contentBytes
      })
    }


    let msgPayload = {
      //Ref: https://learn.microsoft.com/en-us/graph/api/resources/message#properties
      message: {
        subject: param.emailMessage.subject,
        body: {
          contentType: 'HTML',
          content: param.emailMessage.html
        },
        toRecipients: toRecipients, //[{ emailAddress: { address: 'chairith.ar@pinno.io' } }]
        ccRecipients: ccRecipients,
        attachments: attachments
      },
      saveToSentItems: "false"
    };


    let sendResponse = await axios({ // Send Email using Microsoft Graph
      method: 'post',
      url: param.emailConfig.sendMailUrl,
      headers: {
        'Authorization': "Bearer " + oAuthToken,
        'Content-Type': 'application/json'
      },
      data: msgPayload
    })

    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_MICROSOFT_GRAPH', '', '?', '', emailLog);

    functionReturn.clear();
    functionReturn.success = true;

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_MICROSOFT_GRAPH', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Send email error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getToken_MICROSOFT_GRAPH = async (param) => {

  let tokenExpireOffsetMinute = 10;
  let functionReturn = new FunctionReturn();

  try {

    let isGetNewToken = true;
    let oAuthToken = '';

    functionReturn.clear();
    functionReturn = await getServiceToken({
      emailConfig: param.emailConfig
    });
    if (functionReturn.success) {

      let serviceToken = functionReturn.result;
      if (functionReturn.result.accessToken && serviceToken.expiredAtTimeStamp) {
        let expireAt = moment.unix(serviceToken.expiredAtTimeStamp);
        // console.log(expireAt)

        let checkExpireAt = moment().add(tokenExpireOffsetMinute, 'minutes');
        if (checkExpireAt.isBefore(expireAt)) {
          isGetNewToken = false;
          oAuthToken = functionReturn.result.accessToken;

          helper.logMessage('info', 'MS Graph email use existing token', 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
        }
      }

    }

    if (isGetNewToken || !oAuthToken) {
      let oAuthresponse = await axios({ // Get OAuth token to connect as OAuth client
        method: 'post',
        url: param.emailConfig.tokenUrl,
        data: new URLSearchParams({
          client_id: param.emailConfig.clientId,
          client_secret: param.emailConfig.clientSecret,
          resource: param.emailConfig.resource,
          grant_type: param.emailConfig.grantType
        }).toString()
      })

      let oAuthTokenData = oAuthresponse.data;
      oAuthToken = oAuthresponse.data.access_token;

      await updateServiceToken({
        service: param.emailConfig.service,
        authType: param.emailConfig.authType,
        user: param.emailConfig.username,
        accessToken: oAuthToken,
        tokenExpire: oAuthTokenData.expires_on
      })

      helper.logMessage('info', 'MS Graph email a new token was generated', 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
      // console.log(oAuthToken)
    }

    functionReturn.clear();
    functionReturn.success = true;
    functionReturn.result = {
      oAuthToken: oAuthToken
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get email token error';
  }

  return functionReturn;
}

// exports.sendEmailGSuite = async (param) => {

//   try {

//     // let gsuite = require(env[reqContext.getTenantCode()].testGSuite);

//     // let t = "test";
//     // let privateKey = "-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC4iLU96Nvw07n7\\nVOls/c5+Ew+vqJXkioHdxfVatLpeCB2HB9yia0tzQyqy9yddKAh1OF9RAfewe/QI\\n7qReKhevNKrsWYCTCd6iCSUVT9ODBejJwloGw8mW3q1m/2hqJqT+hZ/WnT6nXSrz\\nbmNnew4h1H1CW+OUXLLdqt6rE/DtVRuKB8mQihJZjsZ69tFfE4B7Vh3YFwUvqXV+\\nE8iVm8sOFpVNhN1fPdrCF8+p1ZIUz69fuGHsHeXsgazXrBkK+/ddpTGBTS4wbJqx\\nC3wACJl+LmtUsFN2pQVns/Jm5n072pvTeGB1Nxk6jh7bQ9DNm2O+B7tbZ0mYqG16\\naVfTsT7jAgMBAAECggEAIgRJbMUtLiLJiPQpJ4dN9l2rKZVpNDz4HZqtVPA13rme\\nP9MKMAKZYQEDsQPwhLKphHpEz9kOAMGIxdDACf+2Z/zMeU8ybWiHWtVWuawCcIe5\\nVt/12oNi+OXJj1ALvm2rQqP9SAGqmA2Lql4yAtRjUYcrI/1uYV4JNuWVsHG3mvgh\\neVcg3wzNYidc0T7uQA+XbUO+Piq6omiWTtpx3QHH2j1l/vBGB4ZRzsZXlphjuRfN\\nt2U8OPeFxazntqbto3Eb0zcuQpIq5V03StVfXeSryV8pMGWbr0BL5HUZeSL8zld3\\nT0mImX/6VT7WBhdtzgVAiK2eT7P/McK1MeUU3JhiWQKBgQD5o8kNM3SjJg91t3gQ\\nNPgOo/N8g8/P3v0i9GBk316P9NUNEnYHNS1TwihHrjly1KtbZRuoYMuBHIFcfl2+\\nMEh2YMFZBMeFCpSwf83zdhBF26rLxXo7JkQS2yXz3UepBQuGKtlNTI2V5d++qEzf\\nuXEet3Iz5zIEzbcPrmm3lae0JwKBgQC9PEk93/ut0cXmpqOoVGKc0X2jFwSBYqi0\\ncu0pBr+o/bl22PZcymIKFLhdeffTsmj3q3eryZWYAQrbv35H/LIe7vfGkI8fdpN6\\nOMUgNqYi5W8pqnzOJqJb3rsWtfDWLYWVNVQK2f3VLyZJNYpNHrILmfsH5xho4o0I\\nAXocbKEo5QKBgQDnWC9zumG26AifsLzlWBEhkDKPC6BEJYQ1Jn9GO/JoOh5OlPMo\\nTtGIs3+cngrDLe73LcXpznoJVp9TVhANtrUQby3/DvzPgDS3NFlp69m8w4uOd52E\\nvzuKteiADGriabh6R69FgVIcvgERsOo80p/QNXTyQKkL5pBlSd7SsS/PNQKBgCrL\\niHDCx6MOjqfTxa0asFZwle4dFXrBOg/c8b9WdF+eSaQT+tsPNc670tno7F/muBBS\\nqbSi2P7QNYluq/tRrWKLfmNca9GcuktorUPUuAuqQVJ16NWiLRODsmG3caiuEMim\\nj8QIenwMtqbVwdog9/jhsMCfxYhqu6Q02U22T1f1AoGAJEWLcEGEK+k/3uSgLApJ\\n5payjU9csZ1nb0mEMUqdAvcHuJcuqNDuGFo6TDodSOJ/B2yDkusI7DckcsXO01BS\\nR46hRZd4TgvgkRyWTjqsO7llqEyr3iP+Q23apmVu9jLFvKNVRmUIczYLgGDvxRaf\\ngDNmFs+qD7Z6vloL8bNe26Q=\\n-----END PRIVATE KEY-----\\n";
//     // // let privateKey = "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC4iLU96Nvw07n7\nVOls/c5+Ew+vqJXkioHdxfVatLpeCB2HB9yia0tzQyqy9yddKAh1OF9RAfewe/QI\n7qReKhevNKrsWYCTCd6iCSUVT9ODBejJwloGw8mW3q1m/2hqJqT+hZ/WnT6nXSrz\nbmNnew4h1H1CW+OUXLLdqt6rE/DtVRuKB8mQihJZjsZ69tFfE4B7Vh3YFwUvqXV+\nE8iVm8sOFpVNhN1fPdrCF8+p1ZIUz69fuGHsHeXsgazXrBkK+/ddpTGBTS4wbJqx\nC3wACJl+LmtUsFN2pQVns/Jm5n072pvTeGB1Nxk6jh7bQ9DNm2O+B7tbZ0mYqG16\naVfTsT7jAgMBAAECggEAIgRJbMUtLiLJiPQpJ4dN9l2rKZVpNDz4HZqtVPA13rme\nP9MKMAKZYQEDsQPwhLKphHpEz9kOAMGIxdDACf+2Z/zMeU8ybWiHWtVWuawCcIe5\nVt/12oNi+OXJj1ALvm2rQqP9SAGqmA2Lql4yAtRjUYcrI/1uYV4JNuWVsHG3mvgh\neVcg3wzNYidc0T7uQA+XbUO+Piq6omiWTtpx3QHH2j1l/vBGB4ZRzsZXlphjuRfN\nt2U8OPeFxazntqbto3Eb0zcuQpIq5V03StVfXeSryV8pMGWbr0BL5HUZeSL8zld3\nT0mImX/6VT7WBhdtzgVAiK2eT7P/McK1MeUU3JhiWQKBgQD5o8kNM3SjJg91t3gQ\nNPgOo/N8g8/P3v0i9GBk316P9NUNEnYHNS1TwihHrjly1KtbZRuoYMuBHIFcfl2+\nMEh2YMFZBMeFCpSwf83zdhBF26rLxXo7JkQS2yXz3UepBQuGKtlNTI2V5d++qEzf\nuXEet3Iz5zIEzbcPrmm3lae0JwKBgQC9PEk93/ut0cXmpqOoVGKc0X2jFwSBYqi0\ncu0pBr+o/bl22PZcymIKFLhdeffTsmj3q3eryZWYAQrbv35H/LIe7vfGkI8fdpN6\nOMUgNqYi5W8pqnzOJqJb3rsWtfDWLYWVNVQK2f3VLyZJNYpNHrILmfsH5xho4o0I\nAXocbKEo5QKBgQDnWC9zumG26AifsLzlWBEhkDKPC6BEJYQ1Jn9GO/JoOh5OlPMo\nTtGIs3+cngrDLe73LcXpznoJVp9TVhANtrUQby3/DvzPgDS3NFlp69m8w4uOd52E\nvzuKteiADGriabh6R69FgVIcvgERsOo80p/QNXTyQKkL5pBlSd7SsS/PNQKBgCrL\niHDCx6MOjqfTxa0asFZwle4dFXrBOg/c8b9WdF+eSaQT+tsPNc670tno7F/muBBS\nqbSi2P7QNYluq/tRrWKLfmNca9GcuktorUPUuAuqQVJ16NWiLRODsmG3caiuEMim\nj8QIenwMtqbVwdog9/jhsMCfxYhqu6Q02U22T1f1AoGAJEWLcEGEK+k/3uSgLApJ\n5payjU9csZ1nb0mEMUqdAvcHuJcuqNDuGFo6TDodSOJ/B2yDkusI7DckcsXO01BS\nR46hRZd4TgvgkRyWTjqsO7llqEyr3iP+Q23apmVu9jLFvKNVRmUIczYLgGDvxRaf\ngDNmFs+qD7Z6vloL8bNe26Q=\n-----END PRIVATE KEY-----\n";
//     // let nodeMailerPrivateKey = privateKey.replace(/\\n/g, "\n");

//     // const transporter = nodemailer.createTransport({
//     //   host: 'smtp.gmail.com',
//     //   port: 465,
//     //   secure: true,
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'test-378@tokyo-dream-303202.iam.gserviceaccount.com',
//     //     serviceClient: '103111922186676319248',
//     //     privateKey: privateKey
//     //   }
//     // });

//     // const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com', //gsuite.client_email,
//     //     serviceClient: gsuite.client_id,
//     //     privateKey: gsuite.private_key
//     //   }
//     // });

//     // //With refresh token from google oauth playground
//     // const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com',
//     //     clientId: '577258180606-18cg5a0a06qmrbov2dg1h5apg1epqkor.apps.googleusercontent.com',
//     //     clientSecret: 'skkW7rW0IKF0W9r4vC4FvgjG',
//     //     // refreshToken: '1//04lLudBcCSrXKCgYIARAAGAQSNwF-L9IrotbJGUbUZX7T7IIhGGpb-hULmSVxm5ju84SqdgMXOa09Y9bd4YIbsi6OI6zD2xGXe1E'
//     //     refreshToken: '1//04nBRkbhxON1zCgYIARAAGAQSNwF-L9Ir5mfrH772qbcy3CxBfk4ja0pelGKThYpSMc7aQLvpltIieIDzkpZjLpi1DjXh1bn8MMw', //old
//     //     // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//     //   }
//     // });

//     //With published consent screen
//     // A Google Cloud Platform project with an OAuth consent screen configured for an
//     // external user type and a publishing status of "Testing" is issued a refresh token expiring in 7 days.
//     // https://developers.google.com/identity/protocols/oauth2
//     const transporter = nodemailer.createTransport({
//       service: 'gmail',
//       auth: {
//         type: 'OAuth2',
//         user: 'chairith@gmail.com',
//         clientId: '322636959057-4eldjtrkrvpshp6u4q6p602t6i369du2.apps.googleusercontent.com',
//         clientSecret: 'tiZ_TYmeKa3SIFN1_EjUKwvd',
//         refreshToken: '1//04GKiOKhYspCYCgYIARAAGAQSNwF-L9IrMrAEC4rPcDW_ECOEj3yV9pzcVW0TX6DhaJ5Zz-RGSI8KB_lgO3nKgnoBEDVV9RFoCKw',
//         accessToken: 'ya29.A0AfH6SMDl73ZPNIOBYlhHoz_wiN7NVjQra9REtNVJrc-V-SU_JTK5A8eiqwVUEPu_oAWDS3r9DA3teub9jU9i3eCmDfRzxIDUQasP0qnnHieai5sESnZ-a3X6SpImZPU8WDwNooFyIZtuw3y1bstupkIJ9zheTw',
//         // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//       }
//     });

//     //End With published consent screen

//     // //************************************** */
//     // //THAILIFE ACCOUNT
//     //  //With refresh token from google oauth playground
//     //  const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'no-reply-hr4u@thailife.com',
//     //     clientId: '372108937521-nhq8v6ahbkjgq93gao0apq26319esen0.apps.googleusercontent.com',
//     //     clientSecret: 'qGOdb03v1GCEOjXgggko3_zA',
//     //     refreshToken: '1//04BbfXAOxcxpzCgYIARAAGAQSNwF-L9Ird1JjsfqgIdQXfxpqlqgxkochZe1xMU-N6UQbavSl4H1AD3-9pwIUuBCysBlWbveqy08',
//     //     // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//     //   }
//     // });
//     // //************************************** */
//     // //END THAILIFE ACCOUNT

//     // let transporter = nodemailer.createTransport({
//     //   host: 'smtp.gmail.com',
//     //   port: 465,
//     //   secure: true,
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com'
//     //   }
//     // });

//     // transporter.set('oauth2_provision_cb', (user, renew, callback) => {
//     //   // let accessToken = userTokens[user];
//     //   let accessToken = ''
//     //   if (!accessToken) {
//     //     return callback(new Error('Unknown user'));
//     //   } else {
//     //     return callback(null, accessToken);
//     //   }
//     // });

//     // await transporter.verify();
//     // await transporter.sendMail({
//     //   // from: 'test-378@tokyo-dream-303202.iam.gserviceaccount.com',
//     //   to: 'chairith@hotmail.com', //'jongkol.suw@thailife.com', //
//     //   subject: 'test gsuite email not consent',
//     //   text: 'hello world'
//     // });

//     transporter.on('token', token => {
//       console.log(token)
//       console.log('A new access token was generated');
//       console.log('User: %s', token.user);
//       console.log('Access Token: %s', token.accessToken);
//       console.log('Expires: %s', new Date(token.expires));
//       console.log('expire timestatmp %s', token.expires)
//     });

//     const message = {
//       to: param.to,         // List of recipients
//       cc: param.cc,
//       subject: param.subject, // Subject line
//       html: param.html,
//       attachments: param.attachments
//     };

//     // await transporter.sendMail(
//     //   message,
//     //   (err, info) => {
//     //     console.log(info)
//     //     console.log(info.envelope);
//     //     console.log(info.messageId);
//     //   }
//     // )

//     // console.log(transporter.transporter.auth.oauth2.accessToken)
//     // console.log(transporter.transporter.auth.oauth2.expires)

//     console.log('sent')
//   }
//   catch (error) {
//     console.log(error)
//   }

//   console.log("finish")
// }
[File Ends] email.js


<-- File Content Ends


[File Ends] email.txt

[File Begins] employeeinfo.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

employeeinfo/
├── dbprocess.js
├── excelform.js
├── main.js
├── service.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const db = require("../../../../../../config/sequelize/sequelize").getConfig();

const reqContext = require("../../../../../../utils/requestcontext");

class DBProcess {

  constructor() {}

  getPersonalAssignmentList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalAssignment.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalDataList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalData.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalIDList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalID.findAll({
      raw: true,
      where: condition,
    });
  }

  getUserList(condition = {}) {
    return db[reqContext.getTenantCode()].User.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalDateSpecificationList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalDateSpecification.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalCommunicationList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalCommunication.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalBankList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalBank.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalAddressList(condition = {}) {
    return db[reqContext.getTenantCode()].PersonalAddress.findAll({
      raw: true,
      where: condition,
    });
  }

  getPRTRConnectEmpDataResult(condition = {}) {
    return db[reqContext.getTenantCode()].PRTRConnectEmpDataResult.findAll({
      raw: true,
      where: condition,
    });
  }

  createPRTRConnectEmpDataResult(dataList = [], transaction = {}) {
    return db[reqContext.getTenantCode()].PRTRConnectEmpDataResult.bulkCreate(dataList, {
      transaction: transaction
  });
  }
}
exports.DBProcess = DBProcess;

[File Ends] dbprocess.js

[File Begins] excelform.js
const excel = require("excel4node");

const helper = require("../../../../../../utils/helper");
const translation = require("../../../../../../utils/translation");

const FunctionReturn = require("../../../../../../models/common/FunctionReturn").FunctionReturn;

class ExcelForm {

    constructor() {

    }

    async main(param) {

        let functionReturn = new FunctionReturn();
        let fileBuffer;

        try {

            let data = {
                output: param.outputData,
                columnHeader: param.columnHeader,
                selection: param.selection
            };

            functionReturn = await this.convertToExcel(data);
            if (functionReturn.success) {

                fileBuffer = await functionReturn.result.writeToBuffer().then(async (buffer) => {
                    fileBuffer = buffer;
                    return buffer
                });

                functionReturn.clear();
                functionReturn.success = true;
                functionReturn.result = { content: fileBuffer };
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/excelform - main', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async convertToExcel(param) {

        let functionReturn = new FunctionReturn();
        let workbook = new excel.Workbook();
        let reportSheet = translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.reportSheet');
        let worksheet = workbook.addWorksheet(reportSheet);
        let style = this.createCellStyle(workbook)
        let i = 0;
        let j = 0;
        let data = {}

        try {

            let reportTitle = translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.reportTitle');
            let output = param.output;
            let columnHeader = param.columnHeader;
            worksheet.cell(1, 1).string(reportTitle).style(style.headerReportTitle);

            for (i = 3; i < output.length + 4; i++) {
                if (i == 3) {
                    for (j = 1; j < columnHeader.length + 1; j++) {
                        worksheet.cell(i, j).string(columnHeader[j - 1].fieldHeader).style(style.columnHeaderStyle);
                    }
                } else {
                    data = output[i - 4];
                    for (j = 1; j < columnHeader.length + 1; j++) {
                        let val = data[columnHeader[j - 1].fieldName];
                        if (typeof val === 'string') {
                            worksheet.cell(i, j).string(val);
                        } else if (typeof val === 'number') {
                            worksheet.cell(i, j).number(val);
                        } else if(!val) {
                            worksheet.cell(i, j).string('');
                        }
                    }
                }
            }

            functionReturn.success = true;
            functionReturn.result = workbook;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/excelform - convertToExcel', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    createCellStyle(workbook) {

        return {
            columnHeaderStyle: workbook.createStyle({
                font: {
                    bold: true
                },
                alignment: {
                    horizontal: 'left',
                    vertical: 'center'
                },
                fill: {
                    type: 'pattern',
                    patternType: 'solid',
                    bgColor: '#C0C0C0',
                    fgColor: '#C0C0C0'
                },
            }),
            contentNumberStyle: workbook.createStyle({
                numberFormat: '#,##0',
            }),
            contentDateStyle: workbook.createStyle({
                numberFormat: 'dd/mm/yyyy',
            }),
            contentDateTimeStyle: workbook.createStyle({
                numberFormat: 'dd/mm/yyyy HH:mm',
            }),
            contentTimeStyle: workbook.createStyle({
                numberFormat: 'HH:mm:ss',
                alignment: {
                    horizontal: 'right',
                },
            }),
            contentTextStyle: workbook.createStyle({
                border: {
                    left: {
                        style: 'thin'
                    },
                    right: {
                        style: 'thin'
                    },
                    top: {
                        style: 'thin'
                    },
                    bottom: {
                        style: 'thin'
                    }
                }
            }),
            headerReportTitle: workbook.createStyle({
                font: {
                    bold: true
                }
            }),
            footerTitle: workbook.createStyle({
                font: {
                    bold: true,
                }
            }),
        }
    }

    validateValue(value) {
        if (value == null || value == undefined) return ''
        else return value
    }

}

exports.ExcelForm = ExcelForm;
[File Ends] excelform.js

[File Begins] main.js
const path = require("path");

const helper = require("../../../../../../utils/helper");
const translation = require("../../../../../../utils/translation");

const Util = require("./util").Util;
const BGProcess = require("../../../../../../utils/bgprocess").BGProcess;
const FunctionReturn = require("../../../../../../models/common/FunctionReturn").FunctionReturn;

const program = "TNT_PRTR04";
const interfaceType = "PRTR_INFOUT_EMPLOYEEINFO";

exports.initPage = async (req, res) => {
  let functionReturn = new FunctionReturn();
  try {

    let util = new Util();
    functionReturn = await util.initPage();

  } catch (error) {
    helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/main - initPage', '', '?', '', '')
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
  }

  res.json(functionReturn);
};

const execute = async (selection, bgProcess, res = null, next = null) => {
  let functionReturn = new FunctionReturn();
  let util = new Util();

  try {
    let param = {
      selection: selection,
      bgProcess: bgProcess,
      res: res,
      interfaceType
    }
    functionReturn = await util.execute(param);

  } catch (error) {
    helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/main - execute', '', '?', '', '')
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
    bgProcess.handleError(functionReturn, res);
  }
};

exports.submit = async (req, res, next) => {
  if (!req.body.bgProcess.isProcess) {
    await execute(req.body, new BGProcess(), res, next);
  } else {
    let controller = path.resolve(__dirname) + "/main";
    let functionReturn = await new BGProcess(program, req).start(
      controller,
      req.body
    );
    res.json(functionReturn);
  }
};

exports.jobSchedule = async (req) => {
  let controller = path.resolve(__dirname) + "/main";
  let functionReturn = await new BGProcess(program).start(controller, req.body);
  return functionReturn;
};

process.on("message", async (bgProcess) => {
  bgProcess = Object.assign(new BGProcess(), bgProcess);
  bgProcess.startAt = new Date(bgProcess.startAt);
  bgProcess.functionReturn = new FunctionReturn();
  await execute(bgProcess.selection, bgProcess);
});
[File Ends] main.js

[File Begins] service.js
const lodash = require("lodash");
const axios = require('axios');

const translation = require("../../../../../../utils/translation");
const helper = require("../../../../../../utils/helper");
const reqContext = require("../../../../../../utils/requestcontext");

const env = require("../../../../../../config/environment/environment").getConfig();

const FunctionReturn = require("../../../../../../models/common/FunctionReturn").FunctionReturn;

class PRTRService {

    constructor() {}

    getAPIToken(encryptText) {

        let functionReturn = new FunctionReturn();

        try {

            let secretKey = env[reqContext.getTenantCode()].serverConnSecretKey;
            functionReturn = helper.decrypt(encryptText, secretKey);

        } catch(error) {
            helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/service - getIZignToken', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async updateEmpInfo(params) {

        let functionReturn = new FunctionReturn();

        try {

            let { interfaceTemplateField = {}, outputDataList = [] } = params;
            let interfaceTemplate = lodash.get(interfaceTemplateField, 'template', '');
            let urlHost = lodash.get(interfaceTemplate, 'host', '');
            let sftpAlgorithm = lodash.get(interfaceTemplate, 'sftpAlgorithm', '');
            let encryptApiToken = '';
            let clientID = '';

            if (sftpAlgorithm) {
                sftpAlgorithm = JSON.parse(sftpAlgorithm);
                clientID = lodash.get(sftpAlgorithm, 'clientID', '');
                encryptApiToken = lodash.get(sftpAlgorithm, 'token', '');
            }

            let apiTokenResult = this.getAPIToken(encryptApiToken);

            let apiToken = '';
            if (apiTokenResult.success) {
                apiToken = apiTokenResult.result;
            } else {
                return functionReturn;
            }

            try {

                let outputPayload = lodash.map(outputDataList, (val) => val.payload);
                let data = JSON.stringify({"EmployeeList": outputPayload});
                let config = {
                    method: 'post',
                    maxBodyLength: Infinity,
                    url: urlHost,
                    headers: {
                        'Token': apiToken,
                        'Content-Type': 'application/json',
                        'ClientID': clientID,
                    },
                    data : data
                };

                let response = await axios.request(config)
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;

            } catch (error) {
                helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/service - updateEmpInfo (Call api) ', '', '', '', '');
                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = `API update employee info error: ${error.message}`;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/service - updateEmpInfo', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

}

exports.PRTRService = PRTRService;
[File Ends] service.js

[File Begins] util.js
const lodash = require("lodash");
const moment = require("moment");
const Sequelize = require("sequelize");

const helper = require("../../../../../../utils/helper");
const globalConstant = require("../../../../../../config/constant");
const translation = require("../../../../../../utils/translation");
const services = require("../../../../../../utils/interface/services");
const sh = require("../../../../../../utils/searchhelp");
const arrayUtil = require("../../../../../../utils/array");
const constant = require("../../../../../../config/constant");
const reqContext = require("../../../../../../utils/requestcontext");

const db = require("../../../../../../config/sequelize/sequelize").getConfig();

const DBProcess = require("./dbprocess").DBProcess;
const ExcelForm = require("./excelform").ExcelForm;
const PRTRService = require("./service").PRTRService;
const FunctionReturn = require("../../../../../../models/common/FunctionReturn").FunctionReturn;
const Permission = require("../../../../../../utils/authorization/permission/permission").Permission;

const Op = Sequelize.Op;

const GENDER_CODE = {
  "1": "M",
  "2": "F"
};
const DAY_TYPE_CODE = {
  reg: "REG",
  prob: "PROB",
  tmn: "TMN",
};
const COMMUNICATION_TYPE = {
  mob: "MOB",
  ofTel: "OFTEL",
  email: "EMAIL",
  peMai: "PEMAI",
  lineId: "LINEID",
  facebook: "FACEBOOK",
};
const DEFAULT_USER_GROUP_NAME = "EMP";
const FILE_NAME_PREFIX = "PRTR_Connect_Emp_Data";
const PROCESS_STATUS = {
  c: 'Create',
  u: 'Update',
}

class Util {
  constructor() { }

  async initPage() {
    let functionReturn = new FunctionReturn();

    try {

      let paramSHEmp = {
        condition: {},
        checkPerAssign: true
      };
      let empCodeList = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

      //-----Check permission-----//
      let permsParam = {
        replaceEmptyList: false,
        checkObjectList: [
          {
            objectType: globalConstant.permissionObjectType.employee,
            objectList: empCodeList,
            codeColumn: 'key'
          },
        ],
      };
      let permission = new Permission();
      let permsReturn = await permission.checkObjectPermission(permsParam);
      if (permsReturn.success) {
        empCodeList = permsReturn.result.checkResult.empList;
      } else {
        empCodeList = [];
      }
      //-----End check permission-----//

      functionReturn.success = true;
      functionReturn.result = {
        selectEmpType: "ALL",
        employeeSH: empCodeList,
        keyDate: moment().format(globalConstant.dbDateFormat),
        isTestRun: true
      };
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - initPage', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }
  async execute(param) {
    let functionReturn = new FunctionReturn();

    try {

      let bgProcess = param.bgProcess;
      let res = param.res;
      functionReturn = await this.getResultData(param);

      if (functionReturn.success) {
        let file = functionReturn.result;
        let fileName = `${FILE_NAME_PREFIX}_${moment().format("DDMMYYYYHH:MM:SS")}.xlsx`;
        await bgProcess.handleOutputFile(
          file.content,
          fileName,
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          res
        );
        functionReturn.clear();
        return;
      } else {
        bgProcess.handleError(functionReturn, res);
        return;
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - execute', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
      bgProcess.handleError(functionReturn, res);
    }
  }

  async getResultData(param) {

    let functionReturn = new FunctionReturn();
    let service = new PRTRService();
    let excel = new ExcelForm();
    let countProgress = 0;

    try {
      let selection = param.selection;
      let interfaceType = param.interfaceType;
      let bgProcess = param.bgProcess;
      let isTestRun = selection.isTestRun;

      let resultData = {};
      let outputDataList = [];
      let interfaceTemplateField = [];
      let updateEmpResult = [];
      let outputExcelPayload = [];
      let total = 9;

      functionReturn.clear();
      functionReturn = await this.adjustSelection(selection);
      if (!functionReturn.success) {
        return functionReturn;
      }
      functionReturn.clear();
      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, ++countProgress, total)

      functionReturn = this.validateSelection(selection);
      if (!functionReturn.success) {
        return functionReturn;
      }

      functionReturn.clear();
      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, ++countProgress, total)

      functionReturn = await this.prepareData(param);
      if (functionReturn.success) {
        resultData = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total)

      let params = { allData: resultData, ...param };
      functionReturn = await this.processData(params);
      if (functionReturn.success) {
        outputDataList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total)

      if (outputDataList.length === 0) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.error.noData');
        return functionReturn;
      }

      functionReturn = await services.getITemplateMapITemplateDetail(interfaceType);
      if (functionReturn.success) {
        interfaceTemplateField = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total)

      if (!isTestRun) {

        let updateEmpParams = {
          interfaceTemplateField: interfaceTemplateField,
          outputDataList: outputDataList
        };
        functionReturn = await service.updateEmpInfo(updateEmpParams);
        if (functionReturn.success) {
          updateEmpResult = functionReturn.result;
          functionReturn.clear();
        } else {
          return functionReturn;
        }

        await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total)

        let updatePRTRConnect = {
          updateEmpResult: updateEmpResult,
          outputDataList: outputDataList,
          ...param
        };
        functionReturn = await this.updatePRTRConnectEmpDataResult(updatePRTRConnect);
        if (functionReturn.success) {
          outputDataList = functionReturn.result;
          functionReturn.clear();
        } else {
          return functionReturn;
        }
      }

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total);

      outputExcelPayload = outputDataList.map((val) => ({
        'Status': lodash.get(val, 'processStatus.Status', '') || '',
        'Message': lodash.get(val, 'processStatus.Message', '') || '',
        'ProcessStatus': lodash.get(val, 'processStatus.ProcessStatus', '') || '',
        ...lodash.get(val, 'payload', {}) || {},
      }));

      let columnHeader = [
        {
          fieldHeader: translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.excelFrom.status'),
          fieldName: "Status"
        },
        {
          fieldHeader: translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.excelFrom.message'),
          fieldName: "Message"
        },
        {
          fieldHeader: translation.getTranslateText('tenant.prtr.interfaceOut.prtrConnect.employeeInfo.excelFrom.processStatus'),
          fieldName: "ProcessStatus"
        }
      ];

      let infFieldListIncludeDetail = lodash.get(interfaceTemplateField, "infFieldListIncludeDetail", []) || [];
      for (let headerItem of infFieldListIncludeDetail) {
        columnHeader.push({
          fieldHeader: lodash.get(headerItem, 'description', '') || '',
          fieldName: lodash.get(headerItem, 'fieldCode', '') || '',
        });
      }

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total);

      let excelParam = {
        outputData: outputExcelPayload,
        columnHeader: columnHeader,
        selection: selection
      };
      functionReturn = await excel.main(excelParam);

      await bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, countProgress++, total);

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - getResultData', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async adjustSelection(selection) {

    let functionReturn = new FunctionReturn();
    let permission = new Permission();

    try {
      let permsParam = {
        replaceEmptyList: true,
        checkObjectList: [
          {
            objectType: globalConstant.permissionObjectType.employee,
            objectList: selection.empCodeList,
          },
        ],
      };

      let permsReturn = await permission.checkObjectPermission(permsParam);
      if (permsReturn.success) {
        selection.empCodeList = permsReturn.result.checkResult.empList;
        functionReturn.success = true;
      } else {
        functionReturn.success = false;
        functionReturn.message = permsReturn.message;
      }
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - adjustSelection', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  validateSelection(selection) {
    let functionReturn = new FunctionReturn();

    try {

      if (!selection.keyDate) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText("common.error.keyDateRequired");
        return functionReturn;
      }

      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - validateSelection', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getTargetEmpCode(param = {}, condition = {}) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();

    try {

      // let bgProcess = param.bgProcess;
      // let countProgress = 2;
      // let totalDatabase = 10;
      let result = {
        personalAssignmentList: [],
        personalDataList: [],
        personalIDList: [],
        personalDateSpecificationList: [],
        personalCommunicationList: [],
        personalBankList: [],
        personalAddressList: [],
        userList: []
      };

      result.personalAssignmentList = await dbProcess.getPersonalAssignmentList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalDataList = await dbProcess.getPersonalDataList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalIDList = await dbProcess.getPersonalIDList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalDateSpecificationList = await dbProcess.getPersonalDateSpecificationList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalCommunicationList = await dbProcess.getPersonalCommunicationList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalBankList = await dbProcess.getPersonalBankList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.personalAddressList = await dbProcess.getPersonalAddressList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      result.userList = await dbProcess.getUserList(condition);

      // await bgProcess.updateStepProgress(
      //   constant.bgStepSelectData.id,
      //   ++countProgress,
      //   totalDatabase
      // );

      let empCodeList = [];
      for (let key in result) {
        if (Object.prototype.hasOwnProperty.call(result, key)) {
          let element = result[key];
          empCodeList = [...empCodeList, ...lodash.map(element, (val) => val.empCode)];
        }
      }

      functionReturn.success = true;
      functionReturn.result = lodash.uniq(empCodeList);

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - getTargetEmpCode', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async prepareData(param) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();

    try {
      let selection = param.selection;
      selection.keyDate = moment(selection.keyDate).format(globalConstant.dbDateFormat);

      let targetEmpCode = [];
      let result = {
        personalAssignmentList: [],
        personalDataList: [],
        personalIDList: [],
        personalDateSpecificationList: [],
        personalCommunicationList: [],
        personalBankList: [],
        personalAddressList: [],
        userList: [],
        titleList: [],
      };

      let orCondition = [
        {
          startDate: selection.keyDate
        },
        {
          changedAt: {
              [Op.between]: [
                moment(selection.keyDate).startOf('day'),
                moment(selection.keyDate).endOf('day'),
              ]
          }
        },
      ];

      let condition = { [Op.or]: orCondition };

      if (!arrayUtil.isEmpty(selection.empCodeList)) {
        condition.empCode = selection.empCodeList;
      }

      let empCodeList = [];
      functionReturn = await this.getTargetEmpCode(param, condition);
      if (!functionReturn.success) {
        return functionReturn;
      } else {
        empCodeList = functionReturn.result;
        functionReturn.clear();
      }

      condition = {
        empCode: empCodeList,
        // This emp code must active in system date
        startDate: { [Op.lte]: moment().format(globalConstant.dbDateFormat) },
        endDate: { [Op.gte]: moment().format(globalConstant.dbDateFormat) }
      };

      result.titleList = await sh.getTitle();
      result.posList = await sh.getPositionList();

      // =================================== Get Optional Data ===================================
      result.personalDateSpecificationList = await dbProcess.getPersonalDateSpecificationList(condition);
      result.personalCommunicationList = await dbProcess.getPersonalCommunicationList(condition);
      result.personalBankList = await dbProcess.getPersonalBankList(condition);
      result.personalAddressList = await dbProcess.getPersonalAddressList(condition);

      // =================================== Check Require Table ===================================
      let personalAssignmentList = await dbProcess.getPersonalAssignmentList(condition);
      let personalDataList = await dbProcess.getPersonalDataList(condition);
      let personalIDList = await dbProcess.getPersonalIDList(condition);
      let userList = await dbProcess.getUserList(condition);

      for (let empCode of empCodeList) {

        let personalAssignmentItem = lodash.find(personalAssignmentList, (val) => val.empCode === empCode);
        if (!personalAssignmentItem) continue;

        let personalDataItem = lodash.find(personalDataList, (val) => val.empCode === empCode);
        if (!personalDataItem) continue;

        let personalIDItem = lodash.find(personalIDList, (val) => val.empCode === empCode);
        if (!personalIDItem) continue;

        let userItem = lodash.find(userList, (val) => val.empCode === empCode);
        if (!userItem) continue;

        result.personalAssignmentList.push(personalAssignmentItem);
        result.personalDataList.push(personalDataItem);
        result.personalIDList.push(personalIDItem);
        result.userList.push(userItem);
        targetEmpCode.push(empCode);
      }

      condition = { empCode: targetEmpCode };
      let connectEmpDataResult = await dbProcess.getPRTRConnectEmpDataResult(condition);

      functionReturn.success = true;
      functionReturn.result = {
        ...result,
        targetEmpCode: targetEmpCode,
        prtrConnectEmpDataResult: connectEmpDataResult
      };

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - prepareData', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async processData(param = {}) {

    let functionReturn = new FunctionReturn();

    try {
      functionReturn.result = [];
      let { allData } = param;
      let {
        personalAddressList = [],
        personalAssignmentList = [],
        personalBankList = [],
        personalCommunicationList = [],
        personalDataList = [],
        personalDateSpecificationList = [],
        personalIDList = [],
        userList = [],
        targetEmpCode = [],
        titleList = [],
        posList = [],
        prtrConnectEmpDataResult = [],
      } = allData;

      for (let empCode of targetEmpCode) {

        let personalAssignmentItem = lodash.find(personalAssignmentList, (val) => val.empCode === empCode);
        let personalBankItem = lodash.find(personalBankList, (val) => val.empCode === empCode);
        let personalAddressItem = lodash.find(personalAddressList, (val) => val.empCode === empCode);
        let personalDataItem = lodash.find(personalDataList, (val) => val.empCode === empCode);
        let personalIDItem = lodash.find(personalIDList, (val) => val.empCode === empCode);
        let userItem = lodash.find(userList, (val) => val.empCode === empCode);

        let personalCommunicationItem = lodash.filter(personalCommunicationList, (val) => val.empCode === empCode);
        let personalCommunicationMOBItem = lodash.find(personalCommunicationItem, (val) => val.commuType === COMMUNICATION_TYPE.mob);
        let personalCommunicationOfTelItem = lodash.find(personalCommunicationItem, (val) => val.commuType === COMMUNICATION_TYPE.ofTel);
        let personalCommunicationEmailItem = lodash.find(personalCommunicationItem, (val) => val.commuType ===  COMMUNICATION_TYPE.email);
        let personalCommunicationPeMaiItem = lodash.find(personalCommunicationItem, (val) => val.commuType ===  COMMUNICATION_TYPE.peMai);
        let personalCommunicationLineIdItem = lodash.find(personalCommunicationItem, (val) => val.commuType ===  COMMUNICATION_TYPE.lineId);
        let personalCommunicationFacebookItem = lodash.find(personalCommunicationItem, (val) => val.commuType ===  COMMUNICATION_TYPE.facebook);

        let personalDateSpecificationItem = lodash.filter(personalDateSpecificationList, (val) => val.empCode === empCode);
        let personalDateSpecificationREGItem = lodash.find(personalDateSpecificationItem, (val) => val.dayTypeCode === DAY_TYPE_CODE.reg);
        let personalDateSpecificationPROBItem = lodash.find(personalDateSpecificationItem, (val) => val.dayTypeCode === DAY_TYPE_CODE.prob);
        let personalDateSpecificationTMNItem = lodash.find(personalDateSpecificationItem, (val) => val.dayTypeCode === DAY_TYPE_CODE.tmn);

        let posCode = lodash.get(personalAssignmentItem, 'posCode', '') || '';
        let titleCode = lodash.get(personalDataItem, 'titleCode', '') || '';
        let genderCode = lodash.get(personalDataItem, 'genderCode', '') || '';
        let titleTHDesc = lodash.get(lodash.find(titleList, (val) => val.titleCode === titleCode), 'thTitleDesc', '') || '';
        let titleENDesc = lodash.get(lodash.find(titleList, (val) => val.titleCode === titleCode), 'enTitleDesc', '') || '';
        let posCodeDesc = lodash.get(lodash.find(posList, (val) => val.posCode === posCode), 'posDescEN', '') || '';

        let fullAddressTH = '';
        if (personalAddressItem) {
            let addressNo = lodash.get(personalAddressItem, 'addressNo', '') || '';
            let roomNo = lodash.get(personalAddressItem, 'roomNo', '') || '';
            let floor = lodash.get(personalAddressItem, 'floor', '') || '';
            let village = lodash.get(personalAddressItem, 'village', '') || '';
            let building = lodash.get(personalAddressItem, 'building', '') || '';
            let moo = lodash.get(personalAddressItem, 'moo', '') || '';
            let soi = lodash.get(personalAddressItem, 'soi', '') || '';
            let yak = lodash.get(personalAddressItem, 'yak', '') || '';
            let street = lodash.get(personalAddressItem, 'street', '') || '';
            let subDistrict = lodash.get(personalAddressItem, 'subDistrict', '') || '';
            let district = lodash.get(personalAddressItem, 'district', '') || '';
            let province = lodash.get(personalAddressItem, 'province', '') || '';
            let postCode = lodash.get(personalAddressItem, 'postCode', '') || '';
            fullAddressTH = `${addressNo} ${roomNo} ${floor} ${village} ${building} ${moo} ${soi} ${yak} ${street} ${subDistrict} ${district} ${province} ${postCode}`;
        }

        // Validate process status CREATE or UPDATE
        let isUpdate = false;
        if (prtrConnectEmpDataResult.length > 0) {
          isUpdate = lodash.filter(prtrConnectEmpDataResult, (val) => val.empCode === empCode).length > 0;
        }

        let responseObj = {
          'EmpTypeCode': !isUpdate ? lodash.get(personalAssignmentItem, 'persAreaCode', '') || '' : '',
          'LMCode': lodash.get(personalDataItem, 'empCode', '') || '',
          'PrefixT': titleTHDesc,
          'FNameT': lodash.get(personalDataItem, 'firstFName', '') || '',
          'LNameT': lodash.get(personalDataItem, 'firstLName', '') || '',
          'PrefixE': titleENDesc,
          'FNameE': lodash.get(personalDataItem, 'secondFName', '') || '',
          'LNameE': lodash.get(personalDataItem, 'secondLName', '') || '',
          'Sex': GENDER_CODE[genderCode] || '',

          // Default empty value
          'GroupName': "",
          'DivisionsName': "",
          'DepartmentName': "",
          'SectionsName': "",
          'ProductsName': "",
          'PositionLevelName': "",
          // Default empty value

          'UserGroupName': !isUpdate ? lodash.get(userItem, 'role', '') || DEFAULT_USER_GROUP_NAME : '',
          'CitizenID': lodash.get(personalIDItem, 'identityNumber', '') || '',
          'StartWorkingDate': lodash.get(personalDateSpecificationREGItem, 'dateData', '') || '' ? moment(personalDateSpecificationREGItem.dateData).format(globalConstant.dateDisplay) : '',
          'EndWorkingDate': lodash.get(personalDateSpecificationPROBItem, 'dateData', '') || '' ? moment(personalDateSpecificationPROBItem.dateData).format(globalConstant.dateDisplay) : '',
          'PositionName': posCodeDesc,
          'UserName': lodash.get(personalDataItem, 'empCode', '') || '',

          // Default empty value
          'Password': "",
          'TimeTableName': "",
          'StationType': "",
          'IsCalLate': "",
          'IsHaveOffDayFlag': "",
          'EmployeeCode': "",
          // Default empty value

          'Telephone': lodash.get(personalCommunicationMOBItem, 'commuInfo', '') || '',

          // Default empty value
          'OTRateName': "",
          'EmployeeHolidayType': "",
          // Default empty value

          'BankAccNo': lodash.get(personalBankItem, '2064313120', '') || '',
          'BankName': lodash.get(personalBankItem, 'bankKeyCode', '') || '',
          'ContractType': lodash.get(personalAssignmentItem, 'empSubGroupCode', '') || '',

          // Default empty value
          'IsGetShift': "",
          'IsGetDiligentAllowance': "",
          // Default empty value

          'EndWorkingDate': lodash.get(personalDateSpecificationTMNItem, 'dateData', '') || '' ? moment(personalDateSpecificationTMNItem.dateData).format(globalConstant.dateDisplay) : '',
          'Birthday': lodash.get(personalDataItem, 'birthDate', '') || '' ? moment(personalDataItem.birthDate).format(globalConstant.dateDisplay) : '',
          'ContactOFC': lodash.get(personalCommunicationOfTelItem, 'commuInfo', '') || '',
          'ContactEmailOFC': lodash.get(personalCommunicationEmailItem, 'commuInfo', '') || '',
          'ContactEmailPNL': lodash.get(personalCommunicationPeMaiItem, 'commuInfo', '') || '',
          'ContactGmail': "",
          'ContactLine': lodash.get(personalCommunicationLineIdItem, 'commuInfo', '') || '',
          'ContactSkype': "",
          'ContactFacebook': lodash.get(personalCommunicationFacebookItem, 'commuInfo', '') || '',
          'Address': fullAddressTH,

          // Default empty value
          'CreateTime': "",
          'UpdateTime': "",
          // Default empty value

          'PayrollGroup': lodash.get(personalAssignmentItem, 'payrollAreaCode', '') || '',
          'EffectiveDate': lodash.get(personalAssignmentItem, 'startDate', '') || '' ? moment(personalAssignmentItem.startDate).format(globalConstant.dateDisplay) : '',
        };

        functionReturn.result.push({
          processStatus: {
            'Status': '',
            'Message': '',
            'ProcessStatus': isUpdate ? PROCESS_STATUS.u : PROCESS_STATUS.c,
          },
          payload: responseObj
        });
      }

      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/util - processData', '', '?', '', '')
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async updatePRTRConnectEmpDataResult(param = {}) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();
    let transaction = null;

    try {

      transaction = await db[reqContext.getTenantCode()].conn.transaction();
      let resultList = [];
      let { updateEmpResult, outputDataList, bgProcess } = param;
      let prtrConnectEmpDataResultUpdate = [];

      let updateEmpResultList = lodash.get(updateEmpResult, 'Data.ResponseList', []) || [];
      for (let updateItem of updateEmpResultList) {

        let outputItemList = lodash.filter(outputDataList, (val) => val.payload.LMCode === updateItem.EmployeeCode);
        for (let outputItem of outputItemList) {
          let prtrConnectItem = {
            empCode: lodash.get(outputItem, 'payload.LMCode', '') || '',
            backgroundProcessingID: bgProcess.id || '',
            interfaceType: (lodash.get(outputItem, 'processStatus.ProcessStatus', '') || 'C')[0],
            changedAt: moment(),
            changedBy: reqContext.getLoginUsername()
          };
          prtrConnectEmpDataResultUpdate.push(prtrConnectItem);
          resultList.push({
            processStatus: {
              'Status': updateItem.Status === 0 ? 'Success' : 'Fail',
              'Message': updateItem.Message || '',
              'ProcessStatus': lodash.get(outputItem, 'processStatus.ProcessStatus', '') || '',
            },
            payload: {
              ...lodash.get(outputItem, 'payload'),
            }
          });
        }
      }

      await dbProcess.createPRTRConnectEmpDataResult(prtrConnectEmpDataResultUpdate, transaction);
      await transaction.commit();

      functionReturn.result = resultList;
      functionReturn.success = true;
    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/prtr/interfaceout/employeeinfo/utilt - updatePRTRConnectEmpDataResult', '', '', '', '')
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.exception');
        await transaction.rollback();
    } finally {
        if (transaction) {
            if (!transaction.finished) {
                await transaction.rollback();
            }
        }
    }

    return functionReturn;
  }

}
exports.Util = Util;

[File Ends] util.js


<-- File Content Ends


[File Ends] employeeinfo.txt

[File Begins] emptostaffprofile.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

emptostaffprofile/
├── dbprocess.js
├── excelform.js
├── main.js
├── service.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const Sequelize = require('sequelize');

const reqContext = require('../../../../utils/requestcontext');
const db = require('../../../../config/sequelize/sequelize').getConfig();

const Op = Sequelize.Op;

const thLangKeyCode = 'TH';
const enLangKeyCode = 'EN';

class DbProcess {

    async getPersonalCommunication(condition = {}) {
        return db[reqContext.getTenantCode()].PersonalCommunication.findAll({
            raw: true,
            where: condition,
        })
    }

    async getUser(condition = {}) {
        return db[reqContext.getTenantCode()].User.findAll({
            raw: true,
            where: condition,
        })
    }

    async getPersonalData(condition = {}) {

        let personalData = db[reqContext.getTenantCode()].PersonalData;

        return personalData.findAll({
          raw: true,
          attributes: [
            'PersonalData.id',
            'PersonalData.empCode',
            'PersonalData.genderCode',
            'PersonalData.nickName',
            'PersonalData.titleCode',
            'PersonalData.firstFName',
            'PersonalData.firstMName',
            'PersonalData.firstLName',
            'PersonalData.secondFName',
            'PersonalData.secondMName',
            'PersonalData.secondLName',
            [Sequelize.col('PersonalData.changedby'), 'personalDataChangedby'],
            [Sequelize.col('PersonalData.endDate'), 'personalDataEndDate'],
            [Sequelize.col('PersonalData.startDate'), 'personalDataStartDate'],
            [Sequelize.col('PersonalData.changedAt'), 'personalDataChangedAt']
          ],
          where: condition,
        //   order: [
            //   ['id', 'DESC'],
            // ['empCode', 'ASC'],
        //   ],
        //   group: ['empCode'],
        });
    }

    async getOrganization(condition) {
        return db[reqContext.getTenantCode()].Organization.findAll({
          raw: true,
          attributes: [
            "orgCode",
            ["firstDesc", "thOrganization"],
            ["secondDesc", "enOrganization"],
            "costCenterCode",
            "parentOrgCode",
            "orgLevelCode",
            "startDate",
            "endDate",
            "changedAt",
            "changedby",
            "companyCode",
          ],
          where: condition,
          order: [["orgCode", "ASC"]],
        });
      }

    getPosition(condition = {}) {
        return db[reqContext.getTenantCode()].Position.findAll({
            raw: true,
            attributes: [
                'posCode',
                'headOfOrg',
                'parentPosition',
                'parentOrgCode',
                ['firstDesc', 'thPosition'],
                ['secondDesc', 'enPosition']
            ],
            where: condition,
            order: [
                ['posCode', 'ASC']
            ]
        })
    }

    getPersonalDateSpecification(condition = {}) {
        return db[reqContext.getTenantCode()].PersonalDateSpecification.findAll({
            raw: true,
            where: condition,
        })
    }

    getServerConnection(condition = {}) {
        return db[reqContext.getTenantCode()].ServerConnection.findOne({
            raw: true,
            where: condition
        })
    }

    getParameter(condition = {}) {
        return db[reqContext.getTenantCode()].Parameter.findOne({
            raw: true,
            where: condition
        })
    }


    getOrganizationLevel(condition = {}) {
        return db[reqContext.getTenantCode()].OrganizationLevel.findAll({
            raw: true,
            where: condition
        })
    }

    getObjectRelation(condition = {}) {
        return db[reqContext.getTenantCode()].ObjectRelation.findAll({
            raw: true,
            where: condition
        })
    }

    getPersonalDateSpecification(condition = {}) {
        return db[reqContext.getTenantCode()].PersonalDateSpecification.findAll({
            raw: true,
            where: condition
        })
    }

    getTimeWSR(condition = {}) {
        return db[reqContext.getTenantCode()].TimeWSR.findAll({
            raw: true,
            where: condition
        })
    }

    getConfigText(condition = {}) {
        return db[reqContext.getTenantCode()].ConfigText.findAll({
            raw: true,
            where: condition
        })
    }

    getTMWsWsr(condition = {}) {
        return db[reqContext.getTenantCode()].TMWsWsr.findAll({
            raw: true,
            attributes: [
                'wsWsrCode',
                [Sequelize.col('ConfigText.description'), 'wsWsrText'],
            ],
            include: [
                {
                    required: false,
                    model: db[reqContext.getTenantCode()].ConfigText,
                    attributes: [],
                    where: {
                        configTableCode: 'TMWsWsr',
                        langKeyCode: thLangKeyCode
                    }
                }
            ],
            where: condition
        })
    }

    getJobLevel(condition = {}) {
        return db[reqContext.getTenantCode()].PAPositionLevel.findAll({
            raw: true,
            attributes: [
                ['positionLevelCode', 'jobLevelCode'],
                [Sequelize.col("ConfigText.langKeyCode"), "langKeyCode"],
                [Sequelize.col('ConfigText.description'), 'jobLevelText'],
            ],
            include: [
                {
                    required: false,
                    model: db[reqContext.getTenantCode()].ConfigText,
                    attributes: [],
                    where: {
                        configTableCode: 'PAPositionLevel',
                        [Op.or]: [
                            { langKeyCode: thLangKeyCode },
                            { langKeyCode: enLangKeyCode }
                        ]
                    }
                }
            ],
            where: condition,
        })
    }

    getEmployeeGroup(condition = {}) {

        return db[reqContext.getTenantCode()].EmpGroup.findAll({
            raw: true,
            attributes: [
                'id',
                'empGroupCode',
                [Sequelize.col("ConfigText.langKeyCode"), "langKeyCode"],
                [Sequelize.col('ConfigText.description'), 'description'],
            ],
            where: condition,
            include: [{
                model: db[reqContext.getTenantCode()].ConfigText,
                attributes: [],
                where: {
                    configTableCode: 'EmpGroup',
                    [Op.or]: [
                        { langKeyCode: thLangKeyCode },
                        { langKeyCode: enLangKeyCode }
                    ]
                }
            }],
            order: [
                ['empGroupCode', 'ASC']
            ]
        })
    }

    getEmpSubGroup(condition = {}) {

        return db[reqContext.getTenantCode()].EmpSubGroup.findAll({
            raw: true,
            attributes: [
                'id',
                'empSubGroupCode',
                [Sequelize.col("ConfigText.langKeyCode"), "langKeyCode"],
                [Sequelize.col('ConfigText.description'), 'description'],
            ],
            where: condition,
            include: [{
                model: db[reqContext.getTenantCode()].ConfigText,
                attributes: [],
                where: {
                    configTableCode: 'EmpSubGroup',
                    [Op.or]: [
                        { langKeyCode: thLangKeyCode },
                        { langKeyCode: enLangKeyCode }
                    ]
                }
            }],
        })
    }

    async getOneUser(condition = {}) {
        return db[reqContext.getTenantCode()].User.findOne({
            raw: true,
            where: condition,
        })
    }

    async getPersonalAssignment(condition = {}) {
        let personalAssignment = db[reqContext.getTenantCode()].PersonalAssignment;
        return personalAssignment.findAll({
            raw: true,
            where: condition,
        });
    }

    async getSYMCStaffProfileTermination(condition = {}) {
        let SYMCStaffProfileTermination = db[reqContext.getTenantCode()].SYMCStaffProfileTermination;
        return SYMCStaffProfileTermination.findAll({
            raw: true,
            where: condition,
        });
    }

    async deleteSYMCStaffProfileTermination(transaction, condition = {}) {
        return db[reqContext.getTenantCode()].SYMCStaffProfileTermination
        .destroy({
            where: condition,
            transaction: transaction
        })
      }

    async createSYMCStaffProfileTermination(data, transaction) {
        return db[reqContext.getTenantCode()].SYMCStaffProfileTermination.create(data, {
            transaction: transaction
        })
    }
}
exports.DbProcess = DbProcess;

[File Ends] dbprocess.js

[File Begins] excelform.js
const moment = require('moment');
const excel = require('excel4node');
const lodash = require('lodash');

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');

const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const DATE_FORMAT = "YYYYMMDD";
const TIME_FORMAT = "HHmmss";
const OUTPUT_FILE_STATUS = {
  complete: "SUCCESS",
  error: "ERROR"
}

const OUTPUT_HEADER_FIELDS = [
  'status',
  'message',
  'messageID',
  'businessEvent',
  'sourceSystemID',
  'sentDttm',
];

const OUTPUT_BODY = [
  'startDate',
  'eventType'
]

class ExcelForm {
  async main(param) {

    let functionReturn = new FunctionReturn();
    let fileBuffer;
    let fileWb;

    try {

      let outputData = param.outputData;
      let columnHeader = param.columnHeader;
      let dataOutput = {
        output: outputData,
        columnHeader: [...OUTPUT_HEADER_FIELDS, ...columnHeader, ...OUTPUT_BODY],
      };

      functionReturn = await this.convertToExcel({ dataOutput: dataOutput });

      if (functionReturn.success) {
        fileWb = functionReturn.result;
        fileBuffer = await functionReturn.result.writeToBuffer().then(async (buffer) => {
          fileBuffer = buffer;
          return buffer;
        });

        let filename = translation.getTranslateText('tenant.symc.empToStaffProfile.outputFileName');

        functionReturn.success = true;
        functionReturn.result = {
          fileWb,
          content: fileBuffer,
          fileName: `${filename}_${moment().format(DATE_FORMAT)}_${moment().format(TIME_FORMAT)}`,
          fileExt: 'xlsx',
        };
      }
    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/usertoldap/excelform - main', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async convertToExcel(params) {

    const { dataOutput } = params;
    let functionReturn = new FunctionReturn();
    let workbook = new excel.Workbook();
    let worksheet = workbook.addWorksheet(translation.getTranslateText('tenant.symc.empToStaffProfile.worksheetName'));
    let style = this.createCellStyle(workbook);
    let i = 0; //row
    let j = 0; //column
    let data = {};

    try {

      let output = dataOutput.output;
      let columnHeader = dataOutput.columnHeader;
      let outputLength = output.length;

      for (i = 1; i < outputLength + 2; i++) {
        if (i == 1) {
          // Column Header
          for (j = 1; j < columnHeader.length + 1; j++) {
            worksheet
              .cell(i, j)
              .string(translation.getTranslateText(`tenant.symc.empToStaffProfile.columnHeaders.${columnHeader[j - 1]}`))
              .style(style.columnHeaderStyle);
          }
        } else {
          // Body
          data = output[i - 2];
          j = 1;

          for (let columnName of columnHeader) {
            if (typeof data[columnName] === 'string') {
              worksheet
                .cell(i, j++)
                .string(data[columnName])
                .style(style.contentTextStyle);
            } else if (typeof data[columnName] === 'number' && !isNaN(data[columnName])) {
              worksheet
                .cell(i, j++)
                .number(data[columnName])
                .style(style.contentAmountStyle);
            } else if (columnName === 'status') {
              let apiStatus = lodash.get(data, 'apiResponse.result.status', null) || lodash.get(data, 'apiResponse.success', null);
              worksheet
                  .cell(i, j++)
                  .string((apiStatus === 200 || apiStatus === true) ? OUTPUT_FILE_STATUS.complete : OUTPUT_FILE_STATUS.error)
                  .style(style.contentTextStyle);
            } else if (columnName === 'startDate') {
              worksheet
                .cell(i, j++)
                .string(moment().format(globalConstant.dateDisplay))
                .style(style.contentTextStyle);
            } else if (columnName === 'workStartDate' || columnName === 'resignEffectiveDate') {
              worksheet
                .cell(i, j++)
                .string(data[columnName] ? moment(data[columnName]).format(globalConstant.dateDisplay) : '')
                .style(style.contentTextStyle);

            } else if (columnName === 'eventType') {
              worksheet
                .cell(i, j++)
                .string(data.action)
                .style(style.contentTextStyle);
            } else if (columnName === 'message') {
              let apiStatus = lodash.get(data, 'apiResponse.result.status', null) || lodash.get(data, 'apiResponse.result.statusCode', null) || lodash.get(data, 'apiResponse.success', null);
              if (apiStatus === 200 || apiStatus === true) {
                worksheet
                .cell(i, j++)
                .string(OUTPUT_FILE_STATUS.complete)
                .style(style.contentTextStyle);
              } else {
                let errorMessage = lodash.get(data, 'apiResponse.result.errors', '') ||
                lodash.get(data, 'apiResponse.result.exception', '') ||
                lodash.get(data, 'apiResponse.result.messages', '');
                worksheet
                .cell(i, j++)
                .string(JSON.stringify(errorMessage))
                .style(style.contentTextStyle);
              }

            } else {
              worksheet
                .cell(i, j++)
                .string('')
                .style(style.contentTextStyle);
            }
          }
        }
      }

      functionReturn.success = true;
      functionReturn.result = workbook;
    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/usertoldap/excelform - convertToExcel', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  createCellStyle(workbook) {
    return {
      columnHeaderStyle: workbook.createStyle({
        font: {
          bold: true,
        },
        alignment: {
          horizontal: 'center',
          vertical: 'center',
        },
        fill: {
          type: 'pattern',
          patternType: 'solid',
          bgColor: '#DEEBF7',
          fgColor: '#DEEBF7',
        },
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentTextStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentTextCenterStyle: workbook.createStyle({
        alignment: {
          horizontal: 'center',
          vertical: 'center',
        },
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentAmountStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: '#,##0.00',
      }),
      contentDateStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'dd/mm/yyyy',
      }),
      contentDateTimeStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'dd/mm/yyyy HH:mm:ss',
      }),
      contentTimeStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'HH:mm:ss',
      }),
      headerReportTitle: workbook.createStyle({
        font: {
          bold: true,
          size: 14,
        },
      }),
      breakTitle: workbook.createStyle({
        font: {
          bold: true,
          size: 16,
        },
      }),
      footerTitle: workbook.createStyle({
        font: {
          bold: true,
        },
      }),
    };
  }
}
exports.ExcelForm = ExcelForm;

[File Ends] excelform.js

[File Begins] main.js
const helper = require('../../../../utils/helper');
const path = require('path');
const translation = require('../../../../utils/translation');

const Util = require('./util').Util;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const BGProcess = require('../../../../utils/bgprocess').BGProcess;

const program = 'TNT_SYMC03';

exports.main = async (req, res, next) => {
  if (!req.body.bgProcess.isProcess) {
    await execute(req.body, new BGProcess(program), res, next);
  } else {
    let controller = path.resolve(__dirname) + '/main';
    let functionReturn = await new BGProcess(program).start(controller, req.body);
    res.json(functionReturn);
  }
};

exports.jobSchedule = async (req) => {
  let controller = path.resolve(__dirname) + '/main';
  let functionReturn = await new BGProcess(program).start(controller, req.body);
  return functionReturn;
};

process.on('message', async (bgProcess) => {
  bgProcess = Object.assign(new BGProcess(), bgProcess);
  bgProcess.startAt = new Date(bgProcess.startAt);
  bgProcess.functionReturn = new FunctionReturn();
  await execute(bgProcess.selection, bgProcess);
});

const execute = async (selection, bgProcess, res = null, next = null) => {
  let functionReturn = new FunctionReturn();
  let util = new Util();

  try {
    let param = {
      selection: selection,
      bgProcess: bgProcess,
      res: res
    };
    functionReturn = await util.execute(param);

    if (functionReturn.success) {
      //Send file
      let file = functionReturn.result;
      functionReturn.clear();

      let fileName = file.fileName + '.' + file.fileExt;
      await bgProcess.handleOutputFile(file.content, fileName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', res, null);
    } else {
      bgProcess.handleError(functionReturn, res);
    }

  } catch (error) {
    helper.logMessage('error', error.stack, 'symc/usertoldap/main - execute', '', '', '', '');
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
  }
};

exports.initPage = async (req, res, next) => {
  let functionReturn = new FunctionReturn();

  try {
    let util = new Util();
    functionReturn = await util.initPage();
  } catch (error) {
    helper.logMessage('error', error.stack, 'symc/usertoldap/main - initPage', '', '', '', '');
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
  }
  res.json(functionReturn);
};

[File Ends] main.js

[File Begins] service.js
const axios = require('axios');
const lodash = require('lodash');
const { spawn } = require('child_process');

const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const services = require("../../../../utils/interface/services");
const globalConstant = require("../../../../config/constant");
const reqContext = require('../../../../utils/requestcontext');

const env = require('../../../../config/environment/environment').getConfig();
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const staffTokenRequestConnCode = "STAFFAPI";
const GET_TOKEN_URL = 'getToken';
const HR_STAFF_PROFILE = 'hrStaffProfile'
const HEADERS = 'application/json';

class StaffAPIService {

    constructor() {}

    async getHRProfileToken() {

        let functionReturn = new FunctionReturn();

        try {

            let serverConn = await services.getServerConnctionByConnCode(staffTokenRequestConnCode);

            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let encryptPath = env[reqContext.getTenantCode()].serverConnSecretKey;
            let email = lodash.get(serverConn, 'result[0].username', '');
            let encryptClientSecret = lodash.get(serverConn, 'result[0].password', '');
            let defaultPath = lodash.get(serverConn, 'result[0].defaultPath', '');
            let host = lodash.get(serverConn, 'result[0].host', '');
            let clientSecret = helper.decrypt(encryptClientSecret, encryptPath);

            try {

                let url = `${host}/${defaultPath}/${GET_TOKEN_URL}/`;

                return new Promise((resolve, reject) => {
                    let curl = spawn('curl', [
                        '--location',
                        url,
                        '--header',
                        `tenant: ${globalConstant.tenantCode.ipop}`,
                        '--header',
                        `Content-Type: ${HEADERS}`,
                        '--data-raw',
                        JSON.stringify({
                            email: email,
                            password: lodash.get(clientSecret, 'result', ''),
                        }),
                        '-k'
                    ]);

                    let stdoutData = '';
                    let stderrData = '';

                    curl.stdout.on('data', (data) => {
                        if (data.toString()) {
                            try {
                                stdoutData += data.toString();
                            } catch (error) {
                                helper.logMessage('error', error.stack, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                            }
                        }
                    });

                    curl.stderr.on('data', (error) => {
                        stderrData = error.toString();
                    });

                    curl.on('close', (code) => {
                        if (code === 0) {
                            try {
                                resolve({ success: true, result: JSON.parse(stdoutData), stderr: null });
                            } catch (error) {
                                resolve({ success: false, result: null, stderr: stdoutData });
                            }
                        } else {
                            helper.logMessage('error', stderrData, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                            resolve({ success: false, result: null, stderr: stderrData });
                        }
                    });

                    curl.on('error', (err) => {
                        reject(err);
                    });
                });

            } catch (error) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('tenant.symc.empToStaffProfile.error.apiTokenRequest')
                return functionReturn;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/serviceapi - apiTokenRequest', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception')
        }
        return functionReturn;
    }

    async createHRStaffProfile(token, params) {

        let functionReturn = new FunctionReturn();

        try {

            if (!token) {
                functionReturn.success = false;
                functionReturn.result = {
                    messages: translation.getTranslateText('tenant.symc.empToStaffProfile.error.errorCreateHRStaffProfile')
                };
                return functionReturn;
            }

            let serverConn = await services.getServerConnctionByConnCode(staffTokenRequestConnCode);

            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let defaultPath = lodash.get(serverConn, 'result[0].defaultPath', '');
            let host = lodash.get(serverConn, 'result[0].host', '');

            let url = `${host}/${defaultPath}/${HR_STAFF_PROFILE}/`;

            return new Promise((resolve, reject) => {
                let curl = spawn('curl', [
                    '--location',
                    url,
                    '--header',
                    `tenant: ${globalConstant.tenantCode.ipop}`,
                    '--header',
                    `Content-Type: ${HEADERS}`,
                    '--header',
                    `Authorization: Bearer ${token}`,
                    '--data-raw',
                    JSON.stringify(params),
                    '-k'
                ]);

                let stdoutData = '';
                let stderrData = '';

                curl.stdout.on('data', (data) => {
                    if (data.toString()) {
                        try {
                            stdoutData += data.toString();
                        } catch (error) {
                            helper.logMessage('error', error.stack, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                        }
                    }
                });

                curl.stderr.on('data', (error) => {
                    stderrData = error.toString();
                });

                curl.on('close', (code) => {
                    if (code === 0) {
                        try {
                            resolve({ success: true, result: JSON.parse(stdoutData), stderr: null });
                        } catch (error) {
                            resolve({ success: false, result: null, stderr: stdoutData });
                        }
                    } else {
                        helper.logMessage('error', stderrData, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                        resolve({ success: false, result: null, stderr: stderrData });
                    }
                });

                curl.on('error', (err) => {
                    reject(err);
                });
            });

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/serviceapi - apiTokenRequest', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception')
        }
        return functionReturn;
    }
}

exports.StaffAPIService = StaffAPIService;

[File Ends] service.js

[File Begins] util.js
const moment = require('moment');
const lodash = require('lodash');
const Sequelize = require('sequelize');

const arrayUtil = require('../../../../utils/array');
const constant = require('../../../../config/constant');
const helper = require('../../../../utils/helper');
const sh = require('../../../../utils/searchhelp');
const reqContext = require('../../../../utils/requestcontext');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');

const DbProcess = require('./dbprocess').DbProcess;
const ExcelForm = require('./excelform').ExcelForm;
const StaffAPIService = require('./service').StaffAPIService;
const Permission = require('../../../../utils/authorization/permission/permission').Permission;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const db = require('../../../../config/sequelize/sequelize').getConfig();

const Op = Sequelize.Op;

const email = "EMAIL";
const mobile = "MOB";
const endDateTarget = '9999-12-31';
const FIX_EMPLOYMENT_CODE = '2';
const FIX_ACTING = '0';
const FIX_DIV_LEVEL = 300;
const FIX_UNIT_LEVEL = 400;
const FIX_DEPT_LEVEL = 500;
const FIX_SECTION_UNIT_LEVEL = 600;
const FIX_FUNC_LEVEL = 700;
const targetRelationTypeID = 1;
const PERMANENT_EMP_TYPE = 'P';
const CREATE = "CREATE";
const UPDATE = "UPDATE";
const STAFF_API_CON_CODE = 'STAFFAPI';

const HR_SYNC_STAFF_PROFILE = "HrSyncStaffProfile";
const SOURCE_SYSTEM_ID = "IPOP";
const INSTANCE_ID_PARAM_NAME = "SYMC_API_StaffProfile";
const PARAM_GROUP = "EP";
const AUTHORIZATION = "ipop@symphony.net.th";
const LDAP_COMMON_NAME = "CN=";
const DATE_FORMAT = "YYYYMMDDHHmmssSSSS";
const DATE_SPEC_REG_EVENT = "REG";

const eventTypeList = [
  {
    description: "Create",
    code: CREATE
  },
  {
    description: "Update",
    code: UPDATE
  }
];

const LDAP_FIELDS = [
  "cn",
  "title",
  "company",
  "department",
  "givenName",
  "sn",
  "displayName",
  "employeeID",
  "employeeNumber",
  "mail",
  "mobile",
  "telephoneNumber",
  "sAMAccountName",
  "userPrincipalName",
  "userAccountControl",
  "accountExpires"
];

const OUTPUT_FILE_FIELDS = [
  "authorization",
  "action",
  "empCode",
  "empType",
  "gender",
  "titleId",
  "positionId",
  "firstName",
  "lastName",
  "firstNameEng",
  "lastNameEng",
  "nickName",
  "workStartDate",
  "resignEffectiveDate",
  "activeFlag",
  "mobilePhone",
  "acting",
  "divUnitLevel",
  "divCode",
  "divName",
  "unitCode",
  "unitName",
  "deptUnitLevel",
  "deptCode",
  "deptName",
  "sectionUnitLevel",
  "sectionCode",
  "sectionName",
  "funcCode",
  "funcName",
  "orgUnitCode",
  "orgUnitName",
  "positionName",
  "positionNameEng",
  "title",
  "titleEng",
  "modifiedDate",
  "modifiedBy",
  "emailSym",
  "empLevelCode",
  "empLevelName",
  "empLevelNameEng",
  "orgUnitTypeLevel",
  "orgUnitTypeCode",
  "orgUnitTypeName",
  "orgUnitTypeNameEng",
  "empGroupCode",
  "empGroupName",
  "empGroupNameEng",
  "reportToEmpCode",
  "reportToEmpFullName",
  "reportToEmpFullNameEng",
  "shiftCode",
  "shiftName",
  "nId",
  "nParentId",
  "headOfLevel"
];

const OUTPUT_FILE_DATE_FORMAT = 'DD-MM-YYYY';

const staffApiResponse = {
  success: true,
  result: {
    type: "",
    title: "",
    status: 200,
    traceId: "",
    errors: {},
  },
  stderr: null,
}

class Util {

  async initPage() {

    let functionReturn = new FunctionReturn();
    let permission = new Permission();
    let empCodeList = [];

    try {

      let paramSHEmp = {
        condition: {},
        allEmployee: true,
        checkPerAssign: true
      };

      // empCodeList = await sh.getAvailableEmpList(paramSHEmp);
      empCodeList = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

      //Check permission
      let permsParam = {
        replaceEmptyList: false,
        checkObjectList: [
          {
            objectType: globalConstant.permissionObjectType.employee,
            objectList: empCodeList, codeColumn: 'key'
          },
        ]
      };

      let permsReturn = await permission.checkObjectPermission(permsParam);

      if (permsReturn.success) {
        empCodeList = permsReturn.result.checkResult.empList;
      }
      //End check permission

      functionReturn.result = {
        eventTypeCode: [],
        startDate: moment().format(),
        eventType: eventTypeList,
        employeeSH: empCodeList,
        selectEmpType: 'ALL',
        transferStaffProfile: true
      };
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/usertoldap/util - initPage', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async execute(param) {

    let functionReturn = new FunctionReturn();
    let excelForm = new ExcelForm();

    try {

      let selection = param.selection;
      let res = param.res;

      if (selection.startDate) {
        selection.startDate = moment(selection.startDate, globalConstant.dateInputFormat);
      }

      let bgProcess = param.bgProcess;
      let outputData = [];
      let selectedFieldList = [];

      // Get Result Data List
      functionReturn = await this.getResultData(param);
      if (functionReturn.success) {
        outputData = functionReturn.result.outputDataList;
        selectedFieldList = functionReturn.result.selectedFieldList;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      // Get Column Header
      let columnHeader = OUTPUT_FILE_FIELDS;

      // Convert to excel
      let paramExcel = {
        outputData: outputData,
        columnHeader: columnHeader,
        selection: selection,
        bgProcess: bgProcess
      };

      functionReturn = await excelForm.main(paramExcel);

    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util - execute', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  getOutputColumnHeader() {
    let columnHeader = [];

    for (let columnName of OUTPUT_FILE_FIELDS) {
      columnHeader.push(translation.getTranslateText(`tenant.symc.empToStaffProfile.columnHeaders.${columnName}`));
    }

    return columnHeader;
  }

  async adjustSelection(selection) {
    let functionReturn = new FunctionReturn();

    try {
      let permsParam = {
        replaceEmptyList: true,
        checkObjectList: [
          {
            objectType: globalConstant.permissionObjectType.employee,
            objectList: selection.empCodeList
          },
        ],
      };

      let permission = new Permission();
      let permsReturn = await permission.checkObjectPermission(permsParam);

      if (permsReturn.success) {
        selection.empCodeList = permsReturn.result.checkResult.empList;
        functionReturn.success = true;
      } else {
        functionReturn.success = false;
        functionReturn.message = permsReturn.message;
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/usertoldap/util - execute', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getResultData(param) {
    let functionReturn = new FunctionReturn();

    try {
      let selection = param.selection;
      let bgProcess = param.bgProcess;
      let res = param.res;
      let resultData = {};
      let outputDataList = [];

      //Check permission
      functionReturn.clear();
      functionReturn = await this.adjustSelection(selection);
      if (!functionReturn.success) {
        return functionReturn;
      }
      functionReturn.clear();
      //End check permission

      //Prepare data
      functionReturn = await this.prepareData(param);
      if (functionReturn.success) {
        resultData = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      //Process Data
      let params = {
        allData: resultData,
        selection: selection,
        bgProcess: bgProcess,
      };
      functionReturn = await this.processData(params);
      if (functionReturn.success) {
        outputDataList = functionReturn.result.outputList;
        functionReturn.clear();
      } else {
        bgProcess.handleError(functionReturn, res);
        return functionReturn;
      }

      functionReturn.success = true;
      functionReturn.result = {
        outputDataList: outputDataList,
        selectedFieldList: selection
      };
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/agcvinythai/usertoldap/util- getResultData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async prepareData(param) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let result = {};
    let countProgress = 0;
    let totalDatabase = 12;

    try {

      let selection = param.selection;
      let bgProcess = param.bgProcess;

      /*
        Get Employee Data
      */
      functionReturn = await this.getEmployeeData(selection);
      if (functionReturn.success) {
        result.employeeDataList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Build empCode list
      let empList = [];
      for (let emp of result.employeeDataList) {
        empList.push(emp.empCode);
      }
      empList = [...new Set(empList)];

      functionReturn = await this.getPersonalCommunication(empList);
      if (functionReturn.success) {
        result.personalCommunication = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      // let orgList = result.employeeDataList.map(val => val.orgCode);
      functionReturn = await this.getOrganization([]);
      if (functionReturn.success) {
        result.organizationList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn = await this.getPosition([]);
      if (functionReturn.success) {
        result.positionList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn = await this.getTitle(result.employeeDataList);
      if (functionReturn.success) {
        result.titleList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn.result = await dbProcess.getJobLevel();
      if (functionReturn.result.length > 0) {
        result.jobLevelList = functionReturn.result;
        functionReturn.clear();
      } else {
        result.jobLevelList = [];
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn.result = await dbProcess.getEmpSubGroup();
      if (functionReturn.result.length > 0) {
        result.employeeGroupList = functionReturn.result;
        functionReturn.clear();
      } else {
        result.employeeGroupList = [];
      }

      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn.result = await dbProcess.getObjectRelation();
      if (functionReturn.result.length > 0) {
        result.objectRelationList = functionReturn.result;
        functionReturn.clear();
      } else {
        result.objectRelationList = [];
      }

      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      let condition = { empCode: { [Op.in]: empList } };
      functionReturn.result = await dbProcess.getTimeWSR(condition);
      if (functionReturn.result.length > 0) {
        result.timeWSRList = functionReturn.result;
        functionReturn.clear();
      } else {
        result.timeWSRList = [];
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      let tMWsWsrCondition = { wsWsrCode: { [Op.in]: lodash.uniq(result.timeWSRList.map(val => val.wsWsrCode)) } };
      functionReturn.result = await dbProcess.getTMWsWsr(tMWsWsrCondition);
      if (functionReturn.result.length > 0) {
        result.tMWsWsrList = functionReturn.result;
        functionReturn.clear();
      } else {
        result.tMWsWsrList = [];
      }
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

      functionReturn.result = await dbProcess.getSYMCStaffProfileTermination({});
      if (functionReturn.result.length > 0) {
        result.staffProfileTermination = functionReturn.result;
        functionReturn.clear();
      } else {
        result.staffProfileTermination = [];
      }

      let empCodeList = result.employeeDataList.map(val => val.empCode);
      functionReturn = await this.getPersonalDateSpecification(lodash.uniq(empCodeList));
      if (functionReturn.success) {
        result.personalDateSpecList = functionReturn.result;
        functionReturn.clear();
      } else {
        return functionReturn;
      }

      functionReturn.success = true;
      functionReturn.result = result;
      bgProcess.updateStepProgress(constant.bgStepSelectData.id, ++countProgress, totalDatabase);

    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util - prepareData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getEmployeeData(selection) {
    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let condition = {};

    try {

      let startDateSelection = selection.startDate;

      condition = {
        persDataCondition: {
          // startDate: {
          //   [Op.lte]: startDateSelection,
          // },
          // endDate: {
          //   [Op.gte]: startDateSelection,
          // },
        },
        persAssignmentCondition: {
          // startDate: {
          //   [Op.lte]: startDateSelection,
          // },
          // endDate: {
          //   [Op.gte]: startDateSelection,
          // },
        },
      };
      if (!arrayUtil.isEmpty(selection.empCodeList)) {
        condition.persDataCondition.empCode = selection.empCodeList;
        condition.persAssignmentCondition.empCode = selection.empCodeList;
      }

      if (!arrayUtil.isEmpty(selection.companyList)) {
        condition.persAssignmentCondition.comCode = selection.companyList;
      }
      if (!arrayUtil.isEmpty(selection.orgList)) {
        condition.persAssignmentCondition.orgCode = selection.orgList;
      }
      if (!arrayUtil.isEmpty(selection.persAreaList)) {
        condition.persAssignmentCondition.persAreaCode = selection.persAreaList;
      }
      if (!arrayUtil.isEmpty(selection.persSubAreaList)) {
        condition.persAssignmentCondition.persSubAreaCode = selection.persSubAreaList;
      }
      if (!arrayUtil.isEmpty(selection.empGroupList)) {
        condition.persAssignmentCondition.empGroupCode = selection.empGroupList;
      }
      if (!arrayUtil.isEmpty(selection.empSubGroupList)) {
        condition.persAssignmentCondition.empSubGroupCode = selection.empSubGroupList;
      }
      if (!arrayUtil.isEmpty(selection.employmentList)) {
        condition.persAssignmentCondition.employmentCode = selection.employmentList;
      }

      let personalAssignment = await dbProcess.getPersonalAssignment(condition.persAssignmentCondition);
      let personalData = await dbProcess.getPersonalData(condition.persDataCondition);

      let employeeData = [];

      // get max date for each employee
      let empCodeGroup = lodash.groupBy(personalAssignment, (item) => item.empCode);
      let maxDate = lodash.map(empCodeGroup, (group) => {
        return lodash.maxBy(group, (itemGroup) => moment(itemGroup.endDate));
      });

      let personalAssignmentMaxDate = maxDate;

      for (let perAssignItem of personalAssignmentMaxDate) {
        let empCode = perAssignItem.empCode;
        let personalDataItem = lodash.filter(personalData, (val) => val.empCode === empCode);
        let maxDate = lodash.maxBy(personalDataItem, (item) => moment(item.personalDataEndDate));
        if (maxDate) {
          let mergedItem = lodash.merge(perAssignItem, maxDate);
          employeeData.push(mergedItem);
        }
      }

      if (arrayUtil.isEmpty(employeeData)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText("tenant.symc.empToStaffProfile.error.noEmpDataFound");
        return functionReturn;
      }

      functionReturn.success = true;
      functionReturn.result = employeeData;
    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util - getEmployeeData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPersonalCommunication(empCodeList) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();

    let mobileCommunicationType = "MOB";
    let emailCommunicationType = "EMAIL";

    let condition = {
        empCode: { [Op.in]: empCodeList },
      [Op.or]: [
        { commuType: emailCommunicationType },
        { commuType: mobileCommunicationType }
      ]
    };

    try {
      functionReturn.result = await dbProcess.getPersonalCommunication(condition);

      if (functionReturn.result.length > 0) {
        functionReturn.success = true;
      } else {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText("tenant.symc.empToStaffProfile.error.noPersonalCommunicationData");
      }
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception'); //'Error get Payroll Area'
    }

    return functionReturn;
  }

  async getUser(empCodeList) {
    let functionReturn = new FunctionReturn();
    const dbProcess = new DbProcess();
    let condition = { empCode: { [Op.in]: empCodeList } }

    try {
      functionReturn.result = await dbProcess.getUser(condition);

      if (functionReturn.result.length > 0) {
        functionReturn.success = true;
      } else {
        functionReturn.clear();
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText("tenant.symc.empToStaffProfile.error.noUserData");
      }
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception'); //'Error get Payroll Area'
    }

    return functionReturn;
  }

  async getSYMCUserADTermination(empCodeList) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let condition = {
      empCode: { [Op.in]: empCodeList },
      // deleted: { [Op.]: 1 }
      deleted: { [Op.eq]: null },
    };

    try {
      functionReturn.result = await dbProcess.getSYMCUserADTermination(condition);
      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async getCompany(comCodeList) {
    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let condition = { comCode: { [Op.in]: comCodeList } }

    try {
      functionReturn.result = await dbProcess.getCompany(condition);
      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async getOrganization(orgList) {
    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();

    let condition = {};

    if (orgList.length > 0) {
      condition = { orgCode: { [Op.in]: orgList } };
    }

    try {
      functionReturn.result = await dbProcess.getOrganization(condition);
      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPosition(posCodeList) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let condition = {};

    if (posCodeList.length > 0) {
      condition = { posCode: { [Op.in]: posCodeList } };
    }

    try {

      functionReturn.result = await dbProcess.getPosition(condition)

      if (!arrayUtil.isEmpty(functionReturn.result)) {
        functionReturn.success = true
      } else {
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.noPositionFound');
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'pyregister', 'E018', 'user', condition, '')
      functionReturn.success = false
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn
  }

  async getTitle(empDataList) {
    let functionReturn = new FunctionReturn();
    let titleList = [];
    let condition = [];

    try {
      // get title list from employee data
      // for (let empData of empDataList) {
      // 	titleList.push(empData.titleCode);
      // }

      // set condition for title
      // condition = {
      // 	titleCode: titleList,
      // };

      // get title
      // functionReturn.result = await dbProcess.getTitle(condition)
      functionReturn.result = await sh.getTitle({});
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/emptostaffprofile/util - getTitle', '', 'user', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPersonalDateSpecification(empCodeList) {
    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let condition = {
      empCode: { [Op.in]: empCodeList },
      // dayTypeCode: globalConstant.persEventTMN
    };

    try {
      functionReturn.result = await dbProcess.getPersonalDateSpecification(condition);
      functionReturn.success = true;
    } catch (error) {
      helper.logMessage('error', error, 'usertoldap/util ', 'E002', 'user', condition, '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  convertDateToLDAPTimestamp(inputDate) {
    // Parse the input date string using the desired format
    const date = moment(inputDate, 'DD/MM/YYYY').endOf('days').add(1, 'seconds');

    // Get the Unix timestamp in seconds from the parsed date
    const unixTimestamp = date.unix();

    // Convert the Unix timestamp to LDAP timestamp format (100-nanosecond intervals)
    const ldapTimestamp = (unixTimestamp + 11644473600) * 10000000;
    return ldapTimestamp;
  }

  convertLDAPTimestampToDate(ldapTimestamp) {
    // Convert LDAP timestamp to Unix timestamp (seconds)
    const unixTimestamp = ldapTimestamp / 10000000 - 11644473600;

    // Convert Unix timestamp to a Moment.js object
    const date = moment.unix(unixTimestamp);

    // Format the date as 'YYYY-MM-DD'
    const formattedDate = date.format('YYYY-MM-DD');

    return formattedDate;
  }


  async processData(params) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();
    let service = new StaffAPIService();
    let outputList = [];
    let transaction = null;

    try {

      let allData = params.allData;
      let selection = params.selection;
      let { eventTypeCode } = selection;
      let { employeeDataList } = allData;

      let hiringResult = [];
      let updateResult = [];
      let terminationResult = [];
      let actingResult = [];
      let isChangedData = false;

      let targetHireUser = lodash.filter(employeeDataList, (val) => {
        return val.eventTypeCode === globalConstant.persEventHire;
      });

      // 1. Check New Hire Condition
      if (eventTypeCode.indexOf(CREATE) > -1 || eventTypeCode.length === 0) {
        let params = { hiringResult, targetHireUser, selection, ...allData };
        await this.getNewHireCondition(params);
      }

      let targetTermUser = lodash.filter(employeeDataList, (val) => {
        return val.eventTypeCode
      });

      // 2. Check Update Data & Termination Condition
      if (eventTypeCode.indexOf(UPDATE) > -1 || eventTypeCode.length === 0) {
        let params = { updateResult, targetTermUser, selection, ...allData };
        isChangedData = await this.getChangeDataCondition(params);
      }

      let targetEmpDataList = employeeDataList;

      // 3. Check Termination Condition
      if (eventTypeCode.indexOf(UPDATE) > -1 || eventTypeCode.length === 0) {
        let params = { terminationResult, targetEmpDataList, targetTermUser, selection, ...allData };
        await this.getTerminationCondition(params);
      }

      // 4. Check Acting Condition
      if (eventTypeCode.indexOf(UPDATE) > -1 || eventTypeCode.length === 0) {
        let params = { actingResult, targetEmpDataList, selection, ...allData };
        await this.getActingCondition(params);
      }

      // AD API config
      let connection = await dbProcess.getServerConnection({ connCode: STAFF_API_CON_CODE });
      if (!connection) {
        functionReturn.message = translation.getTranslateText("tenant.symc.empToStaffProfile.error.ldapConnectionNotFound");
        return functionReturn;
      }

      let instanceID = await dbProcess.getParameter({ paramName: INSTANCE_ID_PARAM_NAME, paramGroup: PARAM_GROUP });
      let resultToken = "";
      let tokenResult = null;

      if (selection.transferStaffProfile) {
        resultToken = await service.getHRProfileToken();
        tokenResult = lodash.get(resultToken, 'result.token', null);
      }

      // Hiring
      for (const hiringItem of hiringResult) {
        let refreshTokenExpiryTime = lodash.get(tokenResult, 'refreshTokenExpiryTime', '');
        if (moment().isAfter(moment(refreshTokenExpiryTime))) {
          resultToken = await service.getHRProfileToken();
          tokenResult = lodash.get(resultToken, 'result.token', null);
        }

        let staffProfileItem = {
          // Message header
          messageID: `${moment().format(DATE_FORMAT)}${instanceID.lowValue}`,
          businessEvent: HR_SYNC_STAFF_PROFILE,
          sourceSystemID: SOURCE_SYSTEM_ID,
          sentDttm: moment().utc(7).toJSON(),

          // Message body
          ...hiringItem
        };
        let response = staffApiResponse;
        if (selection.transferStaffProfile) {
          if (!tokenResult) {
            response = {
              result: {
                messages: lodash.get(resultToken, 'result.message', '') || translation.getTranslateText('tenant.symc.empToStaffProfile.error.errorCreateHRStaffProfile')
              },
              success: false
            };
            outputList.push({ ...staffProfileItem, apiResponse: response, action: CREATE })
            continue;
          } else {
            response = await service.createHRStaffProfile(tokenResult, staffProfileItem);
          }
        }
        outputList.push({ ...staffProfileItem, apiResponse: response, action: CREATE });
      }

      // Update
      // *** กรณีพนักงานมีเปลี่ยนแปลงข้อมูล ให้เอา empCode ที่ได้จากพนักงานเข้าใหม่ (Create) ออกจากการการแก้ไขข้อมูล (Update)
      let finalUpdateResult = updateResult.filter(item => !lodash.some(hiringResult, { employeeID: item.employeeID }));
      for (const updateItem of finalUpdateResult) {
        let refreshTokenExpiryTime = lodash.get(tokenResult, 'refreshTokenExpiryTime', '');

        if (moment().isAfter(moment(refreshTokenExpiryTime))) {
          resultToken = await service.getHRProfileToken();
          tokenResult = lodash.get(resultToken, 'result.token', null);
        }

        let staffProfileItem = {
          // Message header
          messageID: `${moment().format(DATE_FORMAT)}${instanceID.lowValue}`,
          businessEvent: HR_SYNC_STAFF_PROFILE,
          sourceSystemID: SOURCE_SYSTEM_ID,
          sentDttm: moment().utc(7).toJSON(),

          // Message body
          ...updateItem
        };

        let isDuplicate = lodash.find(outputList, (val) => {
          return (val.empCode === updateItem.empCode && val.action === updateItem.action && val.acting === updateItem.acting);
        });

        if (isDuplicate) continue;

        let response = staffApiResponse;
        if (selection.transferStaffProfile) {
          response = await service.createHRStaffProfile(tokenResult, staffProfileItem);
        }

        let resultStatus = lodash.get(response, 'result.status', null);
        if (response.success && resultStatus === 200 && selection.transferStaffProfile) {

          let targetTermUserItem = targetTermUser.find(val => val.empCode === updateItem.empCode);
          let newSYMCStaffProfileTermination = {
            empCode: updateItem.empCode,
            username: `${updateItem.firstNameEng} ${updateItem.lastNameEng}`,
            terminateDate: moment(targetTermUserItem.startDate).format(globalConstant.dbDateFormat),
            interfaceAt: moment().format(globalConstant.dbDateTimeFormat),
            interfaceBy: reqContext.getLoginUsername(),
            action: UPDATE,
            activeFlag: updateItem.activeFlag,
            eventTypeCode: targetTermUserItem.eventTypeCode,
            changedAt: moment().format(globalConstant.dbDateFormat),
            changedBy: reqContext.getLoginUsername()
          };

          transaction = await db[reqContext.getTenantCode()].conn.transaction();
          await dbProcess.createSYMCStaffProfileTermination(newSYMCStaffProfileTermination, transaction);
          await transaction.commit();
        }

        outputList.push({ ...staffProfileItem, apiResponse: response, action: UPDATE });
      }

      // Terminate
      // Update
      // *** กรณีพนักงานมีเปลี่ยนแปลงข้อมูล ให้เอา empCode ที่ได้จากพนักงานเข้าใหม่ (Create) ออกจากการการแก้ไขข้อมูล (Terminate)
      let finalTerminationResult = terminationResult.filter(item => !lodash.some(hiringResult, { empCode: item.empCode }));
      for (const terminateItem of finalTerminationResult) {
        let refreshTokenExpiryTime = lodash.get(tokenResult, 'refreshTokenExpiryTime', '');

        if (moment().isAfter(moment(refreshTokenExpiryTime))) {
          resultToken = await service.getHRProfileToken();
          tokenResult = lodash.get(resultToken, 'result.token', null);
        }

        let isDuplicate = lodash.find(outputList, (val) => {
          return (val.empCode === terminateItem.empCode && val.action === terminateItem.action && val.acting === terminateItem.acting);
        });

        if (isDuplicate) continue;

        let staffProfileItem = {
          // Message header
          messageID: `${moment().format(DATE_FORMAT)}${instanceID.lowValue}`,
          businessEvent: HR_SYNC_STAFF_PROFILE,
          sourceSystemID: SOURCE_SYSTEM_ID,
          sentDttm: moment().utc(7).toJSON(),

          // Message body
          ...terminateItem
        };

        let response = staffApiResponse;
        if (selection.transferStaffProfile) {
          response = await service.createHRStaffProfile(tokenResult, staffProfileItem);
        }

        let resultStatus = lodash.get(response, 'result.status', false);
        if (response.success && resultStatus === 200 && selection.transferStaffProfile) {
          transaction = await db[reqContext.getTenantCode()].conn.transaction();
          let removeCondition = { empCode: terminateItem.empCode };
          await dbProcess.deleteSYMCStaffProfileTermination(transaction, removeCondition);
          transaction.commit();
        }

        outputList.push({ ...staffProfileItem, apiResponse: response, action: UPDATE });
      }

      // Acting
      for (const actingItem of actingResult) {
        let refreshTokenExpiryTime = lodash.get(tokenResult, 'refreshTokenExpiryTime', '');

        if (moment().isAfter(moment(refreshTokenExpiryTime))) {
          resultToken = await service.getHRProfileToken();
          tokenResult = lodash.get(resultToken, 'result.token', null);
        }

        let staffProfileItem = {
          // Message header
          messageID: `${moment().format(DATE_FORMAT)}${instanceID.lowValue}`,
          businessEvent: HR_SYNC_STAFF_PROFILE,
          sourceSystemID: SOURCE_SYSTEM_ID,
          sentDttm: moment().utc(7).toJSON(),

          // Message body
          ...actingItem
        };

        // let isDuplicate = lodash.find(outputList, (val) => {
        //   return (val.empCode === actingItem.empCode && val.action === actingItem.action && val.acting === actingItem.acting);
        // });

        // if (isDuplicate) continue;

        let response = staffApiResponse;
        if (selection.transferStaffProfile) {
          response = await service.createHRStaffProfile(tokenResult, staffProfileItem);
        }
        outputList.push({ ...staffProfileItem, apiResponse: response, action: UPDATE });
      }

      if (outputList.length > 0) {
        functionReturn.success = true;
        functionReturn.result.outputList = outputList;
      } else {
        if (isChangedData) {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('tenant.symc.empToStaffProfile.error.errorEmpDataNotFound');
        } else {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('tenant.symc.empToStaffProfile.error.errorDataNotFound');
        }
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util - processData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
      await transaction.rollback();
    } finally {
      if (transaction) {
        if (!transaction.finished) {
          await transaction.rollback();
        }
      }
    }

    return functionReturn;
  }


  async enableToLDAP(enableResultItem, ldapCN, ldapDC, ldapConnectionHost, connection, clientSecret, service, outputList) {
    let enableParam = {
      payload: enableResultItem,
      connection: {
        dn: `${LDAP_COMMON_NAME}${enableResultItem.cn},${ldapCN.lowValue},${ldapDC.lowValue}`,
        host: ldapConnectionHost,
        username: connection.username,
        password: lodash.get(clientSecret, 'result', ''),
        cnValue: ldapCN.lowValue,
        dnValue: ldapDC.lowValue,
        commonName: `${LDAP_COMMON_NAME}${enableResultItem.cn}`,
      }
    };
    let ldapEnableResult = await service.createOrUpdate(enableParam, LDAP_FIELDS);
    outputList.push({ ...ldapEnableResult, startDate: moment().format(OUTPUT_FILE_DATE_FORMAT), eventType: eventTypeList[3].description });
    return ldapEnableResult;
  }

  async terminateToLDAP(terminateItem, ldapCN, ldapDC, ldapConnectionHost, connection, clientSecret, service, outputList) {
    let terminateParam = {
      payload: terminateItem,
      connection: {
        dn: `${LDAP_COMMON_NAME}${terminateItem.cn},${ldapCN.lowValue},${ldapDC.lowValue}`,
        host: ldapConnectionHost,
        username: connection.username,
        password: lodash.get(clientSecret, 'result', ''),
        cnValue: ldapCN.lowValue,
        dnValue: ldapDC.lowValue,
        commonName: `${LDAP_COMMON_NAME}${terminateItem.cn}`,
      }
    };

    let ldapTerminateResult = await service.createOrUpdate(terminateParam, LDAP_FIELDS);
    outputList.push({ ...ldapTerminateResult, startDate: moment().format(OUTPUT_FILE_DATE_FORMAT), eventType: eventTypeList[2].description });
    return ldapTerminateResult;
  }

  async updateToLDAP(updateItem, ldapCN, ldapDC, ldapConnectionHost, connection, clientSecret, service, outputList) {
    let updateParam = {
      payload: updateItem,
      connection: {
        dn: `${LDAP_COMMON_NAME}${updateItem.cn},${ldapCN.lowValue},${ldapDC.lowValue}`,
        host: ldapConnectionHost,
        username: connection.username,
        password: lodash.get(clientSecret, 'result', ''),
        cnValue: ldapCN.lowValue,
        dnValue: ldapDC.lowValue,
        commonName: `${LDAP_COMMON_NAME}${updateItem.cn}`,
      }
    };

    let ldapUpdateResult = await service.createOrUpdate(updateParam, LDAP_FIELDS);
    outputList.push({ ...ldapUpdateResult, startDate: moment().format(OUTPUT_FILE_DATE_FORMAT), eventType: eventTypeList[1].description });
  }

  async hiringToLDAP(hiringResult, ldapCN, ldapDC, ldapConnectionHost, connection, clientSecret, service, outputList) {
    for (let hiringItem of hiringResult) {
      let addParam = {
        payload: hiringItem,
        connection: {
          dn: `${LDAP_COMMON_NAME}${hiringItem.cn},${ldapCN.lowValue},${ldapDC.lowValue}`,
          host: ldapConnectionHost,
          username: connection.username,
          password: lodash.get(clientSecret, 'result', ''),
          cnValue: ldapCN.lowValue,
          dnValue: ldapDC.lowValue,
          commonName: `${LDAP_COMMON_NAME}${hiringItem.cn}`,
        }
      };
      let ldapCreateResult = await service.createOrUpdate(addParam, LDAP_FIELDS);
      outputList.push({ ...ldapCreateResult, startDate: moment().format(OUTPUT_FILE_DATE_FORMAT), eventType: eventTypeList[0].description });
    }
  }

  async getActingCondition(params) {
    let { actingResult, targetEmpDataList, objectRelationList, selection } = params;

    // เงื่อนไข 1 : รองรับกรณี HR คีย์ Acting ล่วงหน้า (แต่ข้อมูลจะถูกส่งไป ณ วันที่เริ่มรักษาการ, ไม่ใช่วันที่ HR คีย์ Acting)
    for (let userItem of targetEmpDataList) {

      let actingDataList = lodash.filter(objectRelationList, (val) => {
        return moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) &&
          val.objectCode === userItem.empCode &&
          val.relationTypeID === targetRelationTypeID
      });

      if (actingDataList.length === 0) continue;

      let param = {
        userItem,
        action: UPDATE,
        acting: FIX_ACTING,
        ...params
      };

      let item = await this.getUserData(param);
      if (item.success) actingResult.push(item.result);

      if (actingDataList.length > 0) {
        param = await this.getActingResult(actingDataList, params, actingResult, userItem, param);
      }
    }

    // เงื่อนไข 2 : รองรับกรณี HR คีย์ Acting ย้อนหลัง
    for (let userItem of targetEmpDataList) {

      let actingDataList = lodash.filter(objectRelationList, (val) => {
        return moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isBefore(selection.startDate) &&
          moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(endDateTarget) &&
          moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate) &&
          val.objectCode === userItem.empCode &&
          val.relationTypeID === targetRelationTypeID;
      });

      if (actingDataList.length === 0) continue;

      let param = {
        userItem,
        action: UPDATE,
        acting: FIX_ACTING,
        ...params
      };

      let item = await this.getUserData(param);
      if (item.success) actingResult.push(item.result);

      if (actingDataList.length > 0) {
        param = await this.getActingResult(actingDataList, params, actingResult, userItem, param);
      }

    }

    // เงื่อนไข 1 : รองรับกรณี HR คีย์ ยกเลิก Acting ล่วงหน้า (แต่ข้อมูลจะถูกส่งไป ณ วันสิ้นสุดการรักษาการ, ไม่ใช่วันที่ HR คีย์ยกเลิก Acting)
    for (let userItem of targetEmpDataList) {

      let actingDataList = lodash.filter(objectRelationList, (val) => {
        return moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) &&
          val.objectCode === userItem.empCode &&
          val.relationTypeID === targetRelationTypeID
      });

      if (actingDataList.length === 0) continue;

      let param = {
        userItem,
        action: UPDATE,
        acting: FIX_ACTING,
        ...params
      };

      let item = await this.getUserData(param);
      if (item.success) actingResult.push(item.result);

      if (actingDataList.length > 0) {
        param = await this.getActingResult(actingDataList, params, actingResult, userItem, param);
      }
    }

    // เงื่อนไข 2 : รองรับกรณี HR คีย์ยกเลิก Acting ย้อนหลัง
    for (let userItem of targetEmpDataList) {

      let actingDataList = lodash.filter(objectRelationList, (val) => {
        return moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isBefore(selection.startDate) &&
          moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate) &&
          val.objectCode === userItem.empCode &&
          val.relationTypeID === targetRelationTypeID
      });

      if (actingDataList.length === 0) continue;

      let param = {
        userItem,
        action: UPDATE,
        acting: FIX_ACTING,
        ...params
      };

      let item = await this.getUserData(param);
      if (item.success) actingResult.push(item.result);

      if (actingDataList.length > 0) {
        param = await this.getActingResult(actingDataList, params, actingResult, userItem, param);
      }
    }
  }

  async getActingResult(actingDataList, params, actingResult, userItem, param) {
    try {

      for (let actingItem of actingDataList) {
        if (actingItem.relatedObjectType !== globalConstant.objectType.position) continue;
        let posTarget = lodash.find(params.positionList, (val) => val.posCode === actingItem.relatedObjectCode);
        if (!posTarget) continue;

        let actingTarget = lodash.findLast(actingResult, val => val.empCode === userItem.empCode);
        let acting = 0;
        if (actingTarget) {
          acting = Number(actingTarget.acting) + 1;
        }

        let activeFlag = moment(moment(actingItem.endDate).format(globalConstant.dbDateFormat))
          .isSameOrBefore(moment().format(globalConstant.dbDateFormat)) ? '0' : '1';

        param = {
          userItem,
          action: UPDATE,
          acting: `${acting}`,
          activeFlag: activeFlag,
          ...params,
        };

        param.userItem.orgCode = posTarget.parentOrgCode;
        param.userItem.posCode = posTarget.posCode;

        let item = await this.getUserData(param);
        if (item.success) actingResult.push(item.result);
      }
    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util/main - getActingResult', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return param;
  }

  async getTerminationCondition(params) {
    let { targetEmpDataList, selection, terminationResult, personalDateSpecList, staffProfileTermination } = params;

    for (let userItem of targetEmpDataList) {
      let startDate = moment(userItem.startDate).format(globalConstant.dbDateFormat);
      let changedAt = moment(userItem.changedAt).format(globalConstant.dbDateFormat);
      let selectionStartDate = moment(selection.startDate).format(globalConstant.dbDateFormat);
      let terminateUserItem = lodash.find(personalDateSpecList, (val) => val.empCode === userItem.empCode && val.dayTypeCode === globalConstant.persEventTMN);

      if (moment(startDate).isSame(selectionStartDate) || moment(changedAt).isSame(selectionStartDate)) {
        let staffProfileItem = lodash.filter(staffProfileTermination, (val) => val.empCode === userItem.empCode);
        if (staffProfileItem.length > 0) {
          if (!terminateUserItem) {
            let param = {
              userItem,
              action: UPDATE,
              acting: '0',
              ...params
            };
            let item = await this.getUserData(param);

            if (item.success) terminationResult.push(item.result);
          }
        } else {
          let param = {
            userItem,
            action: UPDATE,
            acting: '0',
            ...params
          };

          let item = await this.getUserData(param);
          if (item.success) terminationResult.push(item.result);
        }
      }
    }
  }

  async getChangeDataCondition(params) {
    let { targetTermUser, selection, updateResult, isChangedData } = params;

    let employeeDataListBeforeTemp = lodash.filter(params.employeeDataList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate))
    let personalCommunicationBeforeTemp = lodash.filter(params.personalCommunication, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate))
    let objectRelationListBeforeTemp = lodash.filter(params.objectRelationList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate))
    let personalDateSpecListBeforeTemp = lodash.filter(params.personalDateSpecList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate))
    let timeWSRListBeforeTemp = lodash.filter(params.timeWSRList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate))

    // ปรับเงื่อนไข ล่วงหน้า และ ย้อนหลังเป็นเชต endDate และ updatedAt
    let personalCommunicationAfterTemp = lodash.filter(params.personalCommunication, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSameOrBefore(selection.startDate) && moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSameOrAfter(selection.startDate) && moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate));
    let objectRelationListAfterTemp = lodash.filter(params.objectRelationList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSameOrBefore(selection.startDate) && moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSameOrAfter(selection.startDate) && moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate));
    let personalDateSpecListAfterTemp = lodash.filter(params.personalDateSpecList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSameOrBefore(selection.startDate) && moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSameOrAfter(selection.startDate) && moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate));
    let timeWSRListAfterTemp = lodash.filter(params.timeWSRList, (val) => moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSameOrBefore(selection.startDate) && moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSameOrAfter(selection.startDate) && moment(moment(val.changedAt).format(globalConstant.dbDateFormat)).isSame(selection.startDate));

    for (let userItem of targetTermUser) {

      let selectionStartDate = moment(selection.startDate).format(globalConstant.dbDateFormat);
      let startDate = moment(userItem.startDate).format(globalConstant.dbDateFormat);
      let endDate = moment(userItem.endDate).format(globalConstant.dbDateFormat);
      let changedAt = moment(userItem.changedAt).format(globalConstant.dbDateFormat);

      let personalCommunication = lodash.find(personalCommunicationAfterTemp, val => val.empCode === userItem.empCode);
      let objectRelationList = lodash.find(objectRelationListAfterTemp, val => val.empCode === userItem.empCode);
      let personalDateSpecList = lodash.find(personalDateSpecListAfterTemp, val => val.empCode === userItem.empCode);
      let timeWSRList = lodash.find(timeWSRListAfterTemp, val => val.empCode === userItem.empCode);

      if (
        (
          moment(endDate).isSame(endDateTarget) &&
          moment(changedAt).isSame(selectionStartDate)
        ) ||
        (
          (lodash.get(userItem, 'personalDataEndDate', '') && moment(moment(lodash.get(userItem, 'personalDataEndDate', '')).format(globalConstant.dbDateFormat)).isSame(endDateTarget)) &&
          (lodash.get(userItem, 'personalDataChangedAt', '') && moment(moment(lodash.get(userItem, 'personalDataChangedAt', '')).format(globalConstant.dbDateFormat)).isSame(selectionStartDate))
        ) ||
        (
          (lodash.get(personalCommunication, 'endDate', '') && moment(moment(lodash.get(personalCommunication, 'endDate', '')).format(globalConstant.dbDateFormat)).isSame(endDateTarget)) &&
          (lodash.get(personalCommunication, 'changedAt', '') && moment(moment(lodash.get(personalCommunication, 'changedAt', '')).format(globalConstant.dbDateFormat)).isSame(selectionStartDate))
        ) ||
        (
          (lodash.get(objectRelationList, 'endDate', '') && moment(moment(lodash.get(objectRelationList, 'endDate', '')).format(globalConstant.dbDateFormat)).isSame(endDateTarget)) &&
          (lodash.get(objectRelationList, 'changedAt', '') && moment(moment(lodash.get(objectRelationList, 'changedAt', '')).format(globalConstant.dbDateFormat)).isSame(selectionStartDate))
        ) ||
        (
          (lodash.get(personalDateSpecList, 'endDate', '') && moment(moment(lodash.get(personalDateSpecList, 'endDate', '')).format(globalConstant.dbDateFormat)).isSame(endDateTarget)) &&
          (lodash.get(personalDateSpecList, 'changedAt', '') && moment(moment(lodash.get(personalDateSpecList, 'changedAt', '')).format(globalConstant.dbDateFormat)).isSame(selectionStartDate))

        ) ||
        (
          (lodash.get(timeWSRList, 'endDate', '') && moment(moment(lodash.get(timeWSRList, 'endDate', '')).format(globalConstant.dbDateFormat)).isSame(endDateTarget)) &&
          (lodash.get(timeWSRList, 'changedAt', '') && moment(moment(lodash.get(timeWSRList, 'changedAt', '')).format(globalConstant.dbDateFormat)).isSame(selectionStartDate))
        ) &&
        userItem.eventTypeCode !== globalConstant.persEventTerminate) {

        let newPersonalCommunication = params.personalCommunication.filter(val => val.empCode !== userItem.empCode);
        let emailResult = lodash.maxBy(lodash.filter(params.personalCommunication, (val) => val.empCode === userItem.empCode && val.commuType === email), 'endDate');
        let mobileResult = lodash.maxBy(lodash.filter(params.personalCommunication, (val) => val.empCode === userItem.empCode && val.commuType === mobile), 'endDate');
        newPersonalCommunication.push(mobileResult, emailResult);

        // if (mobileResult) {
        //   newPersonalCommunication.push(mobileResult);
        // }

        // if (emailResult) {
        //   newPersonalCommunication.push(emailResult);
        // }

        isChangedData = true;

        let param = {
          userItem,
          action: UPDATE,
          acting: FIX_ACTING,
          ...params,
          personalCommunication: newPersonalCommunication
        };

        let item = await this.getUserData(param);
        if (item.success) updateResult.push(item.result);

        let actingDataList = lodash.filter(objectRelationListAfterTemp, (val) => val.objectCode === userItem.empCode)
        if (actingDataList.length > 0) {
          let countActing = 0;
          for (let actingItem of actingDataList) {
            if (actingItem.relatedObjectType !== globalConstant.objectType.position) continue;
            let posTarget = lodash.find(params.positionList, (val) => val.posCode === actingItem.relatedObjectCode);
            if (!posTarget) continue;

            param = {
              userItem,
              action: UPDATE,
              acting: `${countActing++}`,
              ...params,
            };
            param.userItem.orgCode = posTarget.parentOrgCode;

            let item = await this.getUserData(param);
            if (item.success) updateResult.push(item.result);
          }
        }
      }
    }

    return isChangedData;
  }

  async getNewHireCondition(params) {
    let { targetHireUser, selection, hiringResult } = params;

    selection.startDate = moment(selection.startDate).format(globalConstant.dbDateFormat);

    let employeeDataListTemp = lodash.filter(params.employeeDataList, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))
    let organizationListTemp = lodash.filter(params.organizationList, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))
    let objectRelationListTemp = lodash.filter(params.objectRelationList, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))
    let personalCommunicationTemp = lodash.filter(params.personalCommunication, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))
    let personalDateSpecListTemp = lodash.filter(params.personalDateSpecList, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))
    let timeWSRListTemp = lodash.filter(params.timeWSRList, (val) => (moment(val.startDate).isBefore(selection.startDate) && moment(val.endDate).isAfter(selection.startDate)) || (moment(moment(val.startDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate) || moment(moment(val.endDate).format(globalConstant.dbDateFormat)).isSame(selection.startDate)))

    // เงื่อนไข 1 : รองรับกรณี HR คีย์ Hiring ล่วงหน้า (แต่ข้อมูลจะถูกส่งไป ณ วันเริ่มงานของพนักงาน, ไม่ใช่วันที่ HR คีย์ Hiring)
    for (let userItem of targetHireUser) {
      let startDate = moment(userItem.startDate).format(globalConstant.dbDateFormat);
      let selectionStartDate = moment(selection.startDate).format(globalConstant.dbDateFormat);
      if (moment(startDate).isSame(selectionStartDate)) {
        let param = {
          userItem,
          action: CREATE,
          acting: FIX_ACTING,
          ...params,
          employeeDataList: employeeDataListTemp,
          organizationList: organizationListTemp,
          objectRelationList: objectRelationListTemp,
          personalCommunication: personalCommunicationTemp,
          personalDateSpecList: personalDateSpecListTemp,
          timeWSRList: timeWSRListTemp,
        };
        let item = await this.getUserData(param);
        if (item.success) hiringResult.push(item.result);
      }
    }

    // เงื่อนไข 2 : รองรับกรณี HR คีย์ Hiring ย้อนหลัง
    for (let userItem of targetHireUser) {
      let startDate = moment(userItem.startDate).format(globalConstant.dbDateFormat);
      let changedAt = moment(userItem.changedAt).format(globalConstant.dbDateFormat);
      let selectionStartDate = moment(selection.startDate).format(globalConstant.dbDateFormat);
      if (moment(startDate).isSameOrBefore(selectionStartDate) && moment(changedAt).isSame(selectionStartDate)) {
        let param = {
          userItem,
          action: CREATE,
          acting: FIX_ACTING,
          ...params,
          employeeDataList: employeeDataListTemp,
          organizationList: organizationListTemp,
          objectRelationList: objectRelationListTemp,
          personalCommunication: personalCommunicationTemp,
          personalDateSpecList: personalDateSpecListTemp,
          timeWSRList: timeWSRListTemp,
        };
        let item = await this.getUserData(param);
        if (item.success) hiringResult.push(item.result);
      }
    }
  }

  formatPhoneNumber(mobileNumber = "") {

    if (!mobileNumber) return mobileNumber;

    // Use regular expression to match the parts of the phone mobileNumber
    let regex = /^(\d{3})(\d{3})(\d{4})$/;
    // Use replace method to insert dashes between matched parts
    let formattedNumber = mobileNumber.replace(regex, '$1-$2-$3');
    return formattedNumber;
  }

  async getUserData(param) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DbProcess();

    try {

      let {
        action,
        activeFlag,
        acting,
        timeWSRList,
        tMWsWsrList,
        jobLevelList,
        userItem,
        titleList,
        positionList,
        organizationList,
        employeeGroupList,
        objectRelationList,
        personalDateSpecList,
        personalCommunication,
      } = param;

      let currentOrgCode = lodash.get(userItem, 'orgCode', '');
      let currentEmpCode = lodash.get(userItem, 'empCode', null)
      let emailItem = lodash.find(personalCommunication, (val) => val.empCode === userItem.empCode && val.commuType === email);
      let mobileItem = lodash.find(personalCommunication, (val) => val.empCode === userItem.empCode && val.commuType === mobile);
      let organizationItem = lodash.find(organizationList, (val) => val.orgCode === currentOrgCode);
      let titleItem = lodash.find(titleList, (val) => val.titleCode === userItem.titleCode);
      let positionItem = lodash.find(positionList, (val) => val.posCode === userItem.posCode);
      let timeWSRItem = lodash.find(timeWSRList, (val) => val.empCode === userItem.empCode);
      let jobLevelThItem = lodash.find(jobLevelList, (val) => val.jobLevelCode === userItem.jobLevel && val.langKeyCode === 'TH');
      let jobLevelEnItem = lodash.find(jobLevelList, (val) => val.jobLevelCode === userItem.jobLevel && val.langKeyCode === 'EN');
      let employeeGroupThItem = lodash.find(employeeGroupList, (val) => val.empSubGroupCode === userItem.empSubGroupCode && val.langKeyCode === 'TH');
      let employeeGroupEnItem = lodash.find(employeeGroupList, (val) => val.empSubGroupCode === userItem.empSubGroupCode && val.langKeyCode === 'EN');
      let objectRelationItem = lodash.find(objectRelationList, (val) => val.objectCode === userItem.empCode);
      let personalDateSpecItem = lodash.find(personalDateSpecList, (val) => val.empCode === userItem.empCode);

      let dateSpecHireResult = await dbProcess.getPersonalDateSpecification({
        empCode: { [Op.in]: [userItem.empCode] },
        dayTypeCode: DATE_SPEC_REG_EVENT
      });

      let hiringTargetItem = lodash.find(param.employeeDataList, (val) => val.empCode === userItem.empCode && val.eventTypeCode === globalConstant.persEventHire);

      let modifiedData = [
        { date: userItem.changedAt, data: userItem },
        { date: userItem.personalDataChangedAt, data: userItem },
      ];

      if (objectRelationItem) {
        modifiedData.push({ date: objectRelationItem.changedAt, data: objectRelationItem });
      }
      if (personalDateSpecItem) {
        modifiedData.push({ date: personalDateSpecItem.changedAt, data: personalDateSpecItem });
      }
      if (timeWSRItem) {
        modifiedData.push({ date: timeWSRItem.changedAt, data: timeWSRItem });
      }
      if (emailItem) {
        modifiedData.push({ date: emailItem.changedAt, data: emailItem });
      }
      if (mobileItem) {
        modifiedData.push({ date: mobileItem.changedAt, data: mobileItem });
      }

      let maxByDate = lodash.maxBy(modifiedData, obj => moment(obj.date).format());
      let orgStructureResult = await sh.getOrgStructureUp({
        orgCode: currentOrgCode
      });

      let changedBy = lodash.get(maxByDate, 'data.personalDataChangedby', '') || lodash.get(maxByDate, 'data.changedBy', '');
      let userData = await dbProcess.getOneUser({ username: changedBy });
      let changedByEmpCode = '';
      if (userData) {
        changedByEmpCode = userData.empCode;
      }

      let orgLevelCode = lodash.get(organizationItem, 'orgLevelCode', '');
      let wsWsrCode = lodash.get(timeWSRItem, 'wsWsrCode', '');
      let tMWsWsrItem = lodash.find(tMWsWsrList, (val) => val.wsWsrCode === wsWsrCode);

      let orgLevelOrder = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelCode === orgLevelCode);

      let orgLevel300 = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelOrder === FIX_DIV_LEVEL);

      let orgLevel400 = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelOrder === FIX_UNIT_LEVEL);

      let orgLevel500 = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelOrder === FIX_DEPT_LEVEL);

      let orgLevel600 = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelOrder === FIX_SECTION_UNIT_LEVEL);

      let orgLevel700 = lodash.find(lodash.get(orgStructureResult, 'result', []),
        (val) => val.orgLevelOrder === FIX_FUNC_LEVEL);

      let reportToEmpCode = '';
      if (userItem.relatedWithPosition === 0) {
        reportToEmpCode = userItem.managerEmpCode || "";
      } else if (userItem.relatedWithPosition === 1) {
        let parentOrg = lodash.find(positionList, (val) => {
          return val.parentOrgCode === positionItem.parentOrgCode && val.headOfOrg === 1;
        });
        if (parentOrg) {
          let condition = {
            posCode: parentOrg.posCode,
            employmentCode: { [Op.ne]: FIX_EMPLOYMENT_CODE }
          };
          let empData = await dbProcess.getPersonalAssignment(condition);
          if (empData) {
            reportToEmpCode = lodash.get(empData, '[0].empCode', '');
          } else {
            let actingResult = lodash.find(objectRelationList, (val) => val.relatedObjectCode === positionItem.parentPosition)
            if (actingResult) {
              reportToEmpCode = actingResult.objectCode;
            }
          }
        } else {

        }
      }

      let reportToEmpThName = '';
      let reportToEmpEnName = '';
      if (reportToEmpCode) {

        let condition = {
          startDate: moment(param.selection.startDate, globalConstant.dateInputFormat),
          empCodeList: [reportToEmpCode],
        };

        let empData = await this.getEmployeeData(condition);
        if (empData.success) {
          let titleCode = lodash.get(empData, 'result[0].titleCode', '');
          let titleDesc = lodash.find(titleList, (val) => val.titleCode === titleCode);
          let thTitleDesc = lodash.get(titleDesc, 'thTitleDesc', '');
          let enTitleDesc = lodash.get(titleDesc, 'enTitleDesc', '');
          let firstNameTh = lodash.get(empData, 'result[0].firstFName', '');
          let lastNameTh = lodash.get(empData, 'result[0].firstLName', '');
          let firstNameEn = lodash.get(empData, 'result[0].secondFName', '');
          let lastNameEn = lodash.get(empData, 'result[0].secondLName', '');
          reportToEmpThName = `${thTitleDesc} ${firstNameTh} ${lastNameTh}`;
          reportToEmpEnName = `${enTitleDesc} ${firstNameEn} ${lastNameEn}`;
        }
      }

      let activeFlagValue = activeFlag;

      if (activeFlagValue !== '0' && activeFlagValue !== '1') {
        activeFlagValue = lodash.get(userItem, 'employmentCode', null) === "1" ? "1" : "0" || null;
      }

      let item = {
        "authorization": AUTHORIZATION,
        "action": action || null,
        "empCode": lodash.get(userItem, 'empCode', null) || null,
        "empType": (lodash.get(userItem, 'empGroupCode', null) || null) === PERMANENT_EMP_TYPE ? 1 : 0,
        "gender": lodash.get(userItem, 'genderCode', null) || null,
        "titleId": lodash.get(userItem, 'titleCode', null) || null,
        "positionId": lodash.get(userItem, 'posCode', 0) || 0,
        "firstName": lodash.get(userItem, 'firstFName', null) || null,
        "lastName": lodash.get(userItem, 'firstLName', null) || null,
        "firstNameEng": lodash.get(userItem, 'secondFName', null) || null,
        "lastNameEng": lodash.get(userItem, 'secondLName', null) || null,
        "nickName": lodash.get(userItem, 'nickName', null) || null,
        "workStartDate": lodash.get(dateSpecHireResult, '[0].dateData', null) ? moment(lodash.get(dateSpecHireResult, '[0].dateData', null)).utc(7).toJSON() : null,
        "resignEffectiveDate": lodash.get(userItem, 'eventTypeCode', null) === globalConstant.persEventTerminate ? lodash.get(userItem, 'startDate', null) : null || null,
        "activeFlag": activeFlagValue || null,
        "mobilePhone": this.formatPhoneNumber(lodash.get(mobileItem, 'commuInfo', null)) || null,
        "acting": acting,

        "divUnitLevel": orgLevel300 && orgLevel300.orgLevelOrder || null,
        "divCode": lodash.get(orgLevel300, 'orgCode', null) || null,
        "divName": lodash.get(orgLevel300, 'firstDesc', null) || null,
        "unitCode": lodash.get(orgLevel400, 'orgCode', null) || null,
        "unitName": lodash.get(orgLevel400, 'firstDesc', null) || null,
        "deptUnitLevel": lodash.get(orgLevel500, 'orgLevelOrder', null) || null,
        "deptCode": lodash.get(orgLevel500, 'orgCode', null) || null,
        "deptName": lodash.get(orgLevel500, 'firstDesc', null) || null,
        "sectionUnitLevel": lodash.get(orgLevel600, 'orgLevelOrder', null) || null,
        "sectionCode": lodash.get(orgLevel600, 'orgCode', null) || null,
        "sectionName": lodash.get(orgLevel600, 'firstDesc', null) || null,
        "funcCode": lodash.get(orgLevel700, 'orgCode', null) || null,
        "funcName": lodash.get(orgLevel700, 'firstDesc', null) || null,

        "orgUnitCode": currentOrgCode || null,
        "orgUnitName": lodash.get(organizationItem, 'thOrganization', null) || null,
        "positionName": lodash.get(positionItem, 'thPosition', null) || null,
        "positionNameEng": lodash.get(positionItem, 'enPosition', null) || null,
        "title": lodash.get(titleItem, 'thTitleDesc', null) || null,
        "titleEng": lodash.get(titleItem, 'enTitleDesc', null) || null,
        "modifiedDate": maxByDate ? moment(maxByDate.date).utc(7).toJSON() : null,
        "modifiedBy": changedByEmpCode || null,
        "emailSym": lodash.get(emailItem, 'commuInfo', null) || null,
        "empLevelCode": lodash.get(userItem, 'jobLevel', null) || null,
        "empLevelName": lodash.get(jobLevelThItem, 'jobLevelText', null) || null,
        "empLevelNameEng": lodash.get(jobLevelEnItem, 'jobLevelText', null) || null,
        "orgUnitTypeLevel": lodash.get(orgLevelOrder, 'orgLevelOrder', null) || null,
        "orgUnitTypeCode": currentOrgCode || null,
        "orgUnitTypeName": lodash.get(organizationItem, 'thOrganization', null) || null,
        "orgUnitTypeNameEng": lodash.get(organizationItem, 'enOrganization', null) || null,
        "empGroupCode": lodash.get(userItem, 'empSubGroupCode', null) || null,
        "empGroupName": lodash.get(employeeGroupThItem, 'description', null) || null,
        "empGroupNameEng": lodash.get(employeeGroupEnItem, 'description', null) || null,
        "reportToEmpCode": reportToEmpCode || null,
        "reportToEmpFullName": reportToEmpThName || null,
        "reportToEmpFullNameEng": reportToEmpEnName || null,
        "shiftCode": wsWsrCode || null,
        "shiftName": lodash.get(tMWsWsrItem, 'wsWsrText', null) || null,
        "nId": currentOrgCode || null,
        "nParentId": lodash.get(organizationItem, 'parentOrgCode', null) || null,
        "headOfLevel": lodash.get(positionItem, 'headOfOrg', 0) || 0,
      };

      // TODO Hard code พนักงานรหัส 0002 Mr.Kranphol Asawasuwan
      if (currentEmpCode === '0002') {
        item.reportToEmpCode = '0';
        item.reportToEmpFullName = '';
        item.reportToEmpFullNameEng = '';
      }

      functionReturn.result = item;
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'usertoldap/util /main - processRetro', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

}
exports.Util = Util;
[File Ends] util.js


<-- File Content Ends


[File Ends] emptostaffprofile.txt

[File Begins] izignapi.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

izignapi/
├── dbprocess.js
├── service.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const db = require("../../../../config/sequelize/sequelize").getConfig();
const reqContext = require("../../../../utils/requestcontext");

class DbProcess {

  constructor() {}
  
}

module.exports = DbProcess;

[File Ends] dbprocess.js

[File Begins] service.js
const cryptoJS = require("crypto-js");
const lodash = require('lodash');
const btoa = require('btoa');

const reqContext = require('../../../../utils/requestcontext');
const translation = require('../../../../utils/translation');
const env = require("../../../../config/environment/environment").getConfig();
const helper = require('../../../../utils/helper');

const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

class IZignService {

    constructor() {}

    /**
    * @param {string} data  [Required]
    * @param {string} key   [Required]
    * @param {string} iv    [Required]
    * 
    * @returns {FunctionReturn} 
    * @returns {string}     Encrypt string data
    */
    encData(data, key, iv) {
        let secret = cryptoJS.enc.Base64.parse(key);
        let ivDecode = cryptoJS.enc.Base64.parse(iv);
        let encData = cryptoJS.AES.encrypt(data.toString(), secret, {iv: ivDecode});
        return encData.toString();
    }

    hmacData(dataToSign) {
        // secret ปรับไปใช้ env variable 
        let secret = env[reqContext.getTenantCode()].thirdParty.iZign.iZignSecret;
        let hash = cryptoJS.HmacSHA256(dataToSign, secret);
        return hash.toString();
    }
      
    isUseBody(method, contentType) {
        const supportMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];
        return supportMethods.includes(method) && contentType.indexOf('application/json') != -1;
    }
      
    getHmacBody(requestBody, method, contentType) {
        
        let body = '';
        
        if (this.isUseBody(method, contentType)) {
            if (!this.isJsonString(requestBody)) {
                body = JSON.stringify(requestBody);
            } else {
                body = requestBody;
            }
        }

        if (body == null) {
            body = '';
        }

        return body;
    }
    
    isJsonString(val) {
        try {
            JSON.parse(val);
        } catch (e) {
            return false;
        }
        return true;
    }
    
    getHmacContentType(method, contentType) {
        if (this.isUseBody(method, contentType)) {
            return contentType;
        }
        return '';
    }

    /**
    * @param {string} params.requestUrl [Required]
    * @param {string} params.requestHttpMethod [Required]
    * @param {string} params.requestBody
    * 
    * @returns {FunctionReturn} 
    * @returns {string} result.headers.authorization
    * @returns {string} result.headers.xottk
    */
    async preRequest(params) {
        
        let functionReturn = new FunctionReturn();

        try {

            // แก้ไขให้รับ parameter จากต้นฉบับ
            let protocol = env[reqContext.getTenantCode()].thirdParty.iZign.iZignProtocol;
            let requestUrl = lodash.get(params, 'requestUrl', '');
            let requestHttpMethod = lodash.get(params, 'requestHttpMethod', '');
            let requestBody = lodash.get(params, 'requestBody', '');

            if(!requestUrl) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.service.error.requestUrl');
                return functionReturn;
            }

            if(!requestHttpMethod) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.service.error.requestHttpMethod');
                return functionReturn;
            }

            // appId ปรับไปใช้ env variable 
            let appId = env[reqContext.getTenantCode()].thirdParty.iZign.iZignAppID;

            // contentType ปรับไปใช้ env variable 
            let contentType = env[reqContext.getTenantCode()].thirdParty.iZign.iZignContentType;
            let requestTimeStamp = new Date().getTime();
            let nonce = new Date().getTime();
            
            let body = "";
            if (requestBody != null) {
                body = this.getHmacBody(requestBody, requestHttpMethod,  contentType);
            }
            
            let requestContentMD5 = cryptoJS.MD5(body).toString();
            let hmacContentType = this.getHmacContentType(requestHttpMethod, contentType)
            let dataToSign = `${appId}:${protocol}:${requestHttpMethod}:${requestUrl}:${nonce}:${requestTimeStamp}:${hmacContentType}:${requestContentMD5}`.toLowerCase();
            let hmac = this.hmacData(dataToSign);
            let authorization = `${appId}:${hmac}:${nonce}:${requestTimeStamp}`;
            let xottk = authorization.toString(cryptoJS.enc.Base64);
            let xottkBase64 = btoa(xottk);
                        
             // ใช้ return function เป็น functionReturn
            functionReturn.success = true;
            functionReturn.result = {
                headers: {
                    xottk: xottkBase64,
                }
                
            };

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/service - preRequest', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }
}

exports.IZignService = IZignService;

[File Ends] service.js

[File Begins] util.js
const lodash = require("lodash");
const axios = require('axios');
const fs = require('fs');

const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const env = require('../../../../config/environment/environment').getConfig();

const IZignService = require('./service').IZignService;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const targetCreateType = '2'

const echo = '/echo';
const createDocument = '/documents/api-interface/create';
const downloadDocument = '/documents/download';
const voidDocument = '/documents/api-interface/void';
const deleteDocument = '/documents/api-interface/documents';
const downloadDocumentCertificate = '/documents/signing-detail/export/pdf';

const method = {
    get: 'GET',
    post: 'POST',
    delete: 'DELETE'
}

class Util {

    constructor() {}

    getIZignToken() {

        let functionReturn = new FunctionReturn();

        try {

            let encryptPath = env[reqContext.getTenantCode()].thirdParty.iZign.encryptTokenFile;
            let secretKey = env[reqContext.getTenantCode()].thirdParty.iZign.encryptTokenSecretKey;
            let encryptText = fs.readFileSync(encryptPath, 'utf8');

            if (encryptText) {
                functionReturn = helper.decrypt(encryptText, secretKey)
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.configFileNotFound');
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - getIZignToken', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async partnersEcho() {
        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let params = {
                requestUrl: echo,
                requestHttpMethod: method.post,
                requestBody: {
                    text: "Hello partners echo!"
                },
            };

            let headerResponse = await iZignService.preRequest(params);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let body = params.requestBody;
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${echo}`, body, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api partnersEcho) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.displayMessageEn');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    * @param {string[]} params.additionalFileUrls Url of attachment file (support: pdf, jpg, png)
    * @param {string} params.category [Required] Category of document
    * @param {string} params.companyCode [Required] Code of company
    * @param {string} params.createType [Required] “1” = Create with PDF file, “2” = Create with Template
    * @param {string} params.description Document description
    * @param {string} params.deviceName Device name for create document
    * @param {string} params.dueDate Expired date to sign of document with format "2023-01-15T09:30:16.888Z"
    * @param {string} params.fileName [Required] File name of document
    * @param {string} params.fileUrl [Required] Url of file for create document (required when createType is “1”)
    * @param {string[]} params.hashtagList Hash tag of document
    * @param {string} params.referenceNo [Required] Document reference (unique)
    * @param {string} params.ref1 Other reference of document
    * @param {string} params.ref2 Other reference of document
    * @param {string} params.remark Remark of document
    * @param {bool} params.signByOrder [Required] true: User can be signed by queue, false: All user can be signed
    * @param {string} params.subCategory Sub category of document
    * @param {string} params.templateCode [Required] Template code (required when createType is “2”)
    * @param {number} params.templateDataType [Required] "Type of template data (required when createType is “2”) 1 = Used templateData, 2 = Use templateDataList"
    * @param {Object} params.templateData [Required] Data for mapping in template (required when createType is “2” and templateDatType is 1)
    * @param {Object[]} params.templateDataList [Required] Data for mapping in template (required when createType is “2” and templateDatType is 2)
    * @param {Object} params.userCreatorData [Required] User creator document data
    * @param {Object[]} params.userSignerList [Required] List of user signer data
    * @param {string} params.vendorCompanyName Company name of vendor
    * @param {Object[]} params.eventCallback Handle callback authentication and additional data by event
    *
    *
    */
    async createDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!params) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.parameter');
                return functionReturn;
            }

            if (!params.category) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.category');
                return functionReturn;
            }

            if (!params.companyCode) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.companyCode');
                return functionReturn;
            }

            if (!params.createType) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.createType');
                return functionReturn;
            }

            if (!params.fileName) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.fileName');
                return functionReturn;
            }

            if (!params.fileUrl) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.fileUrl');
                return functionReturn;
            }

            if (!params.referenceNo) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.referenceNo');
                return functionReturn;
            }

            if (!params.signByOrder) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.signByOrder');
                return functionReturn;
            }

            if (params.createType === targetCreateType) {

                if (!params.templateCode) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateCode');
                    return functionReturn;
                }

                if (!params.templateDataType) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateDataType');
                    return functionReturn;
                }

                if (!params.templateData) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateData');
                    return functionReturn;
                }

            }

            if (!params.templateDataList) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateDataList');
                return functionReturn;
            }

            if (!params.userCreatorData) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.userCreatorData');
                return functionReturn;
            }

            if (!params.userSignerList) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.userSignerList');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: createDocument,
                requestHttpMethod: method.post,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${createDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api createDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                if (!errorMessage) {
                    errorMessage = lodash.get(error, 'message', '');
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - createDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    * @param {string} id [Required] Document Id
    */
    async downloadDocument(documentId) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            let params = {
                requestUrl: `${downloadDocument}/${documentId}`,
                requestHttpMethod: method.get
            };

            let headerResponse = await iZignService.preRequest(params);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.get(`${apiHost}${downloadDocument}/${documentId}`, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api downloadDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
     * Downloads a certificate document using the provided parameters.
     *
     * @param {Object} params - The parameters for the request.
     * @param {string} params.documentId - The documentId of the request.
     * @return {Promise<FunctionReturn>} A promise that resolves to a FunctionReturn object containing the result and success status of the request.
     */
    async downloadDocumentCertificate(params) {
        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!params) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: downloadDocumentCertificate,
                requestHttpMethod: method.post,
                requestBody: params
            };

            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${downloadDocumentCertificate}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocumentCertificate (Call api downloadDocumentCertificate) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocumentCertificate', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    *  @param {string} documentId [Required] Document Id
    *  @param {string} userEmail [Required] User email for void
    *  @param {string} voidedReason [Required] Reason of void
    *  @param {string} deviceName Device name for create document
    */
    async voidDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let documentId = lodash.get(params, 'documentId', '');
            let userEmail = lodash.get(params, 'userEmail', '');

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            if (!userEmail) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.api.util.error.userEmail');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: voidDocument,
                requestHttpMethod: method.post,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${voidDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api voidDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - voidDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    *  @param {string} documentId [Required] Document Id
    *  @param {string} userEmail [Required] User email for void
    */
    async deleteDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let documentId = lodash.get(params, 'documentId', '');
            let userEmail = lodash.get(params, 'userEmail', '');

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            if (!userEmail) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.api.util.error.userEmail');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: deleteDocument,
                requestHttpMethod: method.delete,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${deleteDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                    });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api deleteDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - deleteDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

}

exports.Util = Util;
[File Ends] util.js


<-- File Content Ends


[File Ends] izignapi.txt

[File Begins] pahadvanceapi.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

pahadvanceapi/
├── dbprocess.js
├── service.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const db = require("../../../../config/sequelize/sequelize").getConfig();
const reqContext = require("../../../../utils/requestcontext");

class DbProcess {

  getPersonalCommunication(condition = {}) {
    const PersonalCommunication = db[reqContext.getTenantCode()].PersonalCommunication;
    return PersonalCommunication.findAll({
      raw: true,
      where: condition,
    });
  }

  getPersonalID(condition = {}) {
    const PersonalID = db[reqContext.getTenantCode()].PersonalID;
    return PersonalID.findAll({
      raw: true,
      where: condition,
    });
  }

  getTPTPahAdvProduct(condition = {}) {
    const TPTPahAdvProduct = db[reqContext.getTenantCode()].TPTPahAdvProduct;
    return TPTPahAdvProduct.findOne({
      raw: true,
      where: condition,
    });
  }

}

module.exports = DbProcess;

[File Ends] dbprocess.js

[File Begins] service.js
const helper = require('../../../../utils/helper');
const { spawn } = require('child_process');


class PahAdvanceApiService {

    constructor() {}

    nodeSpawn(args) {
        return new Promise((resolve, reject) => {
            const { method, url, headers, data } = args;

            let curlBody = [];
            if (method.toUpperCase() === 'GET') {
                curlBody = [
                    '-X', method.toUpperCase(),
                    url,
                    '-H', `token: ${headers.token}`,
                    '-H', `module-key: ${headers['module-key']}`,
                    '-H', `X-API-KEY: ${headers['X-API-KEY']}`,
                    '-H', `Content-Type: ${headers['Content-Type']}`,
                    '-L', //  url ที่เราทำการขอดึงข้อมูลนั้นมีการ redirect ไปที่อื่น การที่เราจะให้มัน following redirect ด้วย ทำได้โดยการใส่ option -L
                ];
            } else if (method.toUpperCase() === 'POST') {
                curlBody = [
                    '-X', method.toUpperCase(),
                    url,
                    '-H', `token: ${headers.token}`,
                    '-H', `module-key: ${headers['module-key']}`,
                    '-H', `X-API-KEY: ${headers['X-API-KEY']}`,
                    '-H', `Content-Type: ${headers['Content-Type']}`,
                    '-d', data,
                    '-L', //  url ที่เราทำการขอดึงข้อมูลนั้นมีการ redirect ไปที่อื่น การที่เราจะให้มัน following redirect ด้วย ทำได้โดยการใส่ option -L
                ];
            }
            const curl = spawn('curl', curlBody);

            let stdoutData = '';
            let stderrData = '';

            curl.stdout.on('data', (data) => {
                if (data.toString()) {
                    try {
                        stdoutData += data.toString();
                    } catch (error) {
                        helper.logMessage('error', error.stack, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                    }
                }
            });

            curl.stderr.on('data', (error) => {
                stderrData = error.toString();
            });

            curl.on('close', (code) => {
                if (code === 0) {
                    try {
                        resolve({ data: JSON.parse(stdoutData), stderr: null });
                    } catch (error) {
                        resolve({ data: null, stderr: stdoutData });
                    }
                } else {
                    helper.logMessage('error', stderrData, '/thirdparty/pahadvance/pahadvanceapi/service - nodeSpawn', '', '', '', '');
                    resolve({ data: null, stderr: stderrData });
                }
            });

            curl.on('error', (err) => {
                reject(err);
            });
        });
    }

}

exports.PahAdvanceApiService = PahAdvanceApiService;

[File Ends] service.js

[File Begins] util.js
const _ = require("lodash");
const crypto = require('crypto');
const axios = require('axios');
const Sequelize = require('sequelize');
const fs = require('fs');
const moment = require('moment');
const FormData = require('form-data');
const env = require('../../../../config/environment/environment').getConfig();
const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const DBProcess = require('./dbprocess');
const PahAdvanceApiService = require('./service').PahAdvanceApiService;

const Op = Sequelize.Op;

const algorithm = 'aes-256-cbc';
const submitCheckPath = '/partner/loan/submit-check/';
const contractListPath = '/partner/contract/list/';
const contractDetailPath = '/partner/contract/';
const loanSubmit = '/partner/loan/submit';
const submitPayback = '/partner/payback/pay/';

const errorTutorialDialogCode = "ERR-006";

class Util {

    constructor() {}

    getPahAdvanceEncryptToken() {
        let functionReturn = new FunctionReturn();

        try {

            let encryptPath = env[reqContext.getTenantCode()].thirdParty.pahAdvance.encryptTokenFile;
            let encryptText = fs.readFileSync(encryptPath, 'utf8');

            functionReturn.result = encryptText;
            functionReturn.success = true;

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getPahAdvanceEncryptToken', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    getEnCryption(data) {

        let functionReturn = new FunctionReturn();

        try {
            let plainText = _.get(data, 'text', '');
            let IV = _.get(data, 'iv', '');           // e.g. "DSpxkYIMKi+K9vXvJFVqmQ==";
            let ENC_KEY = _.get(data, 'key', '');     // e.g. "JqAK7Ml2EeUVcZUSNxZqxsU6kEP0JW4naxRHzkVU3cA=";

            if (plainText && IV && ENC_KEY) {

                let iv = Buffer.from(IV, 'base64');
                let key = Buffer.from(ENC_KEY, 'base64');

                let cipher = crypto.createCipheriv(algorithm, key, iv);
                let encrypted = cipher.update(plainText);
                encrypted = Buffer.concat([encrypted, cipher.final()]);

                functionReturn.success = true;
                functionReturn.result = encrypted.toString('base64');

            } else {
                functionReturn.success = false;
                functionReturn.result = null;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getEnCryption', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    getApiEncryptTokenSecretKey() {
        let functionReturn = new FunctionReturn();

        try {

            let decryptSecretKey = env[reqContext.getTenantCode()].thirdParty.pahAdvance.encryptTokenSecretKey;
            let apiTokenResult = this.getPahAdvanceEncryptToken();

            let getTonkenString = _.get(apiTokenResult, 'result', '');
            let apiToken = helper.decryptToJson(getTonkenString, decryptSecretKey);

            functionReturn = apiToken;

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getApiEncryptTokenSecretKey', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    async getLoanSubmitCheck() {
        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let apiHost = env[reqContext.getTenantCode()].thirdParty.pahAdvance.apiHost;
            let empInfo = {};

            let apiToken = this.getApiEncryptTokenSecretKey();
            if (apiToken.success === false) {
                functionReturn = apiToken;
                return functionReturn;
            }

            let persCommuMOBCondition = {
                empCode: reqContext.getCurrentEmpCode(),
                commuType: "MOB",
                startDate: { [Op.lte]: new Date() },
                endDate: { [Op.gte]: new Date() }
            };
            let persDataMobCommu = await dbProcess.getPersonalCommunication(persCommuMOBCondition);
            empInfo.phoneNo = _.get(persDataMobCommu, '[0].commuInfo', '');

            let persIDCondition = {
                empCode: reqContext.getCurrentEmpCode(),
                idTypeCode: '01',
                startDate: { [Op.lte]: new Date() },
                endDate: { [Op.gte]: new Date() }
              };
            let persDataID = await dbProcess.getPersonalID(persIDCondition);
            empInfo.idCardNo = _.get(persDataID, '[0].identityNumber', '');

            let encryptParam = {
                text: moment().add(7, 'hours').utc().format(),
                iv: _.get(apiToken, 'result.encryptToken.encryptTokenIV', ''),
                key: _.get(apiToken, 'result.encryptToken.encryptTokenKey', ''),
            };
            let tokenEnCrypt = this.getEnCryption(encryptParam);

            if (tokenEnCrypt.success === false) {
                functionReturn = tokenEnCrypt;
                return functionReturn;
            }

            let configHeaders = {
                token: _.get(tokenEnCrypt, 'result', ''),
                'module-key': _.get(apiToken, 'result.headers.module_key', ''),
                'X-API-KEY': _.get(apiToken, 'result.headers.x_api_key', ''),
                'Content-Type': 'application/json'
            }

            let getTPTPahAdvProduct = await dbProcess.getTPTPahAdvProduct();
            let getLoanProductId = _.get(getTPTPahAdvProduct, 'loanProductId', '');
            let getModuleId = _.get(getTPTPahAdvProduct, 'moduleId', '');
            let getSubModuleId = _.get(getTPTPahAdvProduct, 'subModuleId', '');

            let config = {
                method: 'post',
                url: `${apiHost}${submitCheckPath}`,
                headers: configHeaders,
                data : JSON.stringify({
                    ...empInfo,
                    loanProductId: getLoanProductId,
                    moduleId: getModuleId,
                    subModuleId: getSubModuleId
                })
            };

            // TODO Fix bug Node TLSv1.2 is not allowed for Pah advance uat. required only TLSv1.3.
            // let response = await axios(config);
            let apiService = new PahAdvanceApiService();
            let response = await apiService.nodeSpawn(config);

            let getResult = _.get(response, 'data', null);

            if (!_.isEmpty(getResult)) {

                functionReturn.result = getResult;
                functionReturn.success = true;

                let getStatus = _.get(getResult, 'result', false);
                let getErrorCode = _.get(getResult, 'code', '');

                if (getErrorCode === errorTutorialDialogCode) {
                    functionReturn.message = translation.getTranslateText('thirdparty.pahadvance.api.error.error006');
                    functionReturn.success = false;
                }

                if (getStatus === false) {
                    functionReturn.message = _.get(getResult, 'message', '');
                    functionReturn.success = false;
                }

            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('thirdparty.pahadvance.api.error.submitCheckDataNotFound');
                return functionReturn
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getLoanSubmitCheck', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async getContractList(params) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let { empCode, limitPage, state, status } = params;

        try {

            let apiHost = env[reqContext.getTenantCode()].thirdParty.pahAdvance.apiHost;

            let apiToken = this.getApiEncryptTokenSecretKey();
            if (apiToken.success === false) {
                functionReturn = apiToken;
                return functionReturn;
            }

            let encryptParam = {
                text: moment().add(7, 'hours').utc().format(),
                iv: _.get(apiToken, 'result.encryptToken.encryptTokenIV', ''),
                key: _.get(apiToken, 'result.encryptToken.encryptTokenKey', ''),
            };
            let tokenEnCrypt = this.getEnCryption(encryptParam);

            let configHeaders = {
                token: _.get(tokenEnCrypt, 'result', ''),
                'module-key': _.get(apiToken, 'result.headers.module_key', ''),
                'X-API-KEY': _.get(apiToken, 'result.headers.x_api_key', ''),
                'Content-Type': 'application/json'
            }

            let getTPTPahAdvProduct = await dbProcess.getTPTPahAdvProduct();
            let getModuleId = _.get(getTPTPahAdvProduct, 'moduleId', '');
            let getSubModuleId = _.get(getTPTPahAdvProduct, 'subModuleId', '');
            let getLoanProductId = _.get(getTPTPahAdvProduct, 'loanProductId', '');

            let dataParams = {
                limit: limitPage,
                moduleId: getModuleId,
                subModuleId: getSubModuleId,
                loanProductId: getLoanProductId
            };

            if (empCode) {
                dataParams.ref1 = empCode;
            }

            if (state) {
                dataParams.state = state;
            }

            if (status) {
                dataParams.status = status;
            }

            let config = {
                method: 'post',
                url: `${apiHost}${contractListPath}`,
                headers: configHeaders,
                data : JSON.stringify(dataParams)
            };
            helper.logMessage('error', JSON.stringify(config), 'PAH API REQUEST', '', '', '', '');

            // TODO Fix bug Node TLSv1.2 is not allowed for Pah advance uat. required only TLSv1.3.
            // let response = await axios(config);
            let apiService = new PahAdvanceApiService();
            let response = await apiService.nodeSpawn(config);

            helper.logMessage('error', JSON.stringify(response.headers), 'PAH API RESPONSE HEADER', '', '', '', '');
            helper.logMessage('error', JSON.stringify(response.data), 'PAH API RESPONSE DATA', '', '', '', '');
            helper.logMessage('error', response, 'PAH API RESPONSE', '', '', '', '');

            let getResult = _.get(response, 'data', null);
            if (getResult) {
                functionReturn.success = true;
                functionReturn.result = getResult;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('thirdparty.pahadvance.api.error.contractListNotFound');
                return functionReturn
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getContractList', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async getContractDetail(linearId) {
        let functionReturn = new FunctionReturn();

        try {

            if (!linearId) {
                functionReturn.message = translation.getTranslateText('thirdparty.pahadvance.api.error.requireLinearId');
                functionReturn.success = false;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.pahAdvance.apiHost;

            let apiToken = this.getApiEncryptTokenSecretKey();
            if (apiToken.success === false) {
                functionReturn = apiToken;
                return functionReturn;
            }

            let encryptParam = {
                text: moment().add(7, 'hours').utc().format(),
                iv: _.get(apiToken, 'result.encryptToken.encryptTokenIV', ''),
                key: _.get(apiToken, 'result.encryptToken.encryptTokenKey', ''),
            };
            let tokenEnCrypt = this.getEnCryption(encryptParam);

            let configHeaders = {
                token: _.get(tokenEnCrypt, 'result', ''),
                'module-key': _.get(apiToken, 'result.headers.module_key', ''),
                'X-API-KEY': _.get(apiToken, 'result.headers.x_api_key', ''),
                'Content-Type': 'application/json'
            }

            let config = {
                method: 'get',
                url: `${apiHost}${contractDetailPath}${linearId}`,
                headers: configHeaders,
            };


            // TODO Fix bug Node TLSv1.2 is not allowed for Pah advance uat. required only TLSv1.3.
            // let response = await axios(config);
            let apiService = new PahAdvanceApiService();
            let response = await apiService.nodeSpawn(config);

            let getResult = _.get(response, 'data', null);
            if (getResult) {
                functionReturn.success = true;
                functionReturn.result = getResult;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('thirdparty.pahadvance.api.error.contractListNotFound');
                return functionReturn
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - getContractDetail', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async loanSubmit(params) {
        let functionReturn = new FunctionReturn();

        try {
            let form = new FormData();

            for (let key in params) {
                const value = params[key];
                form.append(key, value);
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.pahAdvance.apiHost;

            let apiToken = this.getApiEncryptTokenSecretKey();
            if (apiToken.success === false) {
                functionReturn = apiToken;
                return functionReturn;
            }

            let encryptParam = {
                text: moment().add(7, 'hours').utc().format(),
                iv: _.get(apiToken, 'result.encryptToken.encryptTokenIV', ''),
                key: _.get(apiToken, 'result.encryptToken.encryptTokenKey', ''),
            };

            let tokenEnCrypt = this.getEnCryption(encryptParam);

            let configHeaders = {
                token: _.get(tokenEnCrypt, 'result', ''),
                'module-key': _.get(apiToken, 'result.headers.module_key', ''),
                'X-API-KEY': _.get(apiToken, 'result.headers.x_api_key', ''),
                'Content-Type': form.getHeaders()['content-type']
            }

            let config = {
                method: 'post',
                url: `${apiHost}${loanSubmit}`,
                headers: configHeaders,
                data: form.getBuffer()
            };

            // TODO Fix bug Node TLSv1.2 is not allowed for Pah advance uat. required only TLSv1.3.
            // response = await axios.post(`${apiHost}${loanSubmit}`, form, { headers: configHeaders });
            let apiService = new PahAdvanceApiService();
            let response = await apiService.nodeSpawn(config);
            let responseData = _.get(response, 'data', '');

            if (!responseData.statusCode && !responseData.status) {
                functionReturn.result = responseData;
                functionReturn.success = true;
            } else {
                let errorMessage = '';
                let getENErrorMessage = _.get(responseData, 'displayMessageEn', '');
                let getTHErrorMessage = _.get(responseData, 'displayMessageTh', '');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - loanSubmit', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    async submitPayback(params) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            if (params.length < 1) {
                functionReturn.message = 'Error submit payback params not empty';
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.pahAdvance.apiHost;

            let apiToken = this.getApiEncryptTokenSecretKey();
            if (apiToken.success === false) {
                functionReturn = apiToken;
                return functionReturn;
            }

            let encryptParam = {
                text: moment().add(7, 'hours').utc().format(),
                iv: _.get(apiToken, 'result.encryptToken.encryptTokenIV', ''),
                key: _.get(apiToken, 'result.encryptToken.encryptTokenKey', ''),
            };

            let tokenEnCrypt = this.getEnCryption(encryptParam);

            let configHeaders = {
                token: _.get(tokenEnCrypt, 'result', ''),
                'module-key': _.get(apiToken, 'result.headers.module_key', ''),
                'X-API-KEY': _.get(apiToken, 'result.headers.x_api_key', ''),
                'Content-Type': 'application/json'
            }

            let getTPTPahAdvProduct = await dbProcess.getTPTPahAdvProduct();
            let getLoanProductId = _.get(getTPTPahAdvProduct, 'loanProductId', '');
            let getModuleId = _.get(getTPTPahAdvProduct, 'moduleId', '');
            let getSubModuleId = _.get(getTPTPahAdvProduct, 'subModuleId', '');

            let config = {
                method: 'post',
                url: `${apiHost}${submitPayback}`,
                headers: configHeaders,
                data : JSON.stringify({
                    moduleId: getModuleId,
                    subModuleId: getSubModuleId,
                    paybackDetailList: params
                })
            };


            // TODO Fix bug Node TLSv1.2 is not allowed for Pah advance uat. required only TLSv1.3.
            // let response = await axios(config);
            let apiService = new PahAdvanceApiService();
            let response = await apiService.nodeSpawn(config);
            let responseData = _.get(response, 'data', {});
            let statusCode = _.get(responseData, 'statusCode', '');
            let status = _.get(responseData, 'status', '');

            if (!statusCode && !status) {
                functionReturn = responseData;
                functionReturn.success = true;
            } else {
                let errorMessage = '';
                let getErrorENMessage = _.get(responseData, 'displayMessageEn', '');
                let getErrorTHMessage = _.get(responseData, 'displayMessageTh', '');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getErrorTHMessage;
                } else {
                    errorMessage = getErrorENMessage;
                }

                functionReturn = getResponse;
                functionReturn.message = errorMessage;
                functionReturn.success = false;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'thirdparty/pahadvance/pahadvanceapi/util - submitPayback', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

}

exports.Util = Util;
[File Ends] util.js


<-- File Content Ends


[File Ends] pahadvanceapi.txt

[File Begins] payrollposting.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

payrollposting/
├── dbprocess.js
├── main.js
├── outputstructure.js
├── serviceapi.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const Sequelize = require('sequelize');
const reqContext = require('../../../../utils/requestcontext');
const db = require('../../../../config/sequelize/sequelize').getConfig();

class DbProcess {

    async getEmployeeData(condition) {

        const personalData = db[reqContext.getTenantCode()].PersonalData;
        const personalAssignment = db[reqContext.getTenantCode()].PersonalAssignment;

        return personalData.findAll({
            raw: true,
            attributes: [
                'empCode',
                ['firstFName', 'thFirstName'],
                ['secondFName', 'enFirstName'],
                ['firstLName', 'thLastName'],
                ['secondLName', 'enLastName'],
                ['firstMName', 'thMiddleName'],
                ['secondMName', 'enMiddleName'],
                'PersonalAssignments.persAreaCode',
                'PersonalAssignments.persSubAreaCode',
                'PersonalAssignments.comCode',
                'PersonalAssignments.empGroupCode',
            ],
            include: [{
                required: true,
                model: personalAssignment,
                attributes: [],
                where: condition.personalAssignmentCondition
            }],
            where: condition.personalDataCondition,
            order: [
                ['empCode', 'ASC']
            ]
        })

    }

    getPayrollDirectory(condition) {

        return db[reqContext.getTenantCode()].PayrollResultDirectory.findAll({
            raw: true,
            attributes: [
                'empCode',
                'id',
                'seqNo',
                'paymentDate',
                'forPeriod',
                'forYear',
                'inPeriod',
                'inYear',
                'resultIndicator'
            ],
            where: condition,
            order: [
                ['empCode', 'ASC']
            ]
        })

    }

    getRecordPayrollDirectory(condition) {
        return db[reqContext.getTenantCode()].PayrollResultDirectory.findAll({
            raw: true,
            attributes: [
                'id'
            ],
            where: condition,
            order: [
                ['seqNo', 'DESC']
            ]
        })
    }

    getRT(condition) {

        return db[reqContext.getTenantCode()].RT.findAll({
            raw: true,
            attributes: [
                'rgdirID',
                'wtCode',
                'amount',
                'quantity',
                'rate',
                'costDistributionNo',
                'forPeriod',
                'forYear',
                'costAssignmentNo'
            ],
            where: condition,
            order: [
                ['rgdirID', 'ASC'],
                ['wtCode', 'ASC']
            ]
        })

    }

    getRTRetroWT(condition) {
        const rt = db[reqContext.getTenantCode()].RT;
        const wageType = db[reqContext.getTenantCode()].WageType;
        return rt.findAll({
            raw: true,
            attributes: [
                'rgdirID',
                'wtCode',
                'amount',
                'quantity',
                'rate'
            ],
            include: [{
                required: true,
                model: wageType,
                attributes: [],
                where: condition.wageTypeCondition
            }],
            where: condition.rtCondition,
            order: [
                ['rgdirID', 'ASC'],
                ['wtCode', 'ASC']
            ]
        })

    }

    getPayrollPeriod(condition) {

        return db[reqContext.getTenantCode()].PayrollPeriod.findAll({
            raw: true,
            attributes: [
                'payrollPeriodCode',
                'period',
                'year',
                'startDate',
                'endDate',
                'paymentDate',
                'payrollAreaCode'
            ],
            where: condition
        })

    }

    getOnePayrollPeriod(condition) {

        return db[reqContext.getTenantCode()].PayrollPeriod.findOne({
            raw: true,
            attributes: [
                'payrollPeriodCode',
                'period',
                'year',
                'startDate',
                'endDate',
                'paymentDate',
                'payrollAreaCode'
            ],
            where: condition
        })

    }

    getPYAccountMapping(condition) {
        const pyAccountMap = db[reqContext.getTenantCode()].PYAccountMapping;
        return pyAccountMap.findAll({
            raw: true,
            attributes: [
                "wtCode",
                "accountGroupCode",
                "ignoreCostDistribution",
            ],
            where: condition
        })
    }

    getWageType(condition) {
        const wageType = db[reqContext.getTenantCode()].WageType;
        return wageType.findAll({
            raw: true,
            attributes: [
                "wtCode",
                "recWTCode",
            ],
            where: condition
        })
    }

    getPYAccountDetail(condition) {
        const pyAccountDetail = db[reqContext.getTenantCode()].PYAccountDetail;
        return pyAccountDetail.findAll({
            raw: true,
            attributes: [
                "company",
                "accEmpGroupCode",
                "accountGroupCode",
                "debit",
                "credit",
                "reclassFlag",
                "reclassDebit",
                "debitChargeExpenseCode",
                "creditChargeExpenseCode"
            ],
            where: condition
        })
    }

    getPYAccount(condition) {
        const pyAccount = db[reqContext.getTenantCode()].PYAccount;
        return pyAccount.findAll({
            raw: true,
            attributes: [
                "accountCode",
                "pyAccType",
                "rate",
                [Sequelize.col('ConfigText.description'), 'accountCodeDesc'],
            ],
            include: [{
                required: false,
                model: db[reqContext.getTenantCode()].ConfigText,
                attributes: [],
                where: {
                    configTableCode: 'PYAccount',
                    langKeyCode: reqContext.getLanguage()
                }
            }],
            where: condition
        })
    }

    getPYAccountEmpGroupingDetail(condition) {
        const pyAccountEmpGrouping = db[reqContext.getTenantCode()].PYAccountEmpGrouping;
        return pyAccountEmpGrouping.findAll({
            raw: true,
            where: condition,
        })
    }

    getPYCostDistribution(condition) {
        const pyCostDistribution = db[reqContext.getTenantCode()].PYCostDistribution;
        return pyCostDistribution.findAll({
            raw: true,
            attributes: [
                "comCode",
                "costCenterCode",
                "rgdirID",
                "percent",
                "orderNumber",
                "sequenceNo"
            ],
            where: condition
        })
    }

    getPYWPBP(condition) {
        const pyWPBP = db[reqContext.getTenantCode()].PYWPBP;
        return pyWPBP.findAll({
            raw: true,
            attributes: [
                "comCode",
                "empGroupCode",
                "costCenter",
                "rgdirID",
                "orgCode",
                "posCode"
            ],
            where: condition
        })
    }

    getAllPYWPBP(condition) {
        const pyWPBP = db[reqContext.getTenantCode()].PYWPBP;
        return pyWPBP.findAll({
            raw: true,
            where: condition
        })
    }


    //Update posting
    getCGPAYROLLMergeDoc(condition) {
        const mergeDoc = db[reqContext.getTenantCode()].CGPAYROLLMergeDoc;
        return mergeDoc.findAll({
            raw: true,
            where: condition,
        })
    }

    createCGPAYROLLMergeDoc(data, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLMergeDoc.create(data, {
            transaction: transaction
        });
    }

    updateCGPAYROLLMergeDoc(data, condition, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLMergeDoc.update(
            data, {
            where: condition,
            transaction: transaction
        });
    }

    creatBulkeCGPAYROLLSouceDoc(params, transaction) {
        const tenant = reqContext.getTenantCode();
        return db[tenant].CGPAYROLLSouceDoc.bulkCreate(params, { transaction: transaction });
    };

    creatBulkeCGPAYROLLPostDetail(params, transaction) {
        const tenant = reqContext.getTenantCode();
        return db[tenant].CGPAYROLLPostDetail.bulkCreate(params, { transaction: transaction });
    };

    deletePostDetail(condition, transaction) {
        return db[reqContext.getTenantCode()].CGPAYROLLPostDetail.destroy({
            where: condition,
            transaction: transaction
        })

    }

    getParameter(condition) {

        const parameter = db[reqContext.getTenantCode()].Parameter;

        return parameter.findAll({
            raw: true,
            attributes: [
                'id',
                'paramGroup',
                'paramName',
                'lowValue',
                'remark'
            ],
            where: condition
        })
    }

    getNumberRangeDetail(condition) {
        const numberRangeDetail = db[reqContext.getTenantCode()].NumberRangeDetail;
        return numberRangeDetail.findOne({
            raw: true,
            where: condition
        })
    }

    updateNumberRangeDetail(data, condition, transaction) {
        const numberRangeDetail = db[reqContext.getTenantCode()].NumberRangeDetail;
        return numberRangeDetail.update(
            data, {
            where: condition,
            transaction: transaction
        });
    }

    getPosition(condition = {}) {
        const position = db[reqContext.getTenantCode()].Position;
        return position.findAll({
            raw: true,
            where: condition
        })
    }

    getPYCostAssignment(condition = {}) {
        const pyCostAssignment = db[reqContext.getTenantCode()].PYCostAssignment;
        return pyCostAssignment.findAll({
            raw: true,
            where: condition
        })
    }


    getCurrentPeriod(condition) {
        return db[reqContext.getTenantCode()].PayrollControlRecord.findOne({
            raw: true,
            attributes: [
                'currentPeriod',
                'currentYear',
            ],
            where: condition
            // where: {
            //   payrollAreaCode: payrollArea
            // }
        })
    }
}

module.exports = DbProcess;
[File Ends] dbprocess.js

[File Begins] main.js
const path = require("path");

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');

const BGProcess = require('../../../../utils/bgprocess').BGProcess;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const PayrollPostingProcessingUtil = require('./util').PayrollPostingProcessingUtil;

const program = 'TNT_ASSETWISE01';
const globalConstant = require('../../../../config/constant');

exports.initPage = async (req, res, next) => {
    let functionReturn = new FunctionReturn();

    try {

        let payrollPostingProcessingUtil = new PayrollPostingProcessingUtil();
        functionReturn = await payrollPostingProcessingUtil.initPage(); 

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/main - initPage', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn);
}

exports.main = async (req, res, next) => {
    if (!req.body.bgProcess.isProcess) {

        let appExecutionID = await helper.logAppExecution({
            programCode: program,
            isBGProcess: false,
            selection: req.body,
            event: globalConstant.logAppUsageEvent.start
        });

        await execute(req.body, new BGProcess(program), res, next);

        await helper.logAppExecution({
            appExecutionID: appExecutionID,            
            event: globalConstant.logAppUsageEvent.finish
        });

    } else {
        let controller = path.resolve(__dirname) + '/main'
        let functionReturn = await new BGProcess(program).start(controller, req.body)
        res.json(functionReturn)
    }
}

exports.onInputChange = async (req, res) => {

    let functionReturn = new FunctionReturn();

    try {

        let params = req.body;
        let payrollPostingProcessingUtil = new PayrollPostingProcessingUtil();
        functionReturn = await payrollPostingProcessingUtil.onInputChange(params); 

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/main - onInputChange', '', '', '', '');
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn)
}

exports.onCompanyChange = async (req, res) => {

    let functionReturn = new FunctionReturn();

    try {

        let params = req.body;
        let payrollPostingProcessingUtil = new PayrollPostingProcessingUtil();
        functionReturn = await payrollPostingProcessingUtil.onCompanyChange(params); 

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/main - onCompanyChange', '', '', '', '');
        functionReturn.success = false
        functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    res.json(functionReturn)
}

exports.jobSchedule = async (req) => {
    let controller = path.resolve(__dirname) + '/main'

    req.body.empStatusList = req.body.empStatus;
    req.body.persAreaList = req.body.personnelArea;
    req.body.persSubAreaList = req.body.personnelSubArea;
    req.body.empGroupList = req.body.empGroup;
    req.body.empSubGroupList = req.body.empSubGroup;

    let functionReturn = await new BGProcess(program).start(controller, req.body)
    return functionReturn
}

process.on('message', async (bgProcess) => {

    bgProcess = Object.assign(new BGProcess(), bgProcess)
    bgProcess.startAt = new Date(bgProcess.startAt)
    bgProcess.functionReturn = new FunctionReturn()
    await execute(bgProcess.selection, bgProcess)

})

const execute = async (selection, bgProcess, res = null, next = null) => {

    let functionReturn = new FunctionReturn()
    try {

        let param = {
            selection: selection.data,
            bgProcess: bgProcess,
            res: res
        }
        let payrollPostingProcessingUtil = new PayrollPostingProcessingUtil();
        functionReturn = await payrollPostingProcessingUtil.execute(param);

    } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/main - execute', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
        bgProcess.handleError(functionReturn, res);
    }
}

[File Ends] main.js

[File Begins] outputstructure.js
exports.createOutputStructure = () => {
    let outputStructure = {};
    outputStructure['separateIndicator'] = '';
    outputStructure['documentDate'] = '';
    outputStructure['documentType'] = '3A';
    outputStructure['companyCode'] = '';
    outputStructure['postingDate'] = '';
    outputStructure['period'] = '';
    outputStructure['currency'] = 'THB';
    outputStructure['exchangeRate'] = '';
    outputStructure['translationDate'] = '';
    outputStructure['reference'] = '';
    outputStructure['documentHeaderText'] = '';
    outputStructure['refKeyHeader1'] = '';
    outputStructure['refKeyHeader2'] = '';
    outputStructure['branchNumber'] = '0000';
    outputStructure['extraBranchCode'] = '';
    outputStructure['extraTAXID'] = '';
    outputStructure['extraTEXT'] = '';
    outputStructure['reversalReasonAccrued'] = '';
    outputStructure['reversalDateAccrued'] = '';
    outputStructure['postingKey'] = '';
    outputStructure['accountSAP'] = '';
    outputStructure['specialGLIndicator'] = '';
    outputStructure['alternativeReconciliationAccount'] = '';
    outputStructure['taxBaseAmountDocumentCurrency'] = '';
    outputStructure['taxBaseAmountLocalCurrency'] = '';
    outputStructure['amtDocCurr'] = '';
    outputStructure['amtLocalCurr'] = '';
    outputStructure['taxAmount'] = '';
    outputStructure['autoCalVAT'] = '';
    outputStructure['taxCode'] = '';
    outputStructure['indicatorDetermineTaxBase'] = '';
    outputStructure['branchCode'] = '';
    outputStructure['termsPayment'] = '';
    outputStructure['baselineDateDueDateCalculation'] = '';
    outputStructure['paymentBlockKey'] = '';
    outputStructure['invRefDoc'] = '';
    outputStructure['invRefFiscalYear'] = '';
    outputStructure['invRefLineItem'] = '';
    outputStructure['paymentCurrency'] = '';
    outputStructure['paymentCurrencyAmount'] = '';
    outputStructure['paymentMethod'] = '';
    outputStructure['paymentReference'] = '';
    outputStructure['assignmentNumber'] = '';
    outputStructure['text'] = '';
    outputStructure['tradingPartner'] = '';
    outputStructure['refKeyLineItem1'] = '';
    outputStructure['refKeyLineItem2'] = '';
    outputStructure['refKeyLineItem3'] = '';
    outputStructure['valueDate'] = '';
    outputStructure['bankPartnerType'] = '';
    outputStructure['HouseBank'] = '';
    outputStructure['accountID'] = '';
    outputStructure['costCenter'] = '';
    outputStructure['order'] = '';
    outputStructure['profitCenter'] = '';
    outputStructure['wbsElement'] = '';
    outputStructure['earmarkFund'] = '';
    outputStructure['quantity'] = '';
    outputStructure['baseUnitMeasure'] = '';
    outputStructure['poNo'] = '';
    outputStructure['poItem'] = '';
    outputStructure['indicatorWithholdingTaxType1'] = '';
    outputStructure['withholdingTaxCode1'] = '';
    outputStructure['withholdingTaxBaseAmountDocumentCurrency1'] = '';
    outputStructure['enterWithholdingTaxAmountDocumentCurrencyManually1'] = '';
    outputStructure['indicatorWithholdingTaxType2'] = '';
    outputStructure['withholdingTaxCode2'] = '';
    outputStructure['withholdingTaxBaseAmountDocumentCurrency2'] = '';
    outputStructure['enterWithholdingTaxAmountDocumentCurrencyManually2'] = '';
    outputStructure['indicatorWithholdingTaxType3'] = '';
    outputStructure['withholdingTaxCode3'] = '';
    outputStructure['withholdingTaxBaseAmountDocumentCurrency3'] = '';
    outputStructure['enterWithholdingTaxAmountDocumentCurrencyManually3'] = '';
    outputStructure['payeePayerCode'] = '';
    outputStructure['individualPayeeDocument'] = '';
    outputStructure['name1'] = '';
    outputStructure['name2'] = '';
    outputStructure['name3'] = '';
    outputStructure['name4'] = '';
    outputStructure['street'] = '';
    outputStructure['city'] = '';
    outputStructure['postalCode'] = '';
    outputStructure['country'] = '';
    outputStructure['language'] = '';
    outputStructure['bankKey'] = '';
    outputStructure['bankAccount'] = '';
    outputStructure['bankCountry'] = '';
    outputStructure['taxNo3'] = '';
    outputStructure['taxNo5'] = '';
    outputStructure['typeBusiness'] = '';
    outputStructure['typeIndustry'] = '';
    outputStructure['longText1'] = '';
    outputStructure['longText2'] = '';
    outputStructure['longText3'] = '';
    outputStructure['longText4'] = '';
    outputStructure['longText5'] = '';
    return outputStructure;
}

exports.outputStructureOrder = () => {
    return [
    'separateIndicator',
    'documentDate',
    'documentType',
    'companyCode',
    'postingDate',
    'period',
    'currency',
    'exchangeRate',
    'translationDate',
    'reference',
    'documentHeaderText',
    'refKeyHeader1',
    'refKeyHeader2',
    'branchNumber',
    'extraBranchCode',
    'extraTAXID',
    'extraTEXT',
    'reversalReasonAccrued',
    'reversalDateAccrued',
    'postingKey',
    'accountSAP',
    'specialGLIndicator',
    'alternativeReconciliationAccount',
    'taxBaseAmountDocumentCurrency',
    'taxBaseAmountLocalCurrency',
    'amtDocCurr',
    'amtLocalCurr',
    'taxAmount',
    'autoCalVAT',
    'taxCode',
    'indicatorDetermineTaxBase',
    'branchCode',
    'termsPayment',
    'baselineDateDueDateCalculation',
    'paymentBlockKey',
    'invRefDoc',
    'invRefFiscalYear',
    'invRefLineItem',
    'paymentCurrency',
    'paymentCurrencyAmount',
    'paymentMethod',
    'paymentReference',
    'assignmentNumber',
    'text',
    'tradingPartner',
    'refKeyLineItem1',
    'refKeyLineItem2',
    'refKeyLineItem3',
    'valueDate',
    'bankPartnerType',
    'HouseBank',
    'accountID',
    'costCenter',
    'order',
    'profitCenter',
    'wbsElement',
    'earmarkFund',
    'quantity',
    'baseUnitMeasure',
    'poNo',
    'poItem',
    'indicatorWithholdingTaxType1',
    'withholdingTaxCode1',
    'withholdingTaxBaseAmountDocumentCurrency1',
    'enterWithholdingTaxAmountDocumentCurrencyManually1',
    'indicatorWithholdingTaxType2',
    'withholdingTaxCode2',
    'withholdingTaxBaseAmountDocumentCurrency2',
    'enterWithholdingTaxAmountDocumentCurrencyManually2',
    'indicatorWithholdingTaxType3',
    'withholdingTaxCode3',
    'withholdingTaxBaseAmountDocumentCurrency3',
    'enterWithholdingTaxAmountDocumentCurrencyManually3',
    'payeePayerCode',
    'individualPayeeDocument',
    'name1',
    'name2',
    'name3',
    'name4',
    'street',
    'city',
    'postalCode',
    'country',
    'language',
    'bankKey',
    'bankAccount',
    'bankCountry',
    'taxNo3',
    'taxNo5',
    'typeBusiness',
    'typeIndustry',
    'longText1',
    'longText2',
    'longText3',
    'longText4',
    'longText5'];
}

exports.titleGroup = () => {
    return ["documentDate", "documentType", "companyCode", "postingDate", "period", "currency", "refKeyHeader1", "branchNumber"];
}
[File Ends] outputstructure.js

[File Begins] serviceapi.js
const lodash = require("lodash");
const axios = require('axios');

const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const services = require("../../../../utils/interface/services");
const env = require('../../../../config/environment/environment').getConfig();
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const grantType = "client_credentials";
const pyPostingTriggeConnCode = "PYPOSTINGTRIGGER";
const pyPostingTokenRequestConnCode = "PYPOSTINGTOKENREQUES";
const headers = { "Content-Type": "application/x-www-form-urlencoded" };

class ServiceApi {

    constructor() {}


    async apiTokenRequest() {
        let functionReturn = new FunctionReturn();

        try {

            let serverConn = await services.getServerConnctionByConnCode(pyPostingTokenRequestConnCode);

            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let clientID = lodash.get(serverConn, 'result[0].username', '');
            let encryptClientSecret = lodash.get(serverConn, 'result[0].password', '');
            let host = lodash.get(serverConn, 'result[0].host', '');

            let encryptPath = env[reqContext.getTenantCode()].serverConnSecretKey;
            let clientSecret = helper.decrypt(encryptClientSecret, encryptPath);

            if (!clientSecret.success) {
                functionReturn = serverConn;
                return functionReturn;
            }

            let authParam = new URLSearchParams({
                grant_type: grantType,
                client_id: clientID,
                client_secret: lodash.get(clientSecret, 'result', ''),
            });

            try {
                
                let response = await axios.post(host, authParam, { headers: headers });
                functionReturn.result = lodash.get(response, 'data.access_token', '');
                
            } catch (error) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('tenant.assetwise.payrollPosting.error.apiTokenRequest')
                return functionReturn;
            }

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/serviceapi - apiTokenRequest', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');  
        }

        return functionReturn;
    }

    async submitApiTriggers(fileName) {

        let functionReturn = new FunctionReturn();

        try {

            let resultToken = await this.apiTokenRequest();

            if (!resultToken.success) {
                functionReturn = resultToken;
                return functionReturn;
            }

            let serverConn = await services.getServerConnctionByConnCode(pyPostingTriggeConnCode);
            
            if (!serverConn.success) {
                functionReturn = serverConn;
                return functionReturn;
            }
            
            try {
                
                let host = lodash.get(serverConn, 'result[0].host', '');
                let irpaApiKey = lodash.get(serverConn, 'result[0].username', '');
                let data = JSON.stringify({ input: { ipFileName: fileName } });
                let authorization = lodash.get(resultToken, 'result', '');
                  
                let config = {
                    method: 'post',
                    url: host,
                    headers: { 
                        'irpa-api-key': irpaApiKey,
                        'Authorization': `Bearer ${authorization}`, 
                        'Content-Type': 'application/json'
                    },
                    data : data
                };

                let response = await axios(config);
                let messageText = lodash.get(response, 'statusText', '');
                functionReturn.message = messageText;
                  
            } catch (error) {
                helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/serviceapi - submitApiTriggers', '', '', '', '');
                functionReturn.message = translation.getTranslateText('tenant.assetwise.payrollPosting.error.submitApiTriggers');
                functionReturn.success = false;
            }

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/serviceapi - submitApiTriggers', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');  
        }
        return functionReturn;
    }

}

exports.ServiceApi = ServiceApi;
[File Ends] serviceapi.js

[File Begins] util.js
const Sequelize = require('sequelize');
const moment = require("moment");
const fs = require("fs");
const lodash = require('lodash');

const outputStructure = require('./outputstructure');
const arrayUtil = require('../../../../utils/array');
const constant = require('../../../../config/constant');
const sh = require("../../../../utils/searchhelp");
const helper = require('../../../../utils/helper');
const jsonUtil = require('../../../../utils/json');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const reqContext = require('../../../../utils/requestcontext');
const services = require("../../../../utils/interface/services");
const itftemplate = require("../../../../utils/interface/dbprocess/itftemplate");
const userUtil = require('../../../../utils/user');
const documentManagers = require("../../../../utils/interface/document");
const textFile = require("../../../../utils/interface/exportfile/interfaceout/textfile");
const selectionUtil = require('../../../../utils/selection');
const env = require("../../../../config/environment/environment").getConfig();
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const Permission = require('../../../../utils/authorization/permission/permission').Permission;
const ServiceApi = require('./serviceapi').ServiceApi;
const DBProcess = require('./dbprocess');

const payrollType = {
    normal: "NORMAL",
    special: "SPECIAL"
};

const postingKeyType = {
    debit: '40',
    credit: '50'
}

const accountReClass = '5';

const roleAttributePYSpecial = "POSTING_PYTYPE_SPECIAL";
const interfaceType = 'PYPOSTING';
const separator = ",";
const contraAccountLabel = "Contra Acccount";
const numberRangePrefix = "IP-";
const numberRangeDetailNRCode = "POST";
const fileNamePrefix = "ZGLI001_";
const parameterName = "PY_ACCOUNT_POST";
const utf8WithBOMHeader = "\ufeff";

const Op = Sequelize.Op;

const PAYROLL_PERIOD_MONTHLY_CODE = "M01"
const accountGroupCodePrefix = 'BN';

class PayrollPostingProcessingUtil {

    constructor() {

    }

    async initPage() {

        let functionReturn = new FunctionReturn();

        try {

            functionReturn.result = {
                payrollAreaSH: await sh.getPayrollArea(),
            };

            let companyList = await sh.getCompany();
            let payrollPeriodList = await sh.getPayrollPeriodList();

            functionReturn.result.companySH = companyList;

            //Default com code
            functionReturn.result.comCode = [];

            // functionReturn.result.employeeSH = await sh.getAvailableEmpList();
            let paramSHEmp = {
                condition: {},
                checkPerAssign: true
            };
            functionReturn.result.employeeSH = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

            functionReturn.result.selectEmpType = "ALL";

            //Check permission
            let permsParam = {
                replaceEmptyList: false,
                checkObjectList: [
                    {
                        objectType: globalConstant.permissionObjectType.company,
                        objectList: functionReturn.result.companySH,
                        codeColumn: 'comCode'
                    },
                    {
                        objectType: globalConstant.permissionObjectType.employee,
                        objectList: functionReturn.result.employeeSH,
                        codeColumn: 'key'
                    },
                ]
            };

            let permission = new Permission();
            let permsReturn = await permission.checkObjectPermission(permsParam);
            if (permsReturn.success) {
                functionReturn.result.companySH = permsReturn.result.checkResult.companyList;
                functionReturn.result.employeeSH = permsReturn.result.checkResult.empList;
            } else {
                functionReturn.result.companySH = [];
                functionReturn.result.employeeSH = [];
            }

            //Check POSTING_PYTYPE_SPECIAL
            let specialOnly = false;
            const roleAttributes = await userUtil.getUserRoleAttribute({ username: await reqContext.getCurrentUsername() });
            specialOnly = roleAttributes.some((ra) => ra.attributeCode === roleAttributePYSpecial);

            functionReturn.result.specialOnly = specialOnly;

            if (functionReturn.result.specialOnly === true) {
                functionReturn.result.payrollType = payrollType.special;
            } else {
                functionReturn.result.payrollType = payrollType.normal;
            }

            functionReturn.result.putFileToSFTP = true;

            //Set default payroll period
            let payrollArea = functionReturn.result.payrollAreaSH[0].payrollAreaCode;

            // let currentPeriod = await this.getCurrentPeriodDetail({
            //     payrollAreaCode: payrollArea
            // });
            // let currentPeriodResult = currentPeriod.result;

            let pyPeriodCode;
            let pyPeriod = functionReturn.result.payrollAreaSH.find(elem => elem.payrollAreaCode == payrollArea)
            if (!jsonUtil.isEmpty(pyPeriod)) {
                pyPeriodCode = pyPeriod.payrollPeriodCode;
            }
            let payrollPeriod = payrollPeriodList.find(elem =>
                elem.payrollPeriodCode === pyPeriodCode &&
                // elem.startDate <= new Date() &&
                // elem.endDate >= new Date() &&
                elem.payrollArea === payrollArea
            );


            const currentDate = moment();

            const currentMonth = currentDate.format('M');
            const currentYear = currentDate.format('YYYY');

            if (!jsonUtil.isEmpty(payrollPeriod)) {
                // functionReturn.result.payrollPeriodCode = pyPeriodCode
                functionReturn.result.paymentDate = payrollPeriod.paymentDate;
                // functionReturn.result.payrollArea = [payrollArea];
                functionReturn.result.payrollPeriod = currentMonth;
                functionReturn.result.payrollYear = currentYear;
                // functionReturn.result.payrollPeriod = payrollPeriod.period;
                // functionReturn.result.payrollYear = payrollPeriod.year;
                // functionReturn.result.payrollPeriod = currentPeriodResult.currentPeriod;
                // functionReturn.result.payrollYear = currentPeriodResult.currentYear;
            }

            if (functionReturn.result) {
                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("common.error.exception");
            }

        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/main - initPage', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }

        return functionReturn;
    }

    async onCompanyChange(param) {
        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {
            let comCode = lodash.get(param, 'params.company.comCode', '');
            let condition = { comCode: comCode };
            let pyPeriodCondition = {
                period: lodash.get(param, 'params.payrollPeriod', ''),
                year: lodash.get(param, 'params.payrollYear', '')
            }
            let periodResult = await dbProcess.getPayrollPeriod(pyPeriodCondition);
            let pyWPBP = await dbProcess.getAllPYWPBP(condition);
            let storePeriodResult = [];
            for (const periodItem of periodResult) {
                if (pyWPBP.length > 0) pyWPBP = lodash.uniqBy(pyWPBP, (val) => val.payrollAreaCode);
                let item = lodash.find(pyWPBP, (val) => val.payrollAreaCode === periodItem.payrollAreaCode);
                if (!lodash.isEmpty(item)) storePeriodResult.push(periodItem);
            }

            functionReturn.result = storePeriodResult;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/util onCompanyChange', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async onInputChange(param) {
        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {
            let params = lodash.get(param, 'params', '');
            let payrollAreaList = lodash.get(params, 'payrollAreaCodeList', []);
            let payrollPeriodSelection = lodash.get(params, 'payrollPeriod', '');
            let payrollYear = lodash.get(params, 'payrollYear', '');

            if (lodash.isEmpty(payrollAreaList)) return functionReturn;

            let monthlyCode = lodash.find(payrollAreaList, (val) => val.payrollPeriodCode === PAYROLL_PERIOD_MONTHLY_CODE);
            let payrollPeriodCode = "";
            let payrollAreaCode = "";
            if (!lodash.isEmpty(monthlyCode)) {
                payrollPeriodCode = lodash.get(monthlyCode, 'payrollPeriodCode', '');
                payrollAreaCode = lodash.get(monthlyCode, 'payrollAreaCode', '');
            } else {
                payrollPeriodCode = lodash.get(payrollAreaList, '[0].payrollPeriodCode', '');
                payrollAreaCode = lodash.get(payrollAreaList, '[0].payrollAreaCode', '');
            }

            let condition = {
                payrollPeriodCode: payrollPeriodCode,
                period: payrollPeriodSelection,
                year: payrollYear,
                payrollAreaCode: payrollAreaCode
            }

            let payrollPeriodResult = await dbProcess.getOnePayrollPeriod(condition);
            functionReturn.result = payrollPeriodResult;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/util onInputChange', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async uploadFileToSFTP(outputPath, fileName) {
        let functionReturn = new FunctionReturn();
        try {

            const sftpConfig = await services.getSFTPConnectorConfig(interfaceType);

            let outputFilePath = "";
            let pathFile = "";
            let connConfig = "";

            if (sftpConfig.success) {
                outputFilePath = lodash.get(sftpConfig, "result[0].connConfig.outputPath", "");
                pathFile = `${outputFilePath}/${fileName}`;
                connConfig = lodash.get(sftpConfig, "result[0].connConfig", "");
            }

            const uploadFileParam = { outputPath, pathFile, connConfig };
            const response = await documentManagers.uploadFile(uploadFileParam);
            functionReturn = response;
        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/util uploadFileToSFTP', '', 'user', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }
        return functionReturn;
    }

    async execute(param) {

        let functionReturn = new FunctionReturn();
        let serviceApi = new ServiceApi();

        try {

            let bgProcess = param.bgProcess;
            let res = param.res;
            let putFileToSFTP = lodash.get(param, 'selection.putFileToSFTP', true);

            functionReturn = await this.validateSelection(param);
            if (functionReturn.success) {

                let keyDate = functionReturn.result.keyDate;

                functionReturn = await this.getResultPosting(param, keyDate);
                if (!functionReturn.success) {
                    bgProcess.handleError(functionReturn, res);
                    return functionReturn;
                }

                let resultData = functionReturn.result;
                let dateFormat = moment().format('YYYYMMDD');
                let timeFormat = moment().format('HHMMSS');
                let fileName = ``;

                const getConfigDecryptDoc = await itftemplate.getInterfaceTemplateByInterfaceType(interfaceType);
                const encryption = lodash.get(getConfigDecryptDoc, 'encryption', '');

                if (encryption === 'pgp') {
                    fileName = `${fileNamePrefix}${dateFormat}_${timeFormat}.csv.pgp`;
                } else {
                    fileName = `${fileNamePrefix}${dateFormat}_${timeFormat}.csv`;
                }

                let outputPath = env[reqContext.getTenantCode()].bgFileDocumentPath + fileName;

                const csvConfig = {
                    fileName,
                    header: await textFile.generateHeader(interfaceType, separator),
                    detailList: resultData,
                    bgProcess,
                };

                const workbook = await textFile.main(csvConfig, separator);

                if (encryption === 'pgp') {
                    let encryptPayload = documentManager.encryptDocument(workbook.result.content, getConfigDecryptDoc);
                    let encryptResult = await encryptPayload;
                    fs.writeFileSync(outputPath, `${utf8WithBOMHeader}${encryptResult}`, "utf8");
                } else {
                    fs.writeFileSync(outputPath, `${utf8WithBOMHeader}${workbook.result.content}`, "utf8");
                }

                if (putFileToSFTP) {
                    let uploadFileResponse = await this.uploadFileToSFTP(outputPath, fileName);
                    if (!uploadFileResponse.success) {
                        functionReturn = uploadFileResponse;
                        await bgProcess.handleOutputMessage(functionReturn, res);
                        return;
                    }

                    let triggerApiResponse = await serviceApi.submitApiTriggers(fileName);

                    if (!triggerApiResponse.success) {
                        functionReturn = triggerApiResponse;
                        await bgProcess.handleOutputMessage(functionReturn, res);
                        return;
                    }
                }

                let result = fs.readFileSync(outputPath, { encoding: 'utf8' });
                await bgProcess.handleOutputFile(result, fileName, 'text/csv', res, null);
                return;
            }

            functionReturn.clear();
            functionReturn.success = true;
            await bgProcess.handleOutputMessage(functionReturn, res);

        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/util - execute', '', 'user', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("common.error.exception");
            bgProcess.handleError(functionReturn, res);
        }

        return functionReturn;
    }

    async validateSelection(param) {

        let functionReturn = new FunctionReturn();

        try {
            let selection = param.selection;
            let bgProcess = param.bgProcess;
            let res = param.res;
            let payrollArea;
            let payrollPeriod;
            let keyDate;

            //Check permission
            functionReturn.clear();
            functionReturn = await this.adjustSelection(selection);
            if (!functionReturn.success) {
                bgProcess.handleError(functionReturn, res);
                return;
            }
            functionReturn.clear();

            //Validate payroll area input
            functionReturn = await this.validatePayrollArea(selection.payrollArea);
            if (functionReturn.success) {
                payrollArea = functionReturn.result;
                functionReturn.clear();

                if (selection.payrollType === payrollType.normal) {
                    //Validate payroll period and payment date
                    functionReturn = await this.validatePayrollPeriod(selection, payrollArea);
                    if (functionReturn.success) {
                        payrollPeriod = functionReturn.result;
                        keyDate = payrollPeriod[0].paymentDate;
                        functionReturn.clear();
                    } else {
                        bgProcess.handleError(functionReturn, res);
                        return;
                    }
                } else {
                    keyDate = new Date(selection.paymentDate);
                    let getPayrollAreaCodeList = lodash.map(payrollArea, (o) => o.payrollAreaCode);

                    // if (keyDate != 'Invalid Date') {
                    if (keyDate instanceof Date) {
                        payrollPeriod = {
                            year: keyDate.getFullYear(),
                            period: 0,
                            paymentDate: keyDate,
                            payrollAreaCode: getPayrollAreaCodeList
                        };
                    } else {
                        functionReturn.success = false;
                        functionReturn.message = translation.getTranslateText('common.error.invalidPaymentDate'); //'Invalid payment date'
                        bgProcess.handleError(functionReturn, res);
                        return
                    }
                }
            } else {
                bgProcess.handleError(functionReturn, res);
                return;
            }

            functionReturn.success = true;
            functionReturn.result.keyDate = keyDate;
        } catch (error) {
            helper.logMessage('error', error, 'tenant/assetwise/payrollposting/util - validateSelection', '', 'user', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("common.error.exception");
        }

        return functionReturn;

    }

    async adjustSelection(selection) {

        let functionReturn = new FunctionReturn();

        try {

            let permsParam = {
                replaceEmptyList: true,
                checkObjectList: [{
                    objectType: globalConstant.permissionObjectType.company,
                    objectList: selection.comCode
                },
                {
                    objectType: globalConstant.permissionObjectType.employee,
                    objectList: selection.empCodeList
                }]
            }

            let permission = new Permission();
            let permsReturn = await permission.checkObjectPermission(permsParam);
            if (permsReturn.success) {
                if (!arrayUtil.isEmpty(permsReturn.result.checkResult.companyList)) {
                    selection.comCode = permsReturn.result.checkResult.companyList;
                } else {
                    selection.comCode = [];
                }

                if (!arrayUtil.isEmpty(permsReturn.result.checkResult.empList)) {
                    selection.empCodeList = permsReturn.result.checkResult.empList;
                } else {
                    selection.empCodeList = [];
                }

                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = permsReturn.message;
            }
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - adjustSelection', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;

    }

    async validatePayrollArea(payrollArea) {

        let functionReturn = new FunctionReturn();
        let condition = {};

        try {

            //Check if payroll area is enter
            if (!payrollArea) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("common.error.pleaseEnterPayrollGroup"); //'Please enter Payroll Group'
            } else {

                //Set where condition for payroll area
                condition = {
                    payrollAreaCode: payrollArea
                };

                //Check if payroll area is valid
                functionReturn.result = await sh.getPayrollArea(condition);
                if (!arrayUtil.isEmpty(functionReturn.result)) {
                    functionReturn.success = true;
                } else {
                    functionReturn.success = false
                    functionReturn.message = translation.getTranslateText("common.error.noPayrollGroupFound"); //'No Payroll Group found'
                }

            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - validatePayrollArea', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;

    }

    async validatePayrollPeriod(selection, payrollPeriodCode) {

        let functionReturn = new FunctionReturn();
        const dbProcess = new DBProcess();
        let payrollPeriod = 1;
        let payrollYear = 1;
        let paymentDate = '';
        let condition = {};

        try {

            //Validate payroll month
            if (!selection.payrollPeriod) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.enterPayrollMonth");    //'Please enter Payroll Month'
                return functionReturn;
            }

            payrollPeriod = payrollPeriod * selection.payrollPeriod;

            if (isNaN(payrollPeriod)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.invalidPayrollMonth");    //'Invalid Payroll Month'
                return functionReturn;
            }

            //Validate payroll year
            if (!selection.payrollYear) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.enterPayrollYear");  //'Please enter Payroll Year'
                return functionReturn;
            }

            payrollYear = payrollYear * selection.payrollYear

            if (isNaN(payrollYear)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.invalidPayrollYear"); //'Invalid Payroll Year'
                return functionReturn;
            }

            let payrollPeriodCodeList = [];
            if (payrollPeriodCode.length > 0) {
                payrollPeriodCodeList = lodash.map(payrollPeriodCode, (o) => lodash.get(o, "payrollPeriodCode", ""));
                payrollPeriodCodeList = lodash.uniq(payrollPeriodCodeList);
            }

            //Set where condition for normal period
            condition = {
                payrollPeriodCode: {
                    [Op.in]: payrollPeriodCodeList,
                },
                period: payrollPeriod,
                year: payrollYear,
                payrollAreaCode: selection.payrollArea
            }

            if (selection.paymentDate !== null && selection.paymentDate !== '') {
                paymentDate = new Date(selection.paymentDate)
                if (paymentDate !== 'Invalid Date') {
                    condition.paymentDate = paymentDate;
                }
            }

            functionReturn.result = await dbProcess.getPayrollPeriod(condition);
            if (functionReturn.result) {
                functionReturn.success = true;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.invalidPayrollPeriod");   //'Invalid Payroll Period'
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - validatePayrollPeriod', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;

    }

    adjustRTRecWT(paramRTRec) {

        let rtList = paramRTRec.rtList;
        let wageTypeList = paramRTRec.wageTypeList;

        for (let wageType of wageTypeList) {
            let recList = rtList.filter(elem => elem.wtCode === wageType.recWTCode);
            if (!arrayUtil.isEmpty(recList)) {
                for (let rec of recList) {
                    let indexRec = rtList.findIndex(elem => elem.wtCode === wageType.recWTCode && elem.rgdirID === rec.rgdirID);
                    let index = rtList.findIndex(elem => elem.wtCode === wageType.wtCode && elem.rgdirID === rec.rgdirID);
                    if (index >= 0 && indexRec >= 0) {
                        rtList[index].amount = rtList[index].amount + rtList[indexRec].amount;
                        rtList.splice(indexRec, 1);
                    }
                }

            }
        }
        return rtList;
    }

    searchPYAccountEmpGrpDetail(pyAccEmpGrpDetail, comCode, empGroupCode) {

        let accEmpGrp = [];
        for (let pyAccEmpGrp of pyAccEmpGrpDetail) {
            let comCodeList = pyAccEmpGrp.comCode;
            let empGroupList = pyAccEmpGrp.empGroupCode;

            //Find comCode
            let comCodeResult = comCodeList.find(elem => elem === comCode);
            if (jsonUtil.isEmpty(comCodeResult)) {
                continue;
            }

            //Find empGroupCode
            let empGroupCodeResult = empGroupList.find(elem => elem === empGroupCode);
            if (jsonUtil.isEmpty(empGroupCodeResult) && empGroupList.length !== 0) {
                continue;
            }

            accEmpGrp.push(pyAccEmpGrp.accEmpGroupCode);
            // break;
        }

        return accEmpGrp;
    }

    async getPYAccountEmpGroupingDetail() {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let pyAccEmpGrpDetailList = await dbProcess.getPYAccountEmpGroupingDetail({});
            if (!jsonUtil.isEmpty(pyAccEmpGrpDetailList)) {

                for (let pyAccEmpGrpDetail of pyAccEmpGrpDetailList) {
                    let objDetail = JSON.parse(pyAccEmpGrpDetail.accEmpGroupDetail);
                    if (!jsonUtil.isEmpty(objDetail)) {
                        pyAccEmpGrpDetail.positionList = lodash.get(objDetail, 'positionList', []);
                        pyAccEmpGrpDetail.incSubOrg = objDetail.incSubOrg;
                        pyAccEmpGrpDetail.comCode = objDetail.companyList;
                        pyAccEmpGrpDetail.persAreaCode = objDetail.persAreaList;
                        pyAccEmpGrpDetail.persSubAreaCode = objDetail.persSubAreaList;
                        pyAccEmpGrpDetail.empGroupCode = objDetail.empGroupList;
                        pyAccEmpGrpDetail.empSubGroupCode = objDetail.empSubGroupList;
                        pyAccEmpGrpDetail.payrollAreaCode = objDetail.payrollAreaList;
                        pyAccEmpGrpDetail.orgCode = objDetail.orgList;
                        pyAccEmpGrpDetail.incEmpCode = objDetail.incEmpList;
                        pyAccEmpGrpDetail.excEmpCode = objDetail.excEmpList;
                    }
                }

                functionReturn.success = true;
                functionReturn.result = pyAccEmpGrpDetailList;
            }

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - getPYAccountEmpGroupingDetail', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async getEmployeeData(payrollDirectoryList, keyDate, selection) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let empList = [];
        let condition = {};
        let comCode = selection.comCode;

        try {

            //Get employee list from the payroll directory
            for (let payrollDirectory of payrollDirectoryList) {
                empList.push(payrollDirectory.empCode);
            }

            let storeKeyDateParam = [];
            let storeKeyDateConditon = {};
            if (lodash.isArray(keyDate)) {
                for (const keyItem of keyDate) {
                    const getEndDate = lodash.get(keyItem, "endDate", "");
                    let keyDateParam = {
                        startDate: {
                            [Op.lte]: getEndDate,
                        },
                        endDate: {
                            [Op.gte]: getEndDate,
                        },
                    };
                    storeKeyDateParam.push(keyDateParam);
                }
                storeKeyDateConditon = {
                    [Op.or]: storeKeyDateParam
                }
            } else {
                storeKeyDateConditon = {
                    startDate: {
                        [Op.lte]: keyDate
                    },
                    endDate: {
                        [Op.gte]: keyDate
                    }
                }
            }

            //Set condition for PersonalData, PersonalAssignment, BasicPay, PersonalBank
            condition = {
                personalDataCondition: {
                    empCode: empList,
                    ...storeKeyDateConditon,
                },
                personalAssignmentCondition: {
                    ...storeKeyDateConditon,
                    empCode: empList,
                },
            }

            if (comCode) {
                condition.personalAssignmentCondition.comCode = comCode
            }

            functionReturn.result = await dbProcess.getEmployeeData(condition);
            if (!arrayUtil.isEmpty(functionReturn.result)) {
                functionReturn.success = true
                empList = functionReturn.result;
            } else {
                functionReturn.success = false
                functionReturn.message = translation.getTranslateText("common.error.noEmployeeDataFound");  //'No Employee Data found'
                return functionReturn;
            }

            functionReturn.result = empList;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - getEmployeeData', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    clone(src) {
        return Object.assign({}, src)
    }

    async getPayrollResult(selection, keyDate) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let condition = {};
        let rgdirIdList = [];
        let payrollDirectoryList = [];
        let payrollDirectoryListTmp = [];
        let rtList = [];
        let rtRetroList = [];
        let pyAccountMapping = [];
        let pyAccount = [];
        let pyAccountDetail = [];
        let pyCostDistribution = [];
        let pyWPBP = [];
        let wageTypeList = [];
        let pyRetroPayrollDirectoryList = [];
        let rgdirIdRetroList = [];
        let pyAddtionAccountMapping = [];
        let pyCostAssignment = [];

        try {

            let comCode = selection.comCode;

            //Set condition for payroll result directory
            condition.payrollAreaCode = selection.payrollArea;

            if (!arrayUtil.isEmpty(selection.empCodeList)) {
                condition.empCode = selection.empCodeList;
            }

            //Key date condition
            if (selection.payrollType === payrollType.normal) {
                condition.inPeriod = selection.payrollPeriod;
                condition.inYear = selection.payrollYear;
            } else {
                condition.startDate = {
                    [Op.gte]: keyDate
                };
                condition.endDate = {
                    [Op.lte]: keyDate
                };
                condition.payType = constant.pyOffCycle;
            }

            condition.payrollProcessingID = {
                [Sequelize.Op.not]: 0
            };

            //Get payroll result directory
            payrollDirectoryListTmp = await dbProcess.getPayrollDirectory(condition);
            if (arrayUtil.isEmpty(payrollDirectoryListTmp)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.noPyResultDirectoryFound");   //'No Payroll Result Directory found'
                return functionReturn;
            }

            //Get rgdit id list from payroll directory
            for (let rgdir of payrollDirectoryListTmp) {
                //Collect retro record
                if (rgdir.forPeriod !== rgdir.inPeriod || ((rgdir.forPeriod === rgdir.inPeriod) && (rgdir.forYear < rgdir.inYear))) {
                    pyRetroPayrollDirectoryList.push(rgdir);
                    rgdirIdRetroList.push(rgdir.id);
                } else {
                    payrollDirectoryList.push(rgdir);
                    rgdirIdList.push(rgdir.id);
                }
            }

            condition = {
                rgdirID: rgdirIdList
            };

            //Get payroll result from payroll directory and wagetype mapping
            rtList = await dbProcess.getRT(condition);

            if (arrayUtil.isEmpty(rtList)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.noPyResultFound");  //'No Payroll Result found'
                return functionReturn;
            }

            if (rgdirIdRetroList.length > 0) {
                //Get non deduction wage type
                let conditionRTRetro = {
                    rtCondition: {
                        rgdirID: rgdirIdRetroList,
                        wtCode: {
                            [Op.notLike]: 'T%'
                        }
                    },
                    wageTypeCondition: {
                        incomeCode: {
                            [Op.not]: globalConstant.deductionIncomeType
                        }
                    }
                };

                rtRetroList = await dbProcess.getRTRetroWT(conditionRTRetro);
            }

            //Get PYCostAssignment
            pyCostAssignment = await dbProcess.getPYCostAssignment(condition);

            //Get PYCostDistribution
            pyCostDistribution = await dbProcess.getPYCostDistribution(condition);

            //Get PYPYWPBP
            pyWPBP = await dbProcess.getPYWPBP(condition);

            let wtCodeList = [];

            let storeKeyDateConditon = {
                startDate: {
                    [Op.lte]: keyDate
                },
                endDate: {
                    [Op.gte]: keyDate
                }
            }

            //Collect RT list
            for (let rt of rtList) {
                wtCodeList.push(rt.wtCode);
            }

            //Get PYAccountMapping
            let conditionPYWtWithDate = {
                wtCode: wtCodeList,
                ...storeKeyDateConditon,
            };

            pyAccountMapping = await dbProcess.getPYAccountMapping(conditionPYWtWithDate);

            //Get Wage Type
            let conditionWageType = {
                wtCode: wtCodeList,
                recWTCode: {
                    [Op.not]: ''
                },
                ...storeKeyDateConditon,
            };
            wageTypeList = await dbProcess.getWageType(conditionWageType);

            //Adjust RT amount with recovery wage type
            let paramRTRec = {
                rtList: rtList,
                wageTypeList: wageTypeList
            };
            rtList = this.adjustRTRecWT(paramRTRec);

            let paramRTRetroRec = {
                rtList: rtRetroList,
                wageTypeList: wageTypeList
            };
            rtRetroList = this.adjustRTRecWT(paramRTRetroRec);

            //Get PYAccountDetail
            let conditionPYAccDetail = {
                ...storeKeyDateConditon,
            };

            if (comCode) {
                conditionPYAccDetail.company = comCode;
                conditionPYAccDetail.accountGroupCode = { [Op.notLike]: `%${accountGroupCodePrefix}%` }
            }

            pyAccountDetail = await dbProcess.getPYAccountDetail(conditionPYAccDetail);

            //Collect accountCode
            let accountCodeList = [];
            for (let pyAccDet of pyAccountDetail) {

                if (pyAccDet.credit) {
                    accountCodeList.push(pyAccDet.credit);
                }

                if (pyAccDet.debit) {
                    accountCodeList.push(pyAccDet.debit);
                }
            }

            //Get PYAccount
            let conditionPYAccount = {
                accountCode: accountCodeList,
                ...storeKeyDateConditon,
            };

            pyAccount = await dbProcess.getPYAccount(conditionPYAccount);

            // GET Retro

            if (pyRetroPayrollDirectoryList.length > 0) {
                for (let retroPayDirect of pyRetroPayrollDirectoryList) {
                    //Find current RT
                    // let rtCurrent = rtList.filter(elem => elem.rgdirID === pyRetroPayrollDirectoryList[pyDirIndex].id)

                    //Read retro RT
                    let retroRT = rtRetroList.filter(elem => elem.rgdirID === retroPayDirect.id);

                    //Read origin period
                    let conditionOrigin = {
                        forPeriod: retroPayDirect.forPeriod,
                        forYear: retroPayDirect.forYear,
                        payType: constant.pyNormalCycle,
                        payrollAreaCode: selection.payrollArea,
                        empCode: retroPayDirect.empCode,
                        seqNo: { [Op.lt]: retroPayDirect.seqNo },
                        resultIndicator: { [Op.ne]: constant.pyResultDirResultIndicatorOthers },            //CR001204 INS
                    };

                    let sumOriginRT = {};
                    let pyOriginDirectory = await dbProcess.getRecordPayrollDirectory(conditionOrigin)
                    if (!arrayUtil.isEmpty(pyOriginDirectory)) {
                        for (let pyOrigin of pyOriginDirectory) {
                            // Get RT (Original Period)
                            let condOriginRT = {
                                rtCondition: {
                                    rgdirID: pyOrigin.id,
                                    wtCode: {
                                        [Op.notLike]: 'T%'
                                    }
                                },
                                wageTypeCondition: {
                                    incomeCode: {
                                        [Op.not]: globalConstant.deductionIncomeType
                                    }
                                }
                            };

                            //Calculate retro amount
                            let rtOriginalPeriodList = await dbProcess.getRTRetroWT(condOriginRT)
                            if (!arrayUtil.isEmpty(rtOriginalPeriodList)) {
                                //Sum total origin amount
                                for (let rtOriginal of rtOriginalPeriodList) {
                                    if (!sumOriginRT[rtOriginal.wtCode]) {
                                        sumOriginRT[rtOriginal.wtCode] = {};
                                        sumOriginRT[rtOriginal.wtCode].amount = 0;
                                    }
                                    // sumOriginRT[rtOriginal.wtCode] = sumOriginRT[rtOriginal.wtCode] + rtOriginal.amount;

                                    sumOriginRT[rtOriginal.wtCode].rgdirID = rtOriginal.rgdirID;
                                    sumOriginRT[rtOriginal.wtCode].wtCode = rtOriginal.wtCode;
                                    sumOriginRT[rtOriginal.wtCode].quantity = rtOriginal.quantity;
                                    sumOriginRT[rtOriginal.wtCode].rate = rtOriginal.rate;

                                    sumOriginRT[rtOriginal.wtCode].amount = sumOriginRT[rtOriginal.wtCode].amount + rtOriginal.amount;
                                }
                            }
                        }
                    }

                    //Find current pyDirectory
                    let pyDirIndex = payrollDirectoryList.findIndex(elem => elem.inPeriod === retroPayDirect.inPeriod &&
                        elem.empCode === retroPayDirect.empCode &&
                        elem.inYear === retroPayDirect.inYear);
                    // if(pyDirIndex >= 0) {
                    //Loop cal adjust with retro RT
                    let sumRetroRT = {};
                    for (let retroRTRow of retroRT) {
                        if (!sumRetroRT[retroRTRow.wtCode]) {
                            sumRetroRT[retroRTRow.wtCode] = {};
                            sumRetroRT[retroRTRow.wtCode].amount = 0;
                            sumRetroRT[retroRTRow.wtCode].data = {};
                        }

                        sumRetroRT[retroRTRow.wtCode].amount = sumRetroRT[retroRTRow.wtCode].amount + retroRTRow.amount;
                        retroRTRow.amount = sumRetroRT[retroRTRow.wtCode].amount;
                        sumRetroRT[retroRTRow.wtCode].data = retroRTRow;
                    }

                    let addtionalOriginWtCode = [];

                    //Find RT wtCode in origin where not exist in retro and build retro wtCode
                    for (let originRTKey in sumOriginRT) {
                        if (jsonUtil.isEmpty(sumRetroRT[originRTKey]) && sumOriginRT[originRTKey].amount !== 0) {
                            sumRetroRT[originRTKey] = {};

                            //Copy data from retro other row
                            sumRetroRT[originRTKey].data = this.clone(sumOriginRT[originRTKey]);
                            sumRetroRT[originRTKey].data.rgdirID = (retroRT[0]) ? retroRT[0].rgdirID : sumRetroRT[originRTKey].data.rgdirID;
                            sumRetroRT[originRTKey].data.amount = 0;
                            sumRetroRT[originRTKey].amount = 0;

                            //Collect additional wtCode
                            addtionalOriginWtCode.push(originRTKey);
                        }
                    }

                    let collectRetroRgdir = [];
                    for (let wtRetroRT in sumRetroRT) {
                        let rtOrigin = (sumOriginRT[wtRetroRT]) ? sumOriginRT[wtRetroRT].amount : 0;
                        let adjAmount = sumRetroRT[wtRetroRT].amount - rtOrigin;

                        if (pyDirIndex >= 0) {
                            let rtCurrentIndex = rtList.findIndex(elem => elem.wtCode === wtRetroRT &&
                                elem.rgdirID === payrollDirectoryList[pyDirIndex].id)
                            if (rtCurrentIndex >= 0) {
                                rtList[rtCurrentIndex].amount = rtList[rtCurrentIndex].amount + adjAmount;
                            } else {
                                sumRetroRT[wtRetroRT].data.amount = adjAmount;
                                rtList.push(sumRetroRT[wtRetroRT].data);

                                //Find payroll directory rgdir exist
                                let indexDir = payrollDirectoryList.findIndex(elem => elem.id === sumRetroRT[wtRetroRT].data.rgdirID);
                                if (indexDir < 0) {

                                    //Find current payment date
                                    let payrollDirectoryEmpList = payrollDirectoryList.filter(elem => elem.empCode === retroPayDirect.empCode);
                                    if (!arrayUtil.isEmpty(payrollDirectoryEmpList)) {
                                        for (let pyDirEmp of payrollDirectoryEmpList) {
                                            if ((pyDirEmp.forPeriod == pyDirEmp.inPeriod) && (pyDirEmp.forYear === pyDirEmp.inYear)) {
                                                let newRetroPayDirect = this.clone(retroPayDirect);
                                                newRetroPayDirect.paymentDate = pyDirEmp.paymentDate;
                                                newRetroPayDirect.rgdirIDNew = pyDirEmp.id;
                                                payrollDirectoryList.push(newRetroPayDirect);

                                                collectRetroRgdir.push(newRetroPayDirect.id);
                                            }
                                        }

                                    }
                                }
                            }
                        } else {
                            sumRetroRT[wtRetroRT].data.amount = adjAmount;
                            rtList.push(sumRetroRT[wtRetroRT].data);
                        }
                    }

                    //Get more additional mapping and wage type data
                    //Get PYAccountMapping
                    let conditionAddPYWtWithDate = {
                        wtCode: addtionalOriginWtCode,
                        ...storeKeyDateConditon,
                    };
                    pyAddtionAccountMapping = await dbProcess.getPYAccountMapping(conditionAddPYWtWithDate);

                    // //Get Wage Type
                    // let conditionAddWageType = {
                    //     wtCode: addtionalOriginWtCode,
                    //     recWTCode: {
                    //         [Op.not]: ''
                    //     },
                    //     ...storeKeyDateConditon,
                    // };
                    // wageTypeAddtionList = await dbProcess.getWageType(conditionAddWageType);
                    // let conditionPYCostDist = {
                    //     rgdirID: collectRetroRgdir,
                    // };
                    // pyAdditionCostDistribution = await dbProcess.getPYCostDistribution(conditionPYCostDist);

                    pyAccountMapping = pyAccountMapping.concat(pyAddtionAccountMapping);
                    // pyCostDistribution = pyCostDistribution.concat(pyAdditionCostDistribution);

                }
            }

            functionReturn.result.payrollDirectoryList = payrollDirectoryList;
            functionReturn.result.rtList = rtList;
            functionReturn.result.pyAccount = pyAccount;
            functionReturn.result.pyAccountDetail = pyAccountDetail;
            functionReturn.result.pyAccountMapping = pyAccountMapping;
            functionReturn.result.pyCostDistribution = pyCostDistribution;
            functionReturn.result.pyWPBP = pyWPBP;
            functionReturn.result.pyCostAssignment = pyCostAssignment;
            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - getPayrollResult', '', '', '', '')
            functionReturn.success = false
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    sumAmountGroupByAccGroupCode(param = []) {
        let sumNormalPostingResultAmount = [];
        try {
            if (param.length < 1) return param;
            let accGroupGrouping = lodash.groupBy(param, (val) => {
                let debitCreditValue = lodash.get(val, 'debitChargeExpenseCode', '') || lodash.get(val, 'creditChargeExpenseCode', '');
                return `${val.accountGroupCode}-${debitCreditValue}-${val.orderNumber}`
            });
            sumNormalPostingResultAmount = lodash.map(accGroupGrouping, (val) => {
                const reduceAmount = lodash.reduce(val, (sum, n) => {
                    return { ...n, amount: Number(sum.amount) + Number(n.amount) };
                }, { amount: 0 });
                return reduceAmount;
            });
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - sumAmountGroupByAccGroupCode', '', '', '', '');
            return param;
        }
        return sumNormalPostingResultAmount;
    }

    sumAmountGroupByAccGroupCodeRgdirID(param = []) {
        let sumNormalPostingResultAmount = [];
        try {
            if (param.length < 1) return param;
            let accGroupGrouping = lodash.groupBy(param, (val) => `${val.accountGroupCode}${val.rgdirID}`);
            sumNormalPostingResultAmount = lodash.map(accGroupGrouping, (val) => {
                const reduceAmount = lodash.reduce(val, (sum, n) => {
                    return { ...n, amount: Number(sum.amount) + Number(n.amount) };
                }, { amount: 0 });
                return reduceAmount;
            });
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - sumAmountGroupByAccGroupCodeRgdirID', '', '', '', '');
            return param;
        }
        return sumNormalPostingResultAmount;
    }

    async numberRangeManagers() {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();
        let transaction = null;

        try {

            let currentYear = moment().format('YYYY');
            let condition = { year: currentYear, nrCode: numberRangeDetailNRCode };
            let numberRangResult = await dbProcess.getNumberRangeDetail(condition);

            if (lodash.isEmpty(numberRangResult)) {
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.noNumberRangeDetail");
                return functionReturn;
            }

            let currentNumber = lodash.get(numberRangResult, 'currentNumber', 0) || 0;
            let fromNumber = lodash.get(numberRangResult, 'fromNumber', 0) || 0;
            transaction = await services.getTransaction();

            if (currentNumber === 0) {
                currentNumber = fromNumber += 1;
            } else {
                currentNumber += 1;
            }

            let runningNumber = currentNumber.toString().padStart(6, '0');
            functionReturn.result = `${numberRangePrefix}${currentYear}${runningNumber}`;

            // update currentNumber
            let updateData = { ...numberRangResult, currentNumber: currentNumber };
            let updateCondition = {
                id: lodash.get(numberRangResult, 'id', ''),
                recordKey: lodash.get(numberRangResult, 'recordKey', '')
            };

            await dbProcess.updateNumberRangeDetail(updateData, updateCondition, transaction);
            await transaction.commit();

            functionReturn.success = true;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - numberRangeManagers', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.readData");
        } finally {
            if (transaction) {
                if (!transaction.finished) {
                    await transaction.rollback();
                }
            }
        }
        return functionReturn;
    }

    async getResultPosting(param, keyDate) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let selection = param.selection;
            let bgProcess = param.bgProcess;
            let res = param.res;
            let rtList = [];
            let pyAccountList = [];
            let pyAccountDetailList = [];
            let pyAccountMappingList = [];
            let pyCostDistributionList = [];
            let pyWPBPList = [];
            let payrollDirectoryList = [];
            let pyAccountEmpGroupingDetailList = [];
            let countProgress = 0;
            let outputResultFormat = [];
            let totalDatabase = 8;
            let outputStructureResult = outputStructure.createOutputStructure();
            let normalPostingResult = [];
            let reClassPostingDefaultResult = [];
            let reClassPostingResult = [];
            let reclassResult = [];
            let contraPostingResult = [];
            let comCode = selection.comCode;
            let parameterList = [];
            let positionList = [];
            let pyCostAssignment = [];

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            //Get Payroll Result
            functionReturn = await this.getPayrollResult(selection, keyDate);
            if (functionReturn.success) {
                payrollDirectoryList = functionReturn.result.payrollDirectoryList;
                rtList = functionReturn.result.rtList;
                pyAccountList = functionReturn.result.pyAccount;
                pyAccountDetailList = functionReturn.result.pyAccountDetail;
                pyAccountMappingList = functionReturn.result.pyAccountMapping;
                pyCostDistributionList = functionReturn.result.pyCostDistribution;
                pyWPBPList = functionReturn.result.pyWPBP;
                pyCostAssignment = functionReturn.result.pyCostAssignment;
                functionReturn.clear();
            } else {
                return functionReturn;
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            //Get PY Account Emp Grouping Detail
            functionReturn = await this.getPYAccountEmpGroupingDetail();
            if (functionReturn.success) {
                pyAccountEmpGroupingDetailList = functionReturn.result;
                functionReturn.clear();
            } else {
                return functionReturn;
            }
            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            //Get Parameter
            let parameterCondition = { paramName: parameterName };
            parameterList = await dbProcess.getParameter(parameterCondition);

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            let positionCondition = {
                startDate: { [Op.lte]: moment().format(globalConstant.dbDateFormat) },
                endDate: { [Op.gte]: moment().format(globalConstant.dbDateFormat) },
            };
            positionList = await dbProcess.getPosition(positionCondition);

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            // บัญชีที่มี รายการปกติ
            for (const pyAccountItem of pyAccountMappingList) {

                let storeResult = [];
                let accountGroupCode = lodash.get(pyAccountItem, 'accountGroupCode', '');
                let wtCode = lodash.get(pyAccountItem, 'wtCode', '');
                let pyAccountDetail = pyAccountDetailList.filter(val => val.accountGroupCode === accountGroupCode);
                let rt = rtList.filter(val => val.wtCode === wtCode);

                for (const pyAccountDetailItem of pyAccountDetail) {

                    if (pyAccountDetailItem.reclassDebit === null && pyAccountDetailItem.reclassFlag === 1) continue;

                    if (comCode.length > 0) {
                        let company = lodash.get(pyAccountDetailItem, 'company', '');
                        if (comCode.indexOf(company) === -1) continue;
                    }
                    let pyAccountResult = { ...pyAccountItem, ...pyAccountDetailItem };
                    storeResult.push(pyAccountResult);
                }

                for (const resultItem of storeResult) {
                    for (const rtItem of rt) {
                        let resultItemObj = {};
                        let accountCode = lodash.get(resultItem, 'debit', '') || lodash.get(resultItem, 'credit', '');
                        let pyAccountDesc = pyAccountList.find(val => val.accountCode === accountCode);
                        resultItemObj = {
                            ...resultItem,
                            ...rtItem,
                            accountCodeDesc: lodash.get(pyAccountDesc, 'accountCodeDesc', ''),
                            separateIndicator: 1
                        };


                        ////

                        // let company = lodash.get(resultItemObj, 'company', '');
                        // let rgdirID = lodash.get(resultItemObj, 'rgdirID', '');
                        // let accEmpGroupCode = lodash.get(resultItemObj, 'accEmpGroupCode', '');
                        // let rtResult = pyWPBPList.find((val) => val.rgdirID === rgdirID && val.comCode === company);
                        // let orgCode = lodash.get(rtResult, 'orgCode', '');
                        // let posCode = lodash.get(rtResult, 'posCode', '');
                        // let positionResult = lodash.get(positionList.find(val => val.posCode === posCode), 'pyProcessingClass', '');
                        // if (!orgCode) continue;

                        // //เชคว่า ต้องเจอ orgCode รึเปล่า
                        // let pyAccGroupingList = [];
                        // for (const pyAccItem of pyAccountEmpGroupingDetailList) {
                        //     let incSubOrg = lodash.get(pyAccItem, 'incSubOrg', false);
                        //     let positionList = lodash.get(pyAccItem, 'positionList', []);
                        //     let pyAccOrgCode = lodash.get(pyAccItem, 'orgCode', []);
                        //     let orgList = null;

                        //     if (incSubOrg) {
                        //         orgList = await selectionUtil.validateOrgIncludeFlag(pyAccOrgCode);
                        //     }

                        //     let orgListResult = lodash.get(orgList, 'result', []);
                        //     orgListResult = lodash.isEmpty(orgListResult) ? [] : orgListResult;
                        //     orgListResult = orgListResult.concat(pyAccOrgCode);

                        //     if (orgListResult.length > 0) {
                        //         if (
                        //             orgListResult.indexOf(orgCode) !== -1 &&
                        //             pyAccItem.comCode.indexOf(company) !== -1 &&
                        //             (pyAccItem.accEmpGroupCode === accEmpGroupCode)
                        //         ) {
                        //             pyAccGroupingList.push(pyAccItem);
                        //         }
                        //     } else {
                        //         if (
                        //             pyAccItem.comCode.indexOf(company) !== -1 &&
                        //             positionList.indexOf(posCode) !== -1 &&
                        //             (pyAccItem.accEmpGroupCode === accEmpGroupCode || pyAccItem.accEmpGroupCode === positionResult)
                        //         ) {
                        //             pyAccGroupingList.push(pyAccItem);
                        //         }
                        //     }
                        // }

                        // if (pyAccGroupingList.length > 0) {
                        //     // let resultItemObj = {...reclassItem};
                        //     // resultItemObj.separateIndicator = 2;
                        //     // reclassResult.push(resultItemObj);
                        //     normalPostingResult.push(resultItemObj);
                        // }

                        ////
                        normalPostingResult.push(resultItemObj);
                    }
                }
            }

            if (arrayUtil.isEmpty(normalPostingResult)) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.noPyResultFound");  //'No Payroll Result found'
                return functionReturn;
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            let normalPostingCreditGroup = lodash.filter(normalPostingResult, (val) => val.credit !== null);
            let normalPostingDebitGroup = lodash.filter(normalPostingResult, (val) => val.debit !== null);
            normalPostingResult = [...normalPostingDebitGroup, ...normalPostingCreditGroup];

            // บัญชีที่มี reclass + ธรรมดา
            let reclassResultList = lodash.filter(normalPostingResult, (val) => val.reclassFlag === 1);
            for (const reclassItem of reclassResultList) {

                if (reclassItem.costDistributionNo === 1) continue;

                let company = lodash.get(reclassItem, 'company', '');
                let rgdirID = lodash.get(reclassItem, 'rgdirID', '');
                let accEmpGroupCode = lodash.get(reclassItem, 'accEmpGroupCode', '');
                let rtResult = pyWPBPList.find((val) => val.rgdirID === rgdirID && val.comCode === company);
                let orgCode = lodash.get(rtResult, 'orgCode', '');
                let posCode = lodash.get(rtResult, 'posCode', '');
                let positionResult = lodash.get(positionList.find(val => val.posCode === posCode), 'pyProcessingClass', '');
                if (!orgCode) continue;

                //เชคว่า ต้องเจอ orgCode รึเปล่า
                let pyAccGroupingList = [];
                for (const pyAccItem of pyAccountEmpGroupingDetailList) {
                    let incSubOrg = lodash.get(pyAccItem, 'incSubOrg', false);
                    let positionList = lodash.get(pyAccItem, 'positionList', []);
                    let pyAccOrgCode = lodash.get(pyAccItem, 'orgCode', []);
                    let orgList = null;

                    if (incSubOrg) {
                        orgList = await selectionUtil.validateOrgIncludeFlag(pyAccOrgCode);
                    }

                    let orgListResult = lodash.get(orgList, 'result', []);
                    orgListResult = lodash.isEmpty(orgListResult) ? [] : orgListResult;
                    orgListResult = orgListResult.concat(pyAccOrgCode);

                    if (orgListResult.length > 0) {
                        if (
                            orgListResult.indexOf(orgCode) !== -1 &&
                            pyAccItem.comCode.indexOf(company) !== -1 &&
                            (pyAccItem.accEmpGroupCode === accEmpGroupCode)
                        ) {
                            pyAccGroupingList.push(pyAccItem);
                        }
                    } else {
                        if (
                            pyAccItem.comCode.indexOf(company) !== -1 &&
                            positionList.indexOf(posCode) !== -1 &&
                            (pyAccItem.accEmpGroupCode === accEmpGroupCode || pyAccItem.accEmpGroupCode === positionResult)
                        ) {
                            pyAccGroupingList.push(pyAccItem);
                        }
                    }
                }

                if (pyAccGroupingList.length > 0) {
                    let resultItemObj = { ...reclassItem };
                    resultItemObj.separateIndicator = 2;
                    reclassResult.push(resultItemObj);
                }
            }

            pyCostDistributionList = lodash.filter(pyCostDistributionList, (val) => {
                return val.comCode !== "" && val.costCenterCode !== "" && val.orderNumber !== "";
            });

            // บันชีที่มี reclass + costdist (Default)
            for (const pyCostDistItem of pyCostDistributionList) {
                let rgdirID = lodash.get(pyCostDistItem, 'rgdirID', '');
                let rtResult = lodash.filter(normalPostingResult, (val) => val.rgdirID === rgdirID && val.reclassFlag === 1);
                let orderNumber = lodash.get(pyCostDistItem, 'orderNumber', '');
                if (rtResult.length < 1) continue;

                for (const rtItem of rtResult) {
                    if (rtItem.costDistributionNo !== 1) continue;

                    let ignoreCostDistribution = lodash.get(rtItem, 'ignoreCostDistribution', '');
                    let resultItemObj = { ...rtItem };
                    let amount = lodash.get(resultItemObj, 'amount', '');

                    if (ignoreCostDistribution === 0) {
                        let percent = lodash.get(pyCostDistItem, 'percent', '');
                        resultItemObj.amount = Number(Number((Number(amount) * Number(percent)) / 100).toFixed(2));
                        resultItemObj.orderNumber = orderNumber;
                        resultItemObj.separateIndicator = 2;
                        reClassPostingDefaultResult.push(resultItemObj);
                    }
                }
            }

            // บันชีที่มี reclass + costdist (ไม่กระจาย Cost)
            let maxSequence = lodash.maxBy(pyCostDistributionList, (val) => val.sequenceNo);
            for (const pyCostDistItem of [maxSequence]) {
                let rgdirID = lodash.get(pyCostDistItem, 'rgdirID', '');
                let rtResult = lodash.filter(normalPostingResult, (val) => val.rgdirID === rgdirID && val.reclassFlag === 1);
                let orderNumber = lodash.get(pyCostDistItem, 'orderNumber', '');
                if (rtResult.length < 1) continue;
                for (const rtItem of rtResult) {
                    if (rtItem.costDistributionNo !== 1) continue;

                    let ignoreCostDistribution = lodash.get(rtItem, 'ignoreCostDistribution', '');
                    let costAssignmentNo = lodash.get(rtItem, 'costAssignmentNo', '');
                    let resultItemObj = { ...rtItem };
                    let amount = lodash.get(resultItemObj, 'amount', '');

                    if (ignoreCostDistribution === 1) {
                        resultItemObj.amount = Number(amount);
                        resultItemObj.separateIndicator = 2;
                        if (costAssignmentNo > 0) {
                            let result = lodash.find(pyCostAssignment, (val) => val.rgdirID === rgdirID && val.costAssignmentNo === costAssignmentNo);
                            resultItemObj.orderNumber = lodash.get(result, 'orderNumber', '')
                        } else {
                            resultItemObj.orderNumber = orderNumber;
                        }
                        reClassPostingResult.push(resultItemObj);
                    }
                }
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);


            // บันชีที่มี contra
            let groupReclassDebit = lodash.groupBy(reClassPostingDefaultResult, (val) => val.reclassDebit);
            let sumReclassDebit = lodash.map(groupReclassDebit, (groupDebit) => {
                let reduceAmount = lodash.reduce(groupDebit, (sum, n) => {
                    let sumAmount = Number(Number(Number(sum.amount) + Number(n.amount))).toFixed(2);
                    return { ...n, amount: sumAmount };
                }, { amount: 0 });
                return reduceAmount;

            });

            // filter reclass ธรรมดาออก ถ้าหากมี รายการ reclass ที่เป็น costdistribution
            reclassResult = this.sumAmountGroupByAccGroupCodeRgdirID(reclassResult);
            for (const reclassCostDistItem of sumReclassDebit) {
                let reclassDebitCostDist = lodash.get(reclassCostDistItem, 'reclassDebit', '');
                let amountCostDist = lodash.get(reclassCostDistItem, 'amount', 0);
                let rgdirIDCostDist = lodash.get(reclassCostDistItem, 'rgdirID', 0);
                for (const [index, reclassNormalItem] of reclassResult.entries()) {
                    let reclassDebit = lodash.get(reclassNormalItem, 'reclassDebit', '');
                    let amount = lodash.get(reclassNormalItem, 'amount', 0);
                    let rgdirID = lodash.get(reclassCostDistItem, 'rgdirID', 0);
                    if (reclassDebit === reclassDebitCostDist && amount === amountCostDist && rgdirID === rgdirIDCostDist) {
                        reclassResult.splice(index, 1);
                    }
                }
            }

            let mergeReclass = [...reclassResult, ...sumReclassDebit];
            for (const reclassList of mergeReclass) {
                let resultItemObj = { ...reclassList };
                let accountCodeDesc = lodash.get(resultItemObj, 'accountCodeDesc', '');
                let debit = lodash.get(resultItemObj, 'debit', '');

                if (debit) {
                    resultItemObj.credit = debit;
                }

                resultItemObj.credit = `${resultItemObj.credit.substring(0, resultItemObj.credit.length - 1)}9`;
                resultItemObj.debit = null;
                resultItemObj.accountCodeDesc = `${accountCodeDesc}-${contraAccountLabel}`;
                resultItemObj.separateIndicator = 2;
                contraPostingResult.push(resultItemObj);
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            // group + คำนวณ amount
            let normalAdminFilter = lodash.filter(normalPostingResult, (val) => val.reclassFlag === 0);
            let sumNormalPostingResultAmount = this.sumAmountGroupByAccGroupCode(normalAdminFilter);
            let contraPostingPostingResultAmount = this.sumAmountGroupByAccGroupCode(contraPostingResult);
            let reclassResultAmount = this.sumAmountGroupByAccGroupCode(reclassResult);
            reClassPostingDefaultResult = this.sumAmountGroupByAccGroupCode(reClassPostingDefaultResult);
            reClassPostingResult = this.sumAmountGroupByAccGroupCode(reClassPostingResult);
            reclassResultAmount = lodash.map(reclassResultAmount, (val) => {
                val.debit = lodash.get(val, 'reclassDebit', '');
                return val;
            }).sort((a, b) => a.debit - b.debit);
            reClassPostingDefaultResult = lodash.map(reClassPostingDefaultResult, (val) => {
                val.debit = lodash.get(val, 'reclassDebit', '');
                return val;
            }).sort((a, b) => a.debit - b.debit);
            reClassPostingResult = lodash.map(reClassPostingResult, (val) => {
                val.debit = lodash.get(val, 'reclassDebit', '');
                return val;
            }).sort((a, b) => a.debit - b.debit);
            let mergeAllAccountPosting = [...sumNormalPostingResultAmount, ...reclassResultAmount, ...reClassPostingDefaultResult, ...reClassPostingResult, ...contraPostingPostingResultAmount]

            let month = moment().format('MM').padStart(2, '0');
            let year = moment().format('YYYY');

            // map field obj result
            let currentComCode = '';
            let currentSeparateIndicator = '';
            let isShowTitleColumn = false;
            for (const normalPostingItem of mergeAllAccountPosting) {

                let output = { ...outputStructureResult };
                let company = lodash.get(normalPostingItem, 'company', '');
                let separateIndicator = lodash.get(normalPostingItem, 'separateIndicator', '');
                let wtCode = lodash.get(normalPostingItem, 'wtCode', '');
                let longText1Desc = lodash.get(parameterList.find(val => lodash.get(val, 'lowValue', '') === wtCode), 'remark', '');
                let currentYear = moment().format('YYYY');

                if (!separateIndicator || !currentComCode || currentComCode !== company || currentSeparateIndicator !== separateIndicator) {
                    currentComCode = company;
                    isShowTitleColumn = true;
                    currentSeparateIndicator = separateIndicator;
                } else {
                    isShowTitleColumn = false;
                }

                for (const outputKey of Object.keys(outputStructureResult)) {

                    if (outputStructure.titleGroup().indexOf(outputKey) !== -1 && !isShowTitleColumn) {
                        output[outputKey] = '';
                        continue;
                    }

                    switch (outputKey) {
                        case 'separateIndicator':
                            output[outputKey] = separateIndicator;
                            break;
                        case 'documentDate':
                            output[outputKey] = moment(keyDate);
                            break;
                        case 'companyCode':
                            output[outputKey] = lodash.get(normalPostingItem, 'company', '');
                            break;
                        case 'postingDate':
                            output[outputKey] = moment(keyDate);
                            break;
                        case 'period':
                            output[outputKey] = String(selection.payrollPeriod).padStart(2, '0');
                            break;
                        case 'refKeyHeader1':
                            //  let refKeyHeader1Result = await this.numberRangeManagers();
                            //  if (!refKeyHeader1Result.success) {
                            //     functionReturn = refKeyHeader1Result;
                            //     return;
                            //  }
                            let runningNumber = separateIndicator.toString().padStart(6, '0');
                            let pyPeriod = String(selection.payrollPeriod).padStart(2, '0');
                            output[outputKey] = `${numberRangePrefix}${currentYear}${pyPeriod}${runningNumber}`;
                            break;
                        case 'postingKey':
                            output[outputKey] = normalPostingItem.debit ? postingKeyType.debit : postingKeyType.credit;
                            break;
                        case 'accountSAP':
                            output[outputKey] = lodash.get(normalPostingItem, 'debit', '') || lodash.get(normalPostingItem, 'credit', '');
                            break;
                            // case 'specialGLIndicator':
                            //     output[outputKey] = lodash.get(normalPostingItem, 'accountCodeDesc', '');
                            break;
                        case 'amtDocCurr':
                            output[outputKey] = lodash.get(normalPostingItem, 'amount', '');
                            break;
                        case 'amtLocalCurr':
                            output[outputKey] = lodash.get(normalPostingItem, 'amount', '');
                            break;
                        case 'text':
                            output[outputKey] = separateIndicator === 1 ? `Payroll ${month}/${year}` : `Reclass Payroll ${month}/${year}`;
                            break;
                        case 'costCenter':
                            output[outputKey] = lodash.get(normalPostingItem, 'debitChargeExpenseCode', '') || lodash.get(normalPostingItem, 'creditChargeExpenseCode', '');
                            break;
                        case 'order':
                            output[outputKey] = lodash.get(normalPostingItem, 'orderNumber', '');
                            break;
                        case 'profitCenter':
                            output[outputKey] = `${lodash.get(normalPostingItem, 'company', '').slice(0, 3)}00000`;
                            break;
                        case 'longText1':
                            output[outputKey] = longText1Desc;
                            break;
                        default:
                            break;
                    }
                }

                let amtDocCurr = lodash.get(output, 'amtDocCurr', '');
                let amtLocalCurr = lodash.get(output, 'amtLocalCurr', '');
                let accountSAP = lodash.get(output, 'accountSAP', '').charAt(0);
                if (amtDocCurr < 0 || amtLocalCurr < 0 && accountSAP === accountReClass) {
                    output.amtDocCurr = Math.abs(amtDocCurr);
                    output.amtLocalCurr = Math.abs(amtLocalCurr);
                    output.postingKey = postingKeyType.credit;
                }
                outputResultFormat.push(output);
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);

            // ปรับ template result
            const templateDetail = await services.getITemplateMapITemplateDetail(interfaceType);
            const { infFieldListIncludeDetail: detailList } = templateDetail.result;
            let formatJSONList = [];
            for (let val of outputResultFormat) {

                let amtDocCurr = lodash.get(val, 'amtDocCurr', 0);
                let amtLocalCurr = lodash.get(val, 'amtLocalCurr', 0);
                if (amtDocCurr === 0 || amtLocalCurr === 0) continue;

                let formatData = {};
                for (let detail of detailList) {
                    let { fieldMapping, fieldCode, dataType, infDataFormat } = detail;
                    let getValue = lodash.get(val, fieldMapping, "");

                    if (dataType === "DATE" && getValue !== '') {
                        getValue = moment(getValue).format(infDataFormat);
                    } else if (dataType === "DATE" && getValue === '') {
                        getValue = '';
                    }

                    if (fieldCode === "AmtDocCurr" || fieldCode === "AmtLocalCurr") {
                        let sign = Math.sign(getValue);
                        getValue = Number(Math.abs(getValue)).toFixed(2);
                        if (sign === -1) {
                            getValue = `${Number(Math.abs(getValue)).toFixed(2)}-`;
                        }
                    }

                    if (getValue) {
                        if (getValue[0] === '0' || getValue[0] === 0) {
                            getValue = `'${getValue}`;
                        }
                    }

                    formatData[fieldCode] = getValue;
                }
                formatJSONList.push(formatData);
            }

            bgProcess.updateStepProgress(constant.bgStepSelectData.id, countProgress++, totalDatabase);
            functionReturn.success = true;
            functionReturn.result = formatJSONList;
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - getResultPosting', '', '', '', '')
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText("tenant.assetwise.payrollPosting.error.readData");
        }
        return functionReturn;
    }

    async getCurrentPeriodDetail(condition) {

        let functionReturn = new FunctionReturn();
        let dbProcess = new DBProcess();

        try {

            let currentPeriod = await dbProcess.getCurrentPeriod(condition);
            if (!jsonUtil.isEmpty(currentPeriod)) {
                functionReturn.success = true;
                functionReturn.result = currentPeriod;
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('tenant.assetwise.payrollPosting.error.noPayrollControlRecordFound'); //'No Payroll Control Record found';
            }
        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/assetwise/payrollposting/util - getCurrentPeriodDetail', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception'); //'Error in leave type detail';
        }

        return functionReturn;

    }
}

exports.PayrollPostingProcessingUtil = PayrollPostingProcessingUtil;
[File Ends] util.js


<-- File Content Ends


[File Ends] payrollposting.txt

[File Begins] payrolltojoget.txt
Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

payrolltojoget/
├── dbprocess.js
├── excelform.js
├── main.js
├── service.js
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] dbprocess.js
const db = require('../../../../config/sequelize/sequelize').getConfig();
const reqContext = require('../../../../utils/requestcontext');
const Sequelize = require('sequelize');
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
class DBProcess {

  async getSYMCPRGroupHeader(condition) {
    const symcPRGroupHeader = db[reqContext.getTenantCode()].SYMCPRGroupHeader;

    return symcPRGroupHeader.findAll({
      raw: true,
      attributes: [
          'id',
          'prcomCode',
          'prGroupCode',
          [Sequelize.col('ConfigText.description'), 'prGroup'],
          'prPaidToName',
          'prStartDate',
          'prEndDate',
          'prPaymentBy'
      ],
      include: [
        {
            required: false, //Left JOIN
            model: db[reqContext.getTenantCode()].ConfigText,
            attributes: [],
            where: {
                configTableCode: 'SYMCPRGroupHeader',
                langKeyCode: reqContext.getLanguage()
            }
        }
      ],
      where: condition,
      order: [
        ['prcomCode', 'ASC'],
        ['prGroupCode', 'ASC']
      ],
    });
  }  

  async getSYMCPRGroupDetail() {
    const symcPRGroupDetail = db[reqContext.getTenantCode()].SYMCPRGroupDetail;

    return symcPRGroupDetail.findAll({
      raw: true,
      order: [
        ['prGroupHeaderID', 'ASC'],
        ['prwtCode', 'ASC'],
        ['prItemCode', 'ASC']
      ],
    });
  }  

  async getLastSYMCPostedResult(condition) {
    const symcPostedResult = db[reqContext.getTenantCode()].SYMCPostedResult;

    return symcPostedResult.findOne({
      raw: true,
      attributes: [
        'inPeriod',
        'inPeriod',
        'prNo',
        'numOfTime'
      ],
      where: condition,
      order: [
        ['numOfTime', 'DESC']
      ],
    });
  }  

  // async getPayrollPeriod(condition) {
    
  //   return db[reqContext.getTenantCode()].PayrollPeriod.findAll({
  //       raw: true,
  //       attributes: [
  //         'payrollPeriodCode',
  //         'period',
  //         'year',
  //         'startDate',
  //         'endDate',
  //         'paymentDate',
  //         'payrollAreaCode'
  //       ],
  //       where: condition
  //   });

  // }

  async getPayrollPeriod(condition) {
    
    return db[reqContext.getTenantCode()].PayrollPeriod.findAll({
        raw: true,
        attributes: [
          'payrollPeriodCode',
          'period',
          'year',
          'startDate',
          'endDate',
          'paymentDate',
          'payrollAreaCode'
        ],
        where: condition
    });
  }

  async getPayrollDirectory(condition) {

    return db[reqContext.getTenantCode()].PayrollResultDirectory.findAll({
        raw: true,
        attributes: [
          'id',
          'empCode',
          'seqNo',
          'forPeriod',
          'forYear',
          ['inPeriod', 'period'],
          ['inYear', 'year'],
          'paymentDate',
          'payType',
          'payrollAreaCode'
        ],
        where: condition,
        order: [
          ['empCode', 'ASC']
        ]
    })
  }

  async getPYWPBP(condition) {
    const pyWPBP = db[reqContext.getTenantCode()].PYWPBP
    return pyWPBP.findAll({
        raw: true,
        where: condition,
        order: [
          ['id', 'ASC']
        ]
    })
  }

  async getRT(condition) {
    return db[reqContext.getTenantCode()].RT.findAll({
        raw: true,
        attributes: [
            'rgdirID',
            'wtCode',
            'amount',
            'quantity',
            'rate'
        ],
        where: condition
    })
  }

  async getParameter(condition) {

    return db[reqContext.getTenantCode()].Parameter.findOne({
        raw: true,
        attributes: [
            'sign',
            'operator',
            'lowValue',
            'highValue'
        ],
        where: condition
    });

  }

  async getServerConnection(condition) {
    return db[reqContext.getTenantCode()].ServerConnection.findOne({
        raw: true,
        where: condition
    });
  }

  async bulkCreateSYMCPostedResult(param) {
    let functionReturn = new FunctionReturn()

    try {
        // get transaction
        const symcPostedResult = db[reqContext.getTenantCode()].SYMCPostedResult;

        let resultList = param.dataList;
        let transaction = param.transaction;
        
        let insSYMCPostedResultList = await symcPostedResult.bulkCreate(resultList, { transaction });

        if(insSYMCPostedResultList) {

        }

        functionReturn.success = true;
        functionReturn.result = insSYMCPostedResultList;

    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/payrolltojoget/dbprocess - bulkCreateSYMCPostedResult', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

}
exports.DBProcess = DBProcess;

[File Ends] dbprocess.js

[File Begins] excelform.js
const lodash = require('lodash');
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const excel = require('excel4node');
const helper = require('../../../../utils/helper');
const moment = require('moment');
const translation = require('../../../../utils/translation');
const ExcelBuilder = require('../../../../utils/excel/excel-builder');

class ExcelForm {

  async main(param) {

    let functionReturn = new FunctionReturn();
    let fileBuffer;
    try {
      let selection = param.selection;

      functionReturn = await this.convertToExcel(param);
      if (functionReturn.success) {
        // fileWb = functionReturn.result;
        fileBuffer = await functionReturn.result.writeToBuffer().then(async (buffer) => {
          let filename = translation.getTranslateText('tenant.symc.payrollToJoget.fileName')

          let paymentDate = moment(selection.paymentDate);
          if (paymentDate.isValid()) {
            filename += '_' + paymentDate.format('YYYYMMDD');
          }

          filename +=  '.xlsx';

          return {
            content: buffer,
            fileName: filename,
            fileExt: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          };
        });


        functionReturn.success = true;
        // functionReturn.success = false;
        functionReturn.result = fileBuffer;
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/payrolltojoget/excelform - main', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async convertToExcel(param) {
    let functionReturn = new FunctionReturn();

    try {

      let resultDataList = param.resultDataList;
      let excelFieldList = param.excelFieldList;

      let workbook = new excel.Workbook();
      let worksheet = workbook.addWorksheet('Interface to JOGET');
      let style = this.createCellStyle(workbook);
      const excelBuilder = new ExcelBuilder();
      const excelStyleBuilder = excelBuilder.getStyleBuilder();
      let tmpHeaderFieldList = [];

      let i = 1;

      //Column Header
      let j = 1;
      for(let excelField of excelFieldList) {
        if(excelField.excelHeader) {
          worksheet.cell(i, j).string(excelField.excelHeader).style(style.columnHeaderStyle);
          tmpHeaderFieldList.push(excelField);

          j++;
        }
      }
      
      //Body
      i++;
      for(let resultData of resultDataList) {
        j = 1;

        for(let tmpHeaderField of tmpHeaderFieldList) {
          let value = resultData[tmpHeaderField.field];
          
          if(value == undefined || value == null) {
            worksheet.cell(i, j++).string('').style(style.contentTextStyle);
          } else {
            switch (tmpHeaderField.type) {
              case 'I':
                worksheet.cell(i, j++).number(value).style(style.contentNumberStyle);
                break;
              case 'DEC':
                worksheet.cell(i, j++).number(value).style(style.contentAmountStyle);
                break;
              case 'DATE':
                // worksheet.cell(i, j++).date(value).style(style.contentDateStyle);
                let tmpDate = moment(value).format('DD/MM/YYYY');
                worksheet.cell(i, j++).string(tmpDate).style(style.contentTextStyle);
                break;
              case 'DATETIME':
                let tmpDateTime = moment(value).format('DD/MM/YYYY HH:mm:ss');
                worksheet.cell(i, j++).string(tmpDateTime).style(style.contentTextStyle);
                // worksheet.cell(i, j++).date(value).style(style.contentTextStyle);
                break;
              case 'CC':
                worksheet.cell(i, j++).string(value).style(style.contentTextCenterStyle);
                break;
              case 'C':
              default:
                worksheet.cell(i, j++).string(value).style(style.contentTextStyle);
                break;
            }
          }
        }

        i++;
      }

      functionReturn.success = true;
      functionReturn.result = workbook;

    } catch (error) {
      helper.logMessage('error', error.stack, 'symc/payrolltojoget/excelform - convertToExcel', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  createCellStyle(workbook) {
    return {
      columnHeaderStyle: workbook.createStyle({
        font: {
          bold: true,
        },
        alignment: {
          horizontal: 'center',
          vertical: 'center',
        },
        fill: {
          type: 'pattern',
          patternType: 'solid',
          bgColor: '#DEEBF7',
          fgColor: '#DEEBF7',
        },
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentTextStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentTextCenterStyle: workbook.createStyle({
        alignment: {
          horizontal: 'center',
          vertical: 'center',
        },
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
      }),
      contentNumberStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        // numberFormat: '#,##0',
      }),
      contentAmountStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: '#,##0.00',
      }),
      contentDateStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'dd/mm/yyyy',
      }),
      contentDateTimeStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'dd/mm/yyyy hh:mm:ss',
      }),
      contentTimeStyle: workbook.createStyle({
        border: {
          left: {
            style: 'thin',
          },
          right: {
            style: 'thin',
          },
          top: {
            style: 'thin',
          },
          bottom: {
            style: 'thin',
          },
        },
        numberFormat: 'HH:mm:ss',
      }),
      headerReportTitle: workbook.createStyle({
        font: {
          bold: true,
          size: 14,
        },
      }),
      breakTitle: workbook.createStyle({
        font: {
          bold: true,
          size: 16,
        },
      }),
      footerTitle: workbook.createStyle({
        font: {
          bold: true,
        },
      }),
    };
  }
}
exports.ExcelForm = ExcelForm;

[File Ends] excelform.js

[File Begins] main.js
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const constant = require('../../../../config/constant');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const path = require('path');
const BGProcess = require('../../../../utils/bgprocess').BGProcess;
const program = 'TNT_SYMC01';
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const Util = require('./util').Util;

exports.main = async (req, res, next) => {
  if (!req.body.bgProcess.isProcess) {
    await execute(req.body, new BGProcess(program), res, next);
  } else {
    let controller = path.resolve(__dirname) + '/main';
    let functionReturn = await new BGProcess(program).start(controller, req.body);
    res.json(functionReturn);
  }
};

exports.jobSchedule = async (req) => {
  let controller = path.resolve(__dirname) + '/main';
  let functionReturn = await new BGProcess(program).start(controller, req.body);
  return functionReturn;
};

process.on('message', async (bgProcess) => {
  bgProcess = Object.assign(new BGProcess(), bgProcess);
  bgProcess.startAt = new Date(bgProcess.startAt);
  bgProcess.functionReturn = new FunctionReturn();
  await execute(bgProcess.selection, bgProcess);
});

const execute = async (selection, bgProcess, res = null, next = null) => {
  let functionReturn = new FunctionReturn();
  let util = new Util();

  try {
    let param = {
      selection: selection,
      bgProcess: bgProcess,
      // res: res,
    };
    functionReturn = await util.execute(param);
		if (functionReturn.success) {
			let file = functionReturn.result;
			functionReturn.clear();

			let fileName = file.fileName;
			await bgProcess.handleOutputFile(file.content, fileName, file.fileExt, res, null);
		}
		else {
			bgProcess.handleError(functionReturn, res);
		}

  } catch (error) {
    helper.logMessage('error', error.stack, 'symc/payrolltojoget/main - execute', '', '', '', '');
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
  }
};

exports.initPage = async (req, res, next) => {
  let functionReturn = new FunctionReturn();

  try {
    let util = new Util();
    functionReturn = await util.initPage();
    
  } catch (error) {
    helper.logMessage('error', error.stack, 'symc/payrolltojoget/main - initPage', '', '', '', '');
    functionReturn.success = false;
    functionReturn.message = translation.getTranslateText('common.error.exception');
  }
  res.json(functionReturn);
};

[File Ends] main.js

[File Begins] service.js
const cryptoJS = require("crypto-js");
const lodash = require('lodash');
const btoa = require('btoa');

const reqContext = require('../../../../utils/requestcontext');
const translation = require('../../../../utils/translation');
const env = require("../../../../config/environment/environment").getConfig();
const helper = require('../../../../utils/helper');
const { json } = require("body-parser");
const DBProcess = require('./dbprocess').DBProcess;
const jsonUtil = require('../../../../utils/json');
const axios = require('axios');

const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const method = {
    get: 'GET',
    post: 'POST',
    delete: 'DELETE'
}

class JOGETService {

    constructor() {}

    /**
    * @param {string} data  [Required]
    * @param {string} key   [Required]
    * @param {string} iv    [Required]
    * 
    * @returns {FunctionReturn} 
    * @returns {string}     Encrypt string data
    */
    encData(data, key, iv) {
        let secret = cryptoJS.enc.Base64.parse(key);
        let ivDecode = cryptoJS.enc.Base64.parse(iv);
        let encData = cryptoJS.AES.encrypt(data.toString(), secret, {iv: ivDecode});
        return encData.toString();
    }

    hmacData(dataToSign) {
        // secret ปรับไปใช้ env variable 
        let secret = env[reqContext.getTenantCode()].thirdParty.iZign.iZignSecret;
        let hash = cryptoJS.HmacSHA256(dataToSign, secret);
        return hash.toString();
    }
      
    isUseBody(method, contentType) {
        const supportMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];
        return supportMethods.includes(method) && contentType.indexOf('application/json') != -1;
    }
      
    getHmacBody(requestBody, method, contentType) {
        
        let body = '';
        
        if (this.isUseBody(method, contentType)) {
            if (!this.isJsonString(requestBody)) {
                body = JSON.stringify(requestBody);
            } else {
                body = requestBody;
            }
        }

        if (body == null) {
            body = '';
        }

        return body;
    }
    
    isJsonString(val) {
        try {
            JSON.parse(val);
        } catch (e) {
            return false;
        }
        return true;
    }
    
    getHmacContentType(method, contentType) {
        if (this.isUseBody(method, contentType)) {
            return contentType;
        }
        return '';
    }

    /**
    * @param {string} params.serverConnectionData [Required]
    * 
    * @returns {FunctionReturn} 
    * @returns {string} result authorization
    */
    async genAuthorization(param) {
        let functionReturn = new FunctionReturn();

        try {
            let serverConn = param.serverConnectionData;
            let clientID = serverConn.username;
            let encryptClientSecret = serverConn.password;
        
            let clientSecret;
            functionReturn = helper.decrypt(encryptClientSecret, env[reqContext.getTenantCode()].serverConnSecretKey);
            if(!functionReturn.success) {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noServerConnSecretKeyFound');
                return functionReturn;
            }

            clientSecret = functionReturn.result;

            var token = clientID + ":" + clientSecret;

            var authorization = 'Basic ' + btoa(token);    

            functionReturn.success = true;
            functionReturn.result = authorization;

        } catch (error) {
            helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/service - genAuthorization', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');  
        }

        return functionReturn;
    }
}

exports.JOGETService = JOGETService;

[File Ends] service.js

[File Begins] util.js
// const XLSX = require('xlsx');
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;
const DBProcess = require('./dbprocess').DBProcess;
const JOGETService = require('./service').JOGETService;
const db = require('../../../../config/sequelize/sequelize').getConfig();
const arrayUtil = require('../../../../utils/array');
const Sequelize = require('sequelize');
const Op = Sequelize.Op;
const helper = require('../../../../utils/helper');
const sh = require('../../../../utils/searchhelp');
const reqContext = require('../../../../utils/requestcontext');
const moment = require('moment');
const jsonUtil = require('../../../../utils/json');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const ExcelForm = require('./excelform').ExcelForm;
const Permission = require('../../../../utils/authorization/permission/permission').Permission; //Check permission
const mathUtil = require('../../../../utils/math');
const axios = require('axios');

const connCode = 'JOGETAPI';

class Util {

  async initPage() {

    let functionReturn = new FunctionReturn();
    const dbProcess = new DBProcess();
    let companyList = [];
    let payrollAreaList = [];
    let empCodeList = [];
    let prGroupList = [];
    let payrollPeriodList = [];
    try {
      let condition = {
        startDate: {
          [Op.lte]: new Date(),
        },
        endDate: {
          [Op.gte]: new Date(),
        },
      };
      payrollPeriodList = await sh.getPayrollPeriod();
      companyList = await sh.getCompany({});
      payrollAreaList = await sh.getPayrollArea({});
      // empCodeList = await sh.getAvailableEmpList({});
      let paramSHEmp = {
        condition: {},
        allEmployee: true,
        checkPerAssign: true
      };
      empCodeList = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

      condition = {
        prStartDate: { [Op.lte]: new Date() },
        prEndDate: { [Op.gte]: new Date() },
      };
      prGroupList = await dbProcess.getSYMCPRGroupHeader(condition);

      //-----Check permission-----//
      let permsParam = {
        replaceEmptyList: false,
        checkObjectList: [
          {
            objectType: globalConstant.permissionObjectType.company,
            objectList: companyList,
            codeColumn: 'comCode'
          },
          {
            objectType: globalConstant.permissionObjectType.payrollArea,
            objectList: payrollAreaList,
            codeColumn: 'payrollArea'
          },
          {
            objectType: globalConstant.permissionObjectType.employee,
            objectList: empCodeList,
            codeColumn: 'key'
          },
        ],
      };
      let permission = new Permission();
      let permsReturn = await permission.checkObjectPermission(permsParam);
      if (permsReturn.success) {
        companyList = permsReturn.result.checkResult.companyList;
        payrollAreaList = permsReturn.result.checkResult.payrollAreaList;
        empCodeList = permsReturn.result.checkResult.empList;
      }
      //-----End check permission-----//

      let currentPeriod = {};
      let payrollArea = '';
      if (payrollAreaList.length > 0) {
        payrollArea = payrollAreaList[0].payrollAreaCode;
        currentPeriod = payrollPeriodList.find(elem => elem.payrollAreaCode == payrollAreaList[0].payrollAreaCode &&
          moment(elem.startDate).isSameOrBefore(moment(), 'day') &&
          moment(elem.endDate).isSameOrAfter(moment(), 'day'));
      }

      //Concate PR Group code
      for (let i = 0; i < prGroupList.length; i++) {
        prGroupList[i].prPaidToName = prGroupList[i].prGroup + ' - ' + prGroupList[i].prPaidToName;
      }

      functionReturn.success = true;
      functionReturn.result = {
        period: (currentPeriod.period) ? currentPeriod.period : '',
        year: (currentPeriod.year) ? currentPeriod.year : '',
        companySH: companyList,
        payType: 'NOR',
        invoiceDate: new Date(),
        payrollArea: payrollArea,
        payrollAreaSH: payrollAreaList,
        employeeSH: empCodeList,
        prGroupSH: prGroupList,
        payrollPeriodSH: payrollPeriodList,
        selectEmpType: 'ALL',
      };

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - initPage', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async execute(param) {
    let functionReturn = new FunctionReturn();
    let excelForm = new ExcelForm();
    try {
      let selection = param.selection;
      let resultDataList = [];
      let excelFieldList = [];
      let bgProcess = param.bgProcess;

      //Check permission
      functionReturn.clear();
      functionReturn = await this.adjustSelection(selection);
      if (!functionReturn.success) {
        // bgProcess.handleError(functionReturn, res);
        return functionReturn;
      }

      //Prepare data
      functionReturn = await this.prepareData(param);
      if (!functionReturn.success) {
        return functionReturn;
      }

      resultDataList = functionReturn.result.data;
      excelFieldList = functionReturn.result.excelFieldList;

      let resultParam = {
        selection: selection,
        resultDataList: resultDataList,
        excelFieldList: excelFieldList
      }

      //Process to JOGET
      if (selection.transferToJogetFlag) {
        //Update before send

        bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, 0, 1);
        functionReturn = await this.processToJoget(resultParam);
        if (functionReturn.success) {

        }
        bgProcess.updateStepProgress(globalConstant.bgStepProcessData.id, 1, 1);

        //Update after send
      }

      bgProcess.updateStepProgress(globalConstant.bgStepProcessFile.id, 0, 1);
      //Prepare excel
      let excel = new ExcelForm();
      functionReturn = await excel.main(resultParam);
      bgProcess.updateStepProgress(globalConstant.bgStepProcessFile.id, 1, 1);


    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - execute', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async adjustSelection(selection) {
    let functionReturn = new FunctionReturn();
    try {
      let permsParam = {
        replaceEmptyList: true,
        checkObjectList: [
          { objectType: globalConstant.permissionObjectType.company, objectList: [selection.comCode] },
          { objectType: globalConstant.permissionObjectType.payrollArea, objectList: [selection.payrollArea] },
          { objectType: globalConstant.permissionObjectType.employee, objectList: selection.empCodeList },
        ]
      }

      let permission = new Permission();
      let permsReturn = await permission.checkObjectPermission(permsParam);
      if (permsReturn.success) {
        if (!arrayUtil.isEmpty(permsReturn.result.checkResult.companyList)) {
          selection.compCode = permsReturn.result.checkResult.companyList[0];
        } else {
          selection.compCode = null;
        }
        if (!arrayUtil.isEmpty(permsReturn.result.checkResult.payrollAreaList)) {
          selection.payrollArea = permsReturn.result.checkResult.payrollAreaList[0];
        } else {
          selection.payrollArea = null;
        }
        selection.empCodeList = permsReturn.result.checkResult.empList;
        functionReturn.success = true;
      } else {
        functionReturn.success = false;
        functionReturn.message = permsReturn.message;
      }
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - adjustSelection', '', '', '', '')
      functionReturn.success = false
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async prepareData(param) {

    let functionReturn = new FunctionReturn();

    try {
      let selection = param.selection;
      let bgProcess = param.bgProcess;
      let empDataList = [];
      let payrollAreaList = [];
      let payrollPeriodList = [];
      let payrollResultDirList = [];
      let pywpbpList = [];
      let prGroupHList = [];
      let prGroupDList = [];
      let startDate;
      let endDate;
      let period;
      let year;
      let resultDataList = [];
      let countProgress = 0;
      let totalDatabase = 6;
      let numOfTime = 1;

      //Get PR Group Data
      functionReturn = await this.getPRGroup(selection);
      if (functionReturn.success) {
        prGroupHList = functionReturn.result.prGroupHList;
        prGroupDList = functionReturn.result.prGroupDList;
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Employee
      // let empCondition = {
      //   condition: {
      //   }
      // };
      let paramSHEmp = {
        condition: {},
        allEmployee: true,
        checkPerAssign: true,
      };

      if (!arrayUtil.isEmpty(selection.empCodeList)) {
        // empCondition.condition.empCode = selection.empCodeList;
        paramSHEmp.condition = {
          personalData: { empCode: selection.empCodeList }
        };
      }


      // empDataList = await sh.getAvailableEmpList(empCondition);
      empDataList = await sh.getNewAvailableEmpList(paramSHEmp); //NEW

      selection.empDataList = empDataList;
      selection.empCodeList = empDataList.map(a => a.key);
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Payroll period
      functionReturn = await this.getPayrollPeriod(selection);
      if (functionReturn.success) {
        payrollPeriodList = functionReturn.result.payrollPeriodList;
        startDate = functionReturn.result.startDate;
        endDate = functionReturn.result.endDate;
        period = functionReturn.result.period;
        year = functionReturn.result.year;
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Payroll Result Data
      selection.payrollPeriodList = payrollPeriodList;
      selection.payrollAreaList = payrollAreaList;
      selection.startDate = startDate;
      selection.endDate = endDate;
      selection.period = period;
      selection.year = year;
      functionReturn = await this.getPayrollResultData(selection);
      if (functionReturn.success) {
        payrollResultDirList = functionReturn.result.payrollResultDirList;
        pywpbpList = functionReturn.result.pywpbpResultList;
        // rtList = functionReturn.result.rtResultList;
      } else {
        return functionReturn;
      }
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Check last posted result in period
      functionReturn = await this.getLastPostedResult(selection);
      if (functionReturn.success) {
        numOfTime = functionReturn.result.numOfTime + 1;
      }
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);

      //Filter PYWPBP with comCode
      pywpbpList = pywpbpList.filter(elem => elem.comCode == selection.comCode);

      //Prepare data 
      let structure = this.prepareStructure();
      let tmpResult = structure.data;
      let arrayField = structure.fieldList;

      let seq = 0;
      let tmpInvoiceTotal = {};
      let tmpItemTotal = {};
      let empCount = {};
      let processBy = await reqContext.getCurrentUsername();
      let postDateTime = new Date();
      let currentDate = moment();
      let currentDateBE = moment().add(543, 'year');
      for (let prGroupH of prGroupHList) {

        let prGroupDByHList = prGroupDList.filter(elem => elem.prGroupHeaderID == prGroupH.id);
        if (arrayUtil.isEmpty(prGroupDByHList)) {
          continue;
        }

        let pywpbpGroupList = pywpbpList.filter(elem => elem.comCode == prGroupH.prcomCode);
        if (arrayUtil.isEmpty(pywpbpGroupList)) {
          continue;
        }

        let checkPRGroupDataExist = false;

        seq++
        let seqText = String(seq).padStart(4, "0");
        // let curPRNo = prGroupH.prGroup + '-'+ currentDateBE.format('YYYY') + currentDateBE.format('MM') + seqText;
        let tmpNumOfTime = (numOfTime < 10) ? '0' + numOfTime : numOfTime;

        //Pay type condition
        let payType = '';
        switch(selection.payType) {
          case globalConstant.pyNormalCycle: 
            payType = 'N';
            break;
          case globalConstant.pyOffCycle: 
            payType = 'S';
            break;
        }
        
        let curPRNo = prGroupH.prGroup + '-' + currentDateBE.format('YYYY') + currentDateBE.format('MM') + payType + seqText  + tmpNumOfTime;
        // let curPRNo = prGroupH.prGroup + '-' + currentDateBE.format('YYYY') + currentDateBE.format('MM') + seqText + tmpNumOfTime;
        let invoiceNo = prGroupH.prGroup + currentDate.format('YYYY') + currentDate.format('MM') + seqText;

        if (!tmpInvoiceTotal.hasOwnProperty(invoiceNo)) {
          tmpInvoiceTotal[invoiceNo] = 0;
        }

        let wtCodeList = [...new Map(prGroupDByHList.map(item => [item['prwtCode'], item.prwtCode])).values()];

        for (let pywpbpGroup of pywpbpGroupList) {

          //Get py result directory
          let payrollResultDir = payrollResultDirList.find(elem => elem.id == pywpbpGroup.rgdirID);

          //Get RT data
          let paramRT = {
            wtCodeList: wtCodeList,
            rgdirID: pywpbpGroup.rgdirID,
            retroRgdirID: payrollResultDir.retroRgdirID,
            wpbpNo: pywpbpGroup.wpbpNo,
            payrollResultDir: payrollResultDir
          };

          let rtList = [];
          functionReturn = await this.getRTResult(paramRT);
          if (!functionReturn.success || arrayUtil.isEmpty(functionReturn.result)) {
            continue;
          }

          rtList = functionReturn.result;

          for (let rt of rtList) {

            let prGroupDRTList = prGroupDByHList.filter(elem => elem.prwtCode == rt.wtCode);
            if (arrayUtil.isEmpty(prGroupDRTList)) {
              continue;
            }
            for (let prGroupDRT of prGroupDRTList) {

              //Cal RT amount
              let itemAmount = rt.amount * prGroupDRT.prRate;

              if (itemAmount == 0) {
                continue;
              }

              // let curItemKey = invoiceNo + '_' + prGroupDRT.prItemCode;
              let curItemKey = invoiceNo + '_' + prGroupDRT.prDescriptionPRGroup;

              if (!tmpItemTotal.hasOwnProperty(curItemKey)) {
                tmpItemTotal[curItemKey] = 0;
              }

              tmpItemTotal[curItemKey] = mathUtil.round((tmpItemTotal[curItemKey] + itemAmount), 2);
              tmpInvoiceTotal[invoiceNo] = mathUtil.round((tmpInvoiceTotal[invoiceNo] + itemAmount), 2);

              let resultData = clone(tmpResult);
              resultData.numOfTime = numOfTime;
              resultData.prNo = curPRNo;
              resultData.invoiceNo = invoiceNo;
              resultData.itemCode = prGroupDRT.prItemCode;
              resultData.itemDesc = prGroupDRT.prDescriptionPRGroup;
              resultData.budgetCode = prGroupDRT.prBudgetCode;
              resultData.paymentTerms = 'Immediate';    //Fix
              resultData.invoiceDate = new Date(selection.invoiceDate);
              resultData.paymentBy = prGroupH.prPaymentBy;
              resultData.paidtoName = prGroupH.prPaidToName;
              resultData.payGroup = 'SALARY';         //Fix
              resultData.requestSentDttm = postDateTime;
              resultData.processAt = postDateTime;
              resultData.processBy = processBy;

              // let payrollResultDir = payrollResultDirList.find(elem => elem.id == pywpbpGroup.rgdirID);
              if (!jsonUtil.isEmpty(payrollResultDir)) {
                resultData.inPeriod = payrollResultDir.period;
                resultData.inYear = payrollResultDir.year;
                resultData.payType = payrollResultDir.payType;
                resultData.paymentDueDate = payrollResultDir.paymentDate;

                //Collect empCode
                if (!empCount.hasOwnProperty(curItemKey)) {
                  empCount[curItemKey] = {
                    count: 0,
                    empList: []
                  };
                }

                let empIndex = empCount[curItemKey].empList.findIndex(elem => elem == payrollResultDir.empCode);
                if (empIndex < 0) {
                  empCount[curItemKey].count++;
                  empCount[curItemKey].empList.push(payrollResultDir.empCode);
                }
              }

              let resultDataIndex = resultDataList.findIndex(elem => elem.invoiceNo == resultData.invoiceNo &&
                elem.itemDesc == resultData.itemDesc);
              if (resultDataIndex > -1) {
                continue;
              }

              resultDataList.push(resultData);

              checkPRGroupDataExist = true;
            }

          }
        }

        if (!checkPRGroupDataExist) {
          seq--;
        }

      }

      //No result found
      if (arrayUtil.isEmpty(resultDataList)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollResultFound');
        return functionReturn;
      }

      //Set total amount / person
      for (let i = 0; i < resultDataList.length; i++) {

        //Total invoice amount
        if (tmpInvoiceTotal.hasOwnProperty(resultDataList[i].invoiceNo)) {
          resultDataList[i].totalAmount = tmpInvoiceTotal[resultDataList[i].invoiceNo];
        }

        // let curItemKey = resultDataList[i].invoiceNo + '_' + resultDataList[i].itemCode;
        let curItemKey = resultDataList[i].invoiceNo + '_' + resultDataList[i].itemDesc;

        //Total item amount
        if (tmpItemTotal.hasOwnProperty(curItemKey)) {
          resultDataList[i].amount = tmpItemTotal[curItemKey];
        }

        //Total person
        if (empCount.hasOwnProperty(curItemKey)) {
          resultDataList[i].totalPerson = empCount[curItemKey].count;
        }
      }
      bgProcess.updateStepProgress(globalConstant.bgStepSelectData.id, ++countProgress, totalDatabase);


      functionReturn.success = true;
      functionReturn.result.data = resultDataList;
      functionReturn.result.excelFieldList = arrayField;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - prepareData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  prepareStructure() {
    let result = {};

    let arrayFieldList = [];
    arrayFieldList.push({ field: 'inPeriod', type: 'I', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.inPeriod') });
    arrayFieldList.push({ field: 'inYear', type: 'I', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.inYear') });
    arrayFieldList.push({ field: 'numOfTime', type: 'I', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.numOfTime') });
    arrayFieldList.push({ field: 'payType', type: 'CC', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.payType') });
    arrayFieldList.push({ field: 'totalPerson', type: 'I', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.totalPerson') });
    arrayFieldList.push({ field: 'prNo', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.prNo') });
    arrayFieldList.push({ field: 'itemCode', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.itemCode') });
    arrayFieldList.push({ field: 'amount', type: 'DEC', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.amount') });
    arrayFieldList.push({ field: 'itemDesc', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.itemDesc') });
    arrayFieldList.push({ field: 'budgetCode', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.budgetCode') });
    arrayFieldList.push({ field: 'invoiceNo', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.invoiceNo') });
    arrayFieldList.push({ field: 'paymentTerms', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.paymentTerms') });
    arrayFieldList.push({ field: 'invoiceDate', type: 'DATE', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.invoiceDate') });
    arrayFieldList.push({ field: 'paymentBy', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.paymentBy') });
    arrayFieldList.push({ field: 'totalAmount', type: 'DEC', value: 0, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.totalAmount') });
    arrayFieldList.push({ field: 'paidtoName', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.paidtoName') });
    arrayFieldList.push({ field: 'paymentDueDate', type: 'DATE', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.paymentDueDate') });
    arrayFieldList.push({ field: 'payGroup', type: 'CC', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.payGroup') });
    arrayFieldList.push({ field: 'requestSentDttm', type: 'DATETIME', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.requestSentDttm') });
    arrayFieldList.push({ field: 'responseMessageID', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseMessageID') });
    arrayFieldList.push({ field: 'responseBusinessEvent', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseBusinessEvent') });
    arrayFieldList.push({ field: 'responseSourceSystemID', type: 'CC', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseSourceSystemID') });
    arrayFieldList.push({ field: 'responseSentDttm', type: 'DATETIME', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseSentDttm') });
    arrayFieldList.push({ field: 'responseResponseDttm', type: 'DATETIME', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseResponseDttm') });
    arrayFieldList.push({ field: 'responseStatus', type: 'CC', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseStatus') });
    arrayFieldList.push({ field: 'responseMessage', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseMessage') });
    arrayFieldList.push({ field: 'responseStatusCode', type: 'CC', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.responseStatusCode') });
    arrayFieldList.push({ field: 'processAt', type: 'DATETIME', value: null, excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.processAt') });
    arrayFieldList.push({ field: 'processBy', type: 'C', value: '', excelHeader: translation.getTranslateText('tenant.symc.payrollToJoget.excel.processBy') });

    for (let arrayField of arrayFieldList) {
      result[arrayField.field] = arrayField.value;
    }

    return {
      fieldList: arrayFieldList,
      data: result
    };
  }

  async getPayrollArea(selection) {

    let functionReturn = new FunctionReturn();

    try {

      let condition = {
        payrollAreaCode: selection.payrollArea
      };
      let dbProcess = new DBProcess();

      let payrollAreaList = await dbProcess.getPayrollArea(condition);

      if (!arrayUtil.isEmpty(payrollAreaList)) {
        functionReturn.success = true;
        functionReturn.result = payrollAreaList;
      } else {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollAreaFound'); //'No Payroll Area found'
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getPayrollArea', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPayrollPeriod(selection) {

    let functionReturn = new FunctionReturn();

    try {
      let condition = {};
      let dbProcess = new DBProcess();

      if (selection.isOffCycle) {
        let keyDate = new Date(selection.paymentDate);

        if (keyDate != 'Invalid Date') {
          let payrollPeriod = {
            year: keyDate.getFullYear(),
            period: 0,
            paymentDate: keyDate,
            payrollAreaCode: selection.payrollArea
          }
          let payrollPeriodList = [];
          payrollPeriodList.push(payrollPeriod);

          functionReturn.success = true;
          functionReturn.result.payrollPeriodList = payrollPeriodList;
          functionReturn.result.period = payrollPeriod.period;
          functionReturn.result.year = payrollPeriod.year;
        } else {
          functionReturn.success = false
          functionReturn.message = translation.getTranslateText('common.error.invalidPaymentDate'); //'Invalid payment date'
          return functionReturn;

        }
        // if(moment.isDate(selection.paymentDate)) {
        //   condition = {
        //     paymentDate: moment(selection.paymentDate),
        //     payrollAreaCode: {
        //         [Op.in]: [selection.payrollArea]
        //     }
        //   }
        // } else {
        //   functionReturn.success = false;
        //   functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollPeriodFound'); 
        //   return functionReturn;
        // }
      } else {

        if (selection.period && selection.year) {
          condition = {
            period: selection.period,
            year: selection.year,
            payrollAreaCode: {
              [Op.in]: [selection.payrollArea]
            }
          }
        } else {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollPeriodFound');
          return functionReturn;
        }

        let payrollPeriodList = await dbProcess.getPayrollPeriod(condition);
        if (!arrayUtil.isEmpty(payrollPeriodList)) {
          functionReturn.success = true;
          functionReturn.result.payrollPeriodList = payrollPeriodList;
          functionReturn.result.period = payrollPeriodList[0].period;
          functionReturn.result.year = payrollPeriodList[0].year;

          // if(selection.isOffCycle) {
          //   functionReturn.result.startDate = payrollPeriodList[0].paymentDate;
          //   functionReturn.result.endDate = payrollPeriodList[0].paymentDate;
          // } else {
          functionReturn.result.startDate = payrollPeriodList[0].startDate;
          functionReturn.result.endDate = payrollPeriodList[0].endDate;
          // }

        } else {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollPeriodFound');
          return functionReturn;
        }

      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getPayrollPeriod', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPayrollResultData(selection) {

    let functionReturn = new FunctionReturn();

    try {

      //Payroll result directory
      let condition = {};
      let payrollResultDirList = [];
      let pywpbpResultList = [];
      let rtResultList = [];
      let dbProcess = new DBProcess();

      for (let payrollPeriod of selection.payrollPeriodList) {

        if (!selection.isOffCycle) {
          condition = {
            inPeriod: payrollPeriod.period,
            inYear: payrollPeriod.year,
            payType: globalConstant.pyNormalCycle,
            payrollAreaCode: payrollPeriod.payrollAreaCode
          }
        } else {
          condition = {
            paymentDate: payrollPeriod.paymentDate,
            payType: globalConstant.pyOffCycle,
            payrollAreaCode: payrollPeriod.payrollAreaCode,
            resultIndicator: 'A'
          }
        }

        if (!arrayUtil.isEmpty(selection.empCodeList)) {
          condition.empCode = selection.empCodeList;
        }

        let payrollPeriodResultList = await dbProcess.getPayrollDirectory(condition);
        if (!arrayUtil.isEmpty(payrollPeriodResultList)) {
          payrollResultDirList = payrollResultDirList.concat(payrollPeriodResultList);
        }

      }

      if (arrayUtil.isEmpty(payrollResultDirList)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPayrollResultFound');
      }

      //Get retro period data
      let retroResultDirList = payrollResultDirList.filter(elem => elem.period != elem.forPeriod &&
        elem.year != elem.forYear);
      if (!arrayUtil.isEmpty(retroResultDirList)) {
        for (let i = 0; i < retroResultDirList.length; i++) {
          condition = {
            empCode: retroResultDirList[i].empCode,
            inPeriod: retroResultDirList[i].forPeriod,
            inYear: retroResultDirList[i].forYear,
            forPeriod: retroResultDirList[i].forPeriod,
            forYear: retroResultDirList[i].forYear,
            payType: globalConstant.pyNormalCycle,
            payrollAreaCode: retroResultDirList[i].payrollAreaCode,
            resultIndicator: globalConstant.pyResultDirResultIndicatorPrevious
          }

          let retroPeriodResultList = await dbProcess.getPayrollDirectory(condition);
          if (!arrayUtil.isEmpty(retroPeriodResultList)) {
            retroResultDirList[i].retroRgdirID = retroPeriodResultList[0].id;
          }

        }
      }

      let rgdirIdList = payrollResultDirList.map(a => a.id);

      //PYWPBP
      condition = {
        rgdirID: rgdirIdList,
        comCode: selection.comCode
      };
      let pywpbpList = await dbProcess.getPYWPBP(condition);
      if (!arrayUtil.isEmpty(pywpbpList)) {
        pywpbpResultList = pywpbpList;
      }

      functionReturn.success = true;
      functionReturn.result.payrollResultDirList = payrollResultDirList;
      functionReturn.result.pywpbpResultList = pywpbpResultList;
      functionReturn.result.rgdirIdList = rgdirIdList;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getPayrollResultData', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPRGroup(selection) {

    let functionReturn = new FunctionReturn();

    try {

      let dbProcess = new DBProcess();
      let condition = {
        prStartDate: { [Op.lte]: new Date() },
        prEndDate: { [Op.gte]: new Date() },
      };

      if (!arrayUtil.isEmpty(selection.prGroupList)) {
        condition.prGroupCode = selection.prGroupList;
      }

      let prGroupHList = await dbProcess.getSYMCPRGroupHeader(condition);
      if (arrayUtil.isEmpty(prGroupHList)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPRGroupFound');
        return functionReturn;
      }

      let prGroupHeaderIDList = prGroupHList.map(a => a.id);

      condition = {
        prGroupHeaderID: prGroupHeaderIDList
      };
      let prGroupDList = await dbProcess.getSYMCPRGroupDetail(condition);
      if (arrayUtil.isEmpty(prGroupDList)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noPRGroupFound');
        return functionReturn;
      }

      functionReturn.success = true;
      functionReturn.result.prGroupHList = prGroupHList;
      functionReturn.result.prGroupDList = prGroupDList;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getPRGroup', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async getPostedResult(selection) {


    let functionReturn = new FunctionReturn();

    try {
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getPostedResult', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async getLastPostedResult(selection) {

    let functionReturn = new FunctionReturn();

    try {

      let dbProcess = new DBProcess();

      let condition = {
        inPeriod: selection.period,
        inYear: selection.year,
      };
      let symcLastPostedResult = await dbProcess.getLastSYMCPostedResult(condition);
      if (jsonUtil.isEmpty(symcLastPostedResult)) {
        functionReturn.success = false;
        return functionReturn;
      }

      functionReturn.success = true;
      functionReturn.result = symcLastPostedResult;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getLastPostedResult', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async getRTResult(param) {
    let functionReturn = new FunctionReturn();

    try {
      let dbProcess = new DBProcess();
      let rtResultList = [];
      // let payrollResultDir = param.payrollResultDir;

      //RT
      let condition = {
        wtCode: param.wtCodeList,
        rgdirID: param.rgdirID,
        wpbpNo: param.wpbpNo
      };
      let rtList = await dbProcess.getRT(condition);
      if (!arrayUtil.isEmpty(rtList)) {
        rtResultList = rtList;
      }

      //Retro RT;
      if (param.retroRgdirID) {
        condition = {
          wtCode: param.wtCodeList,
          rgdirID: param.retroRgdirID
        };
        let retroRTList = await dbProcess.getRT(condition);
        if (!arrayUtil.isEmpty(retroRTList)) {
          for (let i = 0; i < rtResultList.length; i++) {
            let retroAmount = 0;

            let wtRTList = retroRTList.filter(elem => elem.wtCode == rtResultList[i].wtCode);
            if (!arrayUtil.isEmpty(wtRTList)) {
              for (let wtRT of wtRTList) {
                retroAmount = retroAmount + wtRT.amount;
              }
            }

            rtResultList[i].amount = rtResultList[i].amount - retroAmount;

          }
        }
      }

      functionReturn.success = true;
      functionReturn.result = rtResultList;
    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util - getRTResult', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async processToJoget(param) {

    let functionReturn = new FunctionReturn();
    let transaction = await db[reqContext.getTenantCode()].conn.transaction();

    try {
      let dbProcess = new DBProcess();
      let resultDataList = param.resultDataList;
      let postedDateTime = resultDataList[0].processAt;
      let keyDatePosted = moment(postedDateTime).format('YYYYMMDDHHMMSS');
      let sentDttm = moment(postedDateTime).format('YYYY-MM-DD HH:MM:SS');

      //Get current instance ID
      let instanceID = '';
      functionReturn = await this.getInstanceID();
      if (functionReturn.success) {
        instanceID = functionReturn.result.lowValue;
      }


      let messageID = keyDatePosted + instanceID;

      //Prepare posted message body
      let requestList = [];

      for (let resultData of resultDataList) {
        let request = {};
        request.pr_no = resultData.prNo;
        request.payment_due_date = moment(resultData.paymentDueDate).format('YYYY-MM-DD');
        request.invoice_no = resultData.invoiceNo;
        request.invoice_date = moment(resultData.invoiceDate).format('YYYY-MM-DD');
        request.payment_by = resultData.paymentBy;
        request.paidto_name = resultData.paidtoName;
        request.pay_group = resultData.payGroup;
        request.payment_terms = resultData.paymentTerms;
        request.total_amount = resultData.totalAmount;
        request.budget_code = resultData.budgetCode;
        request.item_code = resultData.itemCode;
        request.item_desc = resultData.itemDesc;
        request.amount = resultData.amount;
        request.total_person = resultData.totalPerson;

        requestList.push(request);
      }

      //Body
      let body = {
        messageID: messageID,
        businessEvent: 'HrJogetPayroll',
        sourceSystemID: 'IPOP',
        sentDttm: sentDttm,
        authorization: "BasicAuthen",
        PayrollItems: requestList
      };

      //Post to JOGET
      param.messageID = messageID;
      param.requestBody = body;
      functionReturn = await this.postToJoget(param);
      if (functionReturn.success) {
        let responseResult = functionReturn.result;
        let responseMessageHeader = responseResult.messageHeader;
        let responseStatus = responseResult.responseStatus;

        //Modify result by response message
        for (let i = 0; i < resultDataList.length; i++) {
          resultDataList[i].responseMessageID = responseMessageHeader.messageID;
          resultDataList[i].responseBusinessEvent = responseMessageHeader.businessEvent;
          resultDataList[i].responseSourceSystemID = responseMessageHeader.sourceSystemID;
          resultDataList[i].responseSentDttm = moment(responseMessageHeader.sentDttm, ["YYYY-MM-DD hh:mm:ss"]).toDate();
          resultDataList[i].responseResponseDttm = moment(responseMessageHeader.responseDttm, ["YYYY-MM-DD hh:mm:ssA"]).toDate();
          resultDataList[i].responseStatus = responseStatus.statusCode;
          resultDataList[i].responseMessage = responseStatus.responseMessage;
          resultDataList[i].responseStatusCode = responseStatus.statusCode;
        }
      } else {
        //Modify result by response message
        for (let i = 0; i < resultDataList.length; i++) {
          resultDataList[i].responseStatus = globalConstant.messageTypeError;
          resultDataList[i].responseMessage = functionReturn.message;
          resultDataList[i].responseStatusCode = globalConstant.messageTypeError;
        }
      }

      //Insert SYMCPostedResult
      let createResultParam = {
        dataList: resultDataList,
        transaction: transaction
      };
      functionReturn = await dbProcess.bulkCreateSYMCPostedResult(createResultParam);
      if (functionReturn.success) {
        await transaction.commit();
      } else {
        await transaction.rollback();
      }

      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util- processToJoget', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
      await transaction.rollback();
    }

    return functionReturn;

  }

  async getInstanceID(param) {

    let functionReturn = new FunctionReturn();

    try {

      let dbProcess = new DBProcess();
      let condition = {
        paramGroup: 'INF',
        paramName: 'SYMC_JOGET_INSTANCE_ID',
        startDate: { [Op.lte]: new Date() },
        endDate: { [Op.gte]: new Date() }
      };

      functionReturn.result = await dbProcess.getParameter(condition);

      functionReturn.success = true

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util- postToJoget', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;

  }

  async postToJoget(param) {

    let functionReturn = new FunctionReturn();

    try {

      let dbProcess = new DBProcess();
      let serverConnParam = {
        connCode: connCode
      };
      let serverConnectionData = await dbProcess.getServerConnection(serverConnParam);
      if (jsonUtil.isEmpty(serverConnectionData)) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noServerConnetionFound');
        return functionReturn;
      }

      let requestBody = param.requestBody;
      param.serverConnectionData = serverConnectionData;

      let host = serverConnectionData.host;
      let hrPayrollPath = serverConnectionData.defaultPath;

      //Get auth
      let service = new JOGETService();
      functionReturn = await service.genAuthorization(param);
      if (!functionReturn.success) {
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('tenant.symc.payrollToJoget.error.noServerConnetionFound');
      }

      let authentication = functionReturn.result;

      let url = `${host}/${hrPayrollPath}/`;

      //Post
      functionReturn.clear();
      try {
        let response = await axios.post(url, requestBody, {
          headers: {
            Authorization: authentication,
            'Content-Type': 'text/plain'
          }
        });

        functionReturn.success = true;
        functionReturn.result = response.data.result;
      } catch (error) {
        helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util- postToJoget (Call api JOGETAPI) ', '', '', '', '');
        let errorMessage = error.response.statusText;

        functionReturn.success = false;
        functionReturn.message = errorMessage;
        return functionReturn;
      }

    } catch (error) {
      helper.logMessage('error', error.stack, 'tenant/symc/payrolltojoget/util- postToJoget', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

}
exports.Util = Util;

const clone = (src) => {
  return Object.assign({}, src);
};

[File Ends] util.js


<-- File Content Ends


[File Ends] payrolltojoget.txt


<-- File Content Ends


Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

document/
└── utils.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] utils.js
const crypto = require('crypto');
const lodash = require('lodash');
const fs = require('fs');
const moment = require('moment');
const axios = require('axios');

const helper = require('../../../../utils/helper');
const translation = require('../../../../utils/translation');
const globalConstant = require('../../../../config/constant');
const reqContext = require('../../../../utils/requestcontext');
const db = require('../../../../config/sequelize/sequelize').getConfig();
const env = require('../../../../config/environment/environment').getConfig();

const DBProcess = require('./dbprocess').DBProcess;
const IZignApiUtils = require('../izignapi/util').Util;
const IZignService = require('../izignapi/service').IZignService;
const DocumentService = require('./service').DocumentService;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;


const ORIGINAL_FILE_NAME_PREFIX = "_CERT";
const IPOP_AUTO_DOC_PREFIX = "IPOP_";

class Util {

  constructor() { }

  getOutputIV() {
    // TODO ใช้ 10 bytes catch Invalid IV length
    return crypto.randomBytes(8).toString('hex');
  }

  getServerFileName() {
    return crypto.randomBytes(15).toString('hex');
  }

  async onCreateTPTIZignDocumentStatus(docStatusList, createDocResponse) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();
    let transaction = null;

    try {

          for (let docStatusItem of docStatusList) {
            transaction = await db[reqContext.getTenantCode()].conn.transaction();

            let newIZignDocStatusItem = {
              documentID: lodash.get(createDocResponse, 'result.id', ''),
              referenceNo: lodash.get(createDocResponse, 'result.referenceNo', ''),
              ...docStatusItem
            };

            let newIZignDocStatus = await dbProcess.createTPTIZignDocumentStatus(newIZignDocStatusItem, transaction);

            if (newIZignDocStatus) {
              await transaction.commit();
            } else {
              await transaction.rollback();
            }
          }

          functionReturn.success = true;

      } catch (error) {

        if (transaction) {
          await transaction.rollback();
        }

        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - voidDocument', '', '', '', '');
        functionReturn.success = false;
        functionReturn.message = translation.getTranslateText('common.error.exception');
      } finally {
        if (transaction) {
            if (!transaction.finished) {
                await transaction.rollback();
            }
        }
      }

      return functionReturn;
  }

  async iZignDocumentStatus(params) {

    let functionReturn = new FunctionReturn();
    let dbProcess = new DBProcess();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let documentList = await dbProcess.getTPTIZignDocumentList(condition);

      for (let docItem of documentList) {

        let docStatus = lodash.get(docItem, 'status', '');
        switch (docStatus) {
          case globalConstant.iZign.ipopDocStatus.inProcess:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.inProcess');
              break;
          case globalConstant.iZign.ipopDocStatus.completed:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.completed');
              break;
          case globalConstant.iZign.ipopDocStatus.void:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.void');
              break;
          case globalConstant.iZign.ipopDocStatus.deleted:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.deleted');
              break;
          case globalConstant.iZign.ipopDocStatus.error:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.error');
              break;
          case globalConstant.iZign.ipopDocStatus.reject:
              docItem.statusText = translation.getTranslateText('thirdparty.iZign.document.util.iZignStatus.reject');
              break;
        }
      }

    functionReturn.result = documentList;
    functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDocumentStatus', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async iZignDownloadDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let dbProcess = new DBProcess();
    let documentService = new DocumentService();

    try {

      let documentID = lodash.get(params, 'documentID', '');

      if (!documentID) {
        functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.documentID');
        return functionReturn;
      }

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignDocItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignDocItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentResult = await iZignApiUtils.downloadDocument(documentID);

      if (!documentResult.success) {
        functionReturn = documentResult;
        return functionReturn;
      }

      let serverFilename = lodash.get(iZignDocItem, 'serverFilename', '');
      let encryptIV = lodash.get(iZignDocItem, 'encryptIV', '');
      let fileUrl = lodash.get(documentResult, 'result.url', '');
      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;

      try {
        let response = await axios.get(fileUrl, { responseType: "arraybuffer" });
        functionReturn.result = lodash.get(response, 'data', '');
        functionReturn.success = true;
      } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocument (Call api iZignDownloadDocument) ', '', '', '', '');

        let errorMessage = '';
        let getENErrorMessage = lodash.get(error, 'response.data.message');
        let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

        if (reqContext.getLanguage() === 'TH') {
            errorMessage = getTHErrorMessage;
        } else {
            errorMessage = getENErrorMessage;
        }

        functionReturn.result = null;
        functionReturn.success = false;
        functionReturn.message = errorMessage;
      }

      let fileBuffer = functionReturn.result;
      let encryptBuffer = await documentService.encryptDocumentFile(fileBuffer, encryptIV);

      if (!encryptBuffer.success) {
        functionReturn = encryptBuffer;
        return functionReturn;
      }

      if (!functionReturn.success) {
        return functionReturn;
      }

      fs.writeFileSync(`${documentPath}${serverFilename}`, encryptBuffer.result);
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async iZignDownloadDocumentCertificate(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let documentService = new DocumentService();
    let dbProcess = new DBProcess();

    try {
      let documentID = lodash.get(params, 'documentID', '');

      if (!documentID) {
        functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.documentID');
        return functionReturn;
      }

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignDocItem = await dbProcess.getTPTIZignDocument(condition);
      let downloadParam = { documentId: documentID };
      let documentResult = await iZignApiUtils.downloadDocumentCertificate(downloadParam);
      if (!documentResult.success) {
        functionReturn = documentResult;
        return functionReturn;
      }

      let fileUrl = lodash.get(documentResult, 'result.url', '');
      let encryptIV = lodash.get(iZignDocItem, 'encryptIV', '');
      let docCertServerFilename = lodash.get(iZignDocItem, 'docCertServerFilename', '');
      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;

      try {
        let response = await axios.get(fileUrl, { responseType: "arraybuffer" });
        functionReturn.result = lodash.get(response, 'data', '');
        functionReturn.success = true;
      } catch (error) {
        helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocumentCertificate (Call api iZignDownloadDocumentCertificate) ', '', '', '', '');
        functionReturn.result = null;
        functionReturn.success = false;
        functionReturn.message = error.message;
      }

      let fileBuffer = functionReturn.result;
      let encryptBuffer = await documentService.encryptDocumentFile(fileBuffer, encryptIV);

      if (!encryptBuffer.success) {
        functionReturn = encryptBuffer;
        return functionReturn;
      }

      if (!functionReturn.success) {
        return functionReturn;
      }

      fs.writeFileSync(`${documentPath}${docCertServerFilename}`, encryptBuffer.result);
      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - iZignDownloadDocumentCertificate', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async createDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();
    let iZignService = new IZignService();
    let documentService = new DocumentService();
    let dbProcess = new DBProcess();
    let transaction = null;

    try {

        let documentFile = lodash.get(params, 'file', '');
        let docStatusList = lodash.get(params, 'docStatusList', []);

        if (!documentFile) {
            functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.document');
            return functionReturn;
        }

        let envIzign = env[reqContext.getTenantCode()].thirdParty.iZign;
        let outputIV = this.getOutputIV();
        let serverFileName = this.getServerFileName();
        let originalFileName = lodash.get(documentFile, 'fileName', '');
        let fileExt = lodash.get(documentFile, 'fileExt', '');

        // Write document file
        let writeDocParam = {
          ...documentFile,
          outputIV: outputIV,
          serverFileName: serverFileName,
          originalFileName: originalFileName,
        }
        let writeFileResponse = await documentService.writeDocumentFile(writeDocParam);

        if (!writeFileResponse.success) {
            functionReturn = writeFileResponse;
            return functionReturn;
        }

        // Upload file to S3
        let uploadFileS3 = await documentService.uploadFileS3(writeFileResponse.result, writeDocParam);

        if (!uploadFileS3.success) {
            functionReturn = uploadFileS3;
            return functionReturn;
        }

        let createDocumentParam = lodash.get(params, 'params', '');
        if (createDocumentParam) {

          let iZignIV = env[reqContext.getTenantCode()].thirdParty.iZign.iZignIV;

          let userSignerList = lodash.get(createDocumentParam, 'userSignerList', '');
          createDocumentParam.fileUrl = lodash.get(uploadFileS3, 'result.url', '');
          let enCryptKey = env[reqContext.getTenantCode()].thirdParty.iZign.iZignEncryptDataKey;

          for (const [index, userSignItem] of userSignerList.entries()) {
            let idCardNo = lodash.get(userSignItem, 'idCardNo', '');
            let encData = iZignService.encData(idCardNo, enCryptKey, iZignIV);
            userSignerList[index].idCardNo = encData;
          }

          createDocumentParam.userSignerList = userSignerList;

          // Calling iZign Api
          let createDocResponse = await iZignApiUtils.createDocument(createDocumentParam);
          transaction = await db[reqContext.getTenantCode()].conn.transaction();

          // Generate TPTIZignDocument documentID and referenceNo if create document fail
          if (createDocResponse.success === false) {
            createDocResponse.result = {
              id: `${IPOP_AUTO_DOC_PREFIX}${this.getServerFileName()}`,
              referenceNo: `${IPOP_AUTO_DOC_PREFIX}${this.getServerFileName()}`,
            }
          }

          let newTPTIZignDocument = {
            documentID: lodash.get(createDocResponse, 'result.id', ''),
            referenceNo: lodash.get(createDocResponse, 'result.referenceNo', ''),
            status: createDocResponse.success ? globalConstant.iZign.ipopDocStatus.inProcess : globalConstant.iZign.ipopDocStatus.error,
            serverFilename: `${serverFileName}.${fileExt}`,
            originalFilename: `${originalFileName}.${fileExt}`,
            encryptIV: outputIV,
            changedAt: moment(),
            changedBy: reqContext.getLoginUsername(),
            message: lodash.get(createDocResponse, 'message', ''),
            docCertServerFilename: this.getServerFileName(),
            docCertOriginalFilename: `${originalFileName}${ORIGINAL_FILE_NAME_PREFIX}.${fileExt}`,
          };

          let createIZignDoc = await dbProcess.createTPTIZignDocument(newTPTIZignDocument, transaction);
          if (createIZignDoc) {
            await transaction.commit();
          }

          // Delete file S3
          let filePath = `${envIzign.awsS3Path}${serverFileName}.${fileExt}`;
          let deleteFileS3 = await documentService.deleteFileS3(filePath);

          if (!deleteFileS3.success) {
            functionReturn = deleteFileS3;
          }

          // Delete temp file
          let tempDocumentPath = lodash.get(writeFileResponse, 'result.tempDocumentPath', '');
          await documentService.deleteTempFile(tempDocumentPath);

          // Create TPTIZignDocumentStatus
          let createDocStatus = await this.onCreateTPTIZignDocumentStatus(docStatusList, createDocResponse);
          if (!createDocStatus.success) {
            functionReturn = createDocStatus;
          }

          functionReturn = createDocResponse;

        } else {
          functionReturn.success = false;
          functionReturn.message = translation.getTranslateText('thirdparty.iZign.document.util.error.parameter');
        }

    } catch (error) {

      if (transaction) {
        await transaction.rollback();
      }

      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - createDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    } finally {
      if (transaction) {
          if (!transaction.finished) {
              await transaction.rollback();
          }
      }
    }

      return functionReturn;
  }

  async voidDocument(params) {

    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();

    try {

        let voidDocumentParams = {
          documentId: lodash.get(params, 'documentID', ''),
          userEmail: lodash.get(params, 'userEmail', ''),
          voidedReason: lodash.get(params, 'voidedReason', ''),
          deviceName: lodash.get(params, 'deviceName', ''),
        }

        functionReturn = await iZignApiUtils.voidDocument(voidDocumentParams);

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - voidDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }

    return functionReturn;
  }

  async downloadDocument(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let documentService = new DocumentService();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;
      let serverFilename = lodash.get(iZignItem, 'serverFilename', '');
      let originalFilename = lodash.get(iZignItem, 'originalFilename', '');
      let iv = lodash.get(iZignItem, 'encryptIV', '');

      let outputPath = `${documentPath}${serverFilename}`;
      let buffer = fs.readFileSync(outputPath);
      let decryptBufferResult = await documentService.decryptDocumentFile(buffer, iv);

      if (!decryptBufferResult.success) {
        functionReturn = decryptBufferResult;
        return functionReturn;
      }

      functionReturn.result = {
        content: decryptBufferResult.result,
        fileName: originalFilename
      };

      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async downloadDocumentCertificate(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let documentService = new DocumentService();

    try {

      let condition = {
        documentID: lodash.get(params, 'documentID', ''),
        referenceNo: lodash.get(params, 'referenceNo', ''),
      };

      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let documentPath = env[reqContext.getTenantCode()].thirdParty.iZign.documentPath;
      let docCertServerFilename = lodash.get(iZignItem, 'docCertServerFilename', '');
      let docCertOriginalFilename = lodash.get(iZignItem, 'docCertOriginalFilename', '');
      let iv = lodash.get(iZignItem, 'encryptIV', '');

      let outputPath = `${documentPath}${docCertServerFilename}`;
      let buffer = fs.readFileSync(outputPath);
      let decryptBufferResult = await documentService.decryptDocumentFile(buffer, iv);

      if (!decryptBufferResult.success) {
        functionReturn = decryptBufferResult;
        return functionReturn;
      }

      functionReturn.result = {
        content: decryptBufferResult.result,
        fileName: docCertOriginalFilename
      };

      functionReturn.success = true;

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocumentCertificate', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }

  async deleteDocument(params) {

    let dbProcess = new DBProcess();
    let functionReturn = new FunctionReturn();
    let iZignApiUtils = new IZignApiUtils();

    try {

      let condition = { documentID: lodash.get(params, 'documentID', '') };
      let iZignItem = await dbProcess.getTPTIZignDocument(condition);

      if (!iZignItem) {
        functionReturn.message =  translation.getTranslateText('thirdparty.iZign.document.util.error.documentNotFound');
        return functionReturn;
      }

      let deleteDocumentParams = {
        documentId: lodash.get(params, 'documentID', ''),
        userEmail: lodash.get(params, 'userEmail', ''),
      };

      functionReturn = await iZignApiUtils.deleteDocument(deleteDocumentParams);

    } catch (error) {
      helper.logMessage('error', error.stack, 'thirdparty/izign/document/utils - downloadDocument', '', '', '', '');
      functionReturn.success = false;
      functionReturn.message = translation.getTranslateText('common.error.exception');
    }
    return functionReturn;
  }
}

exports.Util = Util;

[File Ends] utils.js


<-- File Content Ends


Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

izignapi/
└── util.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] util.js
const lodash = require("lodash");
const axios = require('axios');
const fs = require('fs');

const translation = require('../../../../utils/translation');
const helper = require('../../../../utils/helper');
const reqContext = require('../../../../utils/requestcontext');
const env = require('../../../../config/environment/environment').getConfig();

const IZignService = require('./service').IZignService;
const FunctionReturn = require('../../../../models/common/FunctionReturn').FunctionReturn;

const targetCreateType = '2'

const echo = '/echo';
const createDocument = '/documents/api-interface/create';
const downloadDocument = '/documents/download';
const voidDocument = '/documents/api-interface/void';
const deleteDocument = '/documents/api-interface/documents';
const downloadDocumentCertificate = '/documents/signing-detail/export/pdf';

const method = {
    get: 'GET',
    post: 'POST',
    delete: 'DELETE'
}

class Util {

    constructor() {}

    getIZignToken() {

        let functionReturn = new FunctionReturn();

        try {

            let encryptPath = env[reqContext.getTenantCode()].thirdParty.iZign.encryptTokenFile;
            let secretKey = env[reqContext.getTenantCode()].thirdParty.iZign.encryptTokenSecretKey;
            let encryptText = fs.readFileSync(encryptPath, 'utf8');

            if (encryptText) {
                functionReturn = helper.decrypt(encryptText, secretKey)
            } else {
                functionReturn.success = false;
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.configFileNotFound');
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - getIZignToken', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }
        return functionReturn;
    }

    async partnersEcho() {
        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let params = {
                requestUrl: echo,
                requestHttpMethod: method.post,
                requestBody: {
                    text: "Hello partners echo!"
                },
            };

            let headerResponse = await iZignService.preRequest(params);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let body = params.requestBody;
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${echo}`, body, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api partnersEcho) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.displayMessageEn');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    * @param {string[]} params.additionalFileUrls Url of attachment file (support: pdf, jpg, png)
    * @param {string} params.category [Required] Category of document
    * @param {string} params.companyCode [Required] Code of company
    * @param {string} params.createType [Required] “1” = Create with PDF file, “2” = Create with Template
    * @param {string} params.description Document description
    * @param {string} params.deviceName Device name for create document
    * @param {string} params.dueDate Expired date to sign of document with format "2023-01-15T09:30:16.888Z"
    * @param {string} params.fileName [Required] File name of document
    * @param {string} params.fileUrl [Required] Url of file for create document (required when createType is “1”)
    * @param {string[]} params.hashtagList Hash tag of document
    * @param {string} params.referenceNo [Required] Document reference (unique)
    * @param {string} params.ref1 Other reference of document
    * @param {string} params.ref2 Other reference of document
    * @param {string} params.remark Remark of document
    * @param {bool} params.signByOrder [Required] true: User can be signed by queue, false: All user can be signed
    * @param {string} params.subCategory Sub category of document
    * @param {string} params.templateCode [Required] Template code (required when createType is “2”)
    * @param {number} params.templateDataType [Required] "Type of template data (required when createType is “2”) 1 = Used templateData, 2 = Use templateDataList"
    * @param {Object} params.templateData [Required] Data for mapping in template (required when createType is “2” and templateDatType is 1)
    * @param {Object[]} params.templateDataList [Required] Data for mapping in template (required when createType is “2” and templateDatType is 2)
    * @param {Object} params.userCreatorData [Required] User creator document data
    * @param {Object[]} params.userSignerList [Required] List of user signer data
    * @param {string} params.vendorCompanyName Company name of vendor
    * @param {Object[]} params.eventCallback Handle callback authentication and additional data by event
    *
    *
    */
    async createDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!params) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.parameter');
                return functionReturn;
            }

            if (!params.category) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.category');
                return functionReturn;
            }

            if (!params.companyCode) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.companyCode');
                return functionReturn;
            }

            if (!params.createType) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.createType');
                return functionReturn;
            }

            if (!params.fileName) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.fileName');
                return functionReturn;
            }

            if (!params.fileUrl) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.fileUrl');
                return functionReturn;
            }

            if (!params.referenceNo) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.referenceNo');
                return functionReturn;
            }

            if (!params.signByOrder) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.signByOrder');
                return functionReturn;
            }

            if (params.createType === targetCreateType) {

                if (!params.templateCode) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateCode');
                    return functionReturn;
                }

                if (!params.templateDataType) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateDataType');
                    return functionReturn;
                }

                if (!params.templateData) {
                    functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateData');
                    return functionReturn;
                }

            }

            if (!params.templateDataList) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.templateDataList');
                return functionReturn;
            }

            if (!params.userCreatorData) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.userCreatorData');
                return functionReturn;
            }

            if (!params.userSignerList) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.userSignerList');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: createDocument,
                requestHttpMethod: method.post,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${createDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api createDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                if (!errorMessage) {
                    errorMessage = lodash.get(error, 'message', '');
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - createDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    * @param {string} id [Required] Document Id
    */
    async downloadDocument(documentId) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            let params = {
                requestUrl: `${downloadDocument}/${documentId}`,
                requestHttpMethod: method.get
            };

            let headerResponse = await iZignService.preRequest(params);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.get(`${apiHost}${downloadDocument}/${documentId}`, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api downloadDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
     * Downloads a certificate document using the provided parameters.
     *
     * @param {Object} params - The parameters for the request.
     * @param {string} params.documentId - The documentId of the request.
     * @return {Promise<FunctionReturn>} A promise that resolves to a FunctionReturn object containing the result and success status of the request.
     */
    async downloadDocumentCertificate(params) {
        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            if (!params) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: downloadDocumentCertificate,
                requestHttpMethod: method.post,
                requestBody: params
            };

            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${downloadDocumentCertificate}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocumentCertificate (Call api downloadDocumentCertificate) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - downloadDocumentCertificate', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    *  @param {string} documentId [Required] Document Id
    *  @param {string} userEmail [Required] User email for void
    *  @param {string} voidedReason [Required] Reason of void
    *  @param {string} deviceName Device name for create document
    */
    async voidDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let documentId = lodash.get(params, 'documentId', '');
            let userEmail = lodash.get(params, 'userEmail', '');

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            if (!userEmail) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.api.util.error.userEmail');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: voidDocument,
                requestHttpMethod: method.post,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${voidDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                 });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api voidDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - voidDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

    /**
    *  @param {string} documentId [Required] Document Id
    *  @param {string} userEmail [Required] User email for void
    */
    async deleteDocument(params) {

        let functionReturn = new FunctionReturn();
        let iZignService = new IZignService();

        try {

            let documentId = lodash.get(params, 'documentId', '');
            let userEmail = lodash.get(params, 'userEmail', '');

            if (!documentId) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.util.error.document');
                return functionReturn;
            }

            if (!userEmail) {
                functionReturn.message = translation.getTranslateText('thirdparty.iZign.api.api.util.error.userEmail');
                return functionReturn;
            }

            let preRequestParams = {
                requestUrl: deleteDocument,
                requestHttpMethod: method.delete,
                requestBody: params
            };
            let headerResponse = await iZignService.preRequest(preRequestParams);

            if (!headerResponse.success) {
                functionReturn = headerResponse;
                return functionReturn;
            }

            let apiHost = env[reqContext.getTenantCode()].thirdParty.iZign.apiHost;
            let headerResult = lodash.get(headerResponse, 'result.headers', '');
            let tokenResult = this.getIZignToken();

            try {
                let response = await axios.post(`${apiHost}${deleteDocument}`, params, {
                    headers: {
                        Authorization: lodash.get(tokenResult, 'result', ''),
                        'x-ottk': lodash.get(headerResult, 'xottk', '')
                    }
                    });
                functionReturn.result = lodash.get(response, 'data', '');
                functionReturn.success = true;
            } catch (error) {
                helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - partnersEcho (Call api deleteDocument) ', '', '', '', '');
                let errorMessage = '';
                let getENErrorMessage = lodash.get(error, 'response.data.message');
                let getTHErrorMessage = lodash.get(error, 'response.data.displayMessageTh');

                if (reqContext.getLanguage() === 'TH') {
                    errorMessage = getTHErrorMessage;
                } else {
                    errorMessage = getENErrorMessage;
                }

                functionReturn.result = null;
                functionReturn.success = false;
                functionReturn.message = errorMessage;
            }

        } catch(error) {
            helper.logMessage('error', error.stack, 'thirdparty/izign/izignapi/util - deleteDocument', '', '', '', '');
            functionReturn.success = false;
            functionReturn.message = translation.getTranslateText('common.error.exception');
        }

        return functionReturn;
    }

}

exports.Util = Util;
[File Ends] util.js


<-- File Content Ends


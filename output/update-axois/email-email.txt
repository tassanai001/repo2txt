Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

email/
└── email.js

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] email.js
const FunctionReturn = require('../../models/common/FunctionReturn').FunctionReturn;
const db = require('../../config/sequelize/sequelize').getConfig();
const reqContext = require('../requestcontext');
const jsonUtil = require('../json');
const arrayUtil = require('../array');
const helper = require('../helper');
const cheerio = require('cheerio');
const nodemailer = require('nodemailer');
const env = require('../../config/environment/environment').getConfig();
const globalConstant = require('../../config/constant');
const fs = require('fs');
// const dbAuth = require('../controllers/auth/dbauth/dbauth');

const axios = require('axios');
const moment = require('moment');

// param = {
//   templateName,
//   templateType,
//   templateLanguage
// }
// exports.getEmailTemplateByName = async (name) => {
exports.getEmailTemplateByCondition = async (param) => {
  let functionReturn = new FunctionReturn();
  try {

    let condition = {};

    if (param.templateName) {
      condition.templateName = param.templateName;
    }

    if (param.templateType) {
      condition.templateType = param.templateType
    }

    let emailTemplateList = await db[reqContext.getTenantCode()].EmailTemplate.findAll({
      attributes: [
        'id',
        'templateName',
        'templateType',
        'templateLanguage',
        'defaultTemplate'
      ],
      raw: true,
      where: condition
    });

    if (arrayUtil.isEmpty(emailTemplateList)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }

    let emailTemplate = {};
    if (emailTemplateList.length > 1) {

      if (param.templateLanguage) {
        emailTemplate = emailTemplateList.find(elem => elem.templateLanguage == param.templateLanguage);
      }

      if (jsonUtil.isEmpty(emailTemplate)) {
        emailTemplate = emailTemplateList.find(elem => elem.defaultTemplate == true);
      }

      if (jsonUtil.isEmpty(emailTemplate)) {
        emailTemplate = emailTemplateList[0];
      }

    }
    else {
      emailTemplate = emailTemplateList[0];
    }

    if (jsonUtil.isEmpty(emailTemplate)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }

    functionReturn = await this.getEmailTemplate(emailTemplate.id);

    // let emailTemplate = await db[reqContext.getTenantCode()].EmailTemplate.findOne({
    //   attributes: [
    //     'id',
    //     'templateName',
    //     'templateType',
    //     'templateLanguage',
    //     'defaultLanguage'
    //   ],
    //   raw: true,
    //   where: {
    //     templateName: param.templateName
    //   }
    // });

    // if (jsonUtil.isEmpty(emailTemplate)) {
    //   functionReturn.success = false;
    //   functionReturn.message = 'Cannt find email template';
    //   return functionReturn;
    // }

    // functionReturn = await this.getEmailTemplate(emailTemplate.id);
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplateByCondition', 'E006', '?', param, '');
    functionReturn.success = false;
    functionReturn.message = 'Error in get email template';
  }
  return functionReturn;
}

exports.getEmailTemplate = async (id) => {

  let functionReturn = new FunctionReturn();

  try {
    let variableList = [];
    let variableGroupList = [];
    let emailTemplate = await db[reqContext.getTenantCode()].EmailTemplate.findOne({
      raw: true,
      where: {
        id: id
      }
    });

    if (jsonUtil.isEmpty(emailTemplate)) {
      functionReturn.success = false;
      functionReturn.message = 'Cannt find email template';
      return functionReturn;
    }


    if (emailTemplate.variableGroup) {
      variableGroupList = JSON.parse(emailTemplate.variableGroup);
    }

    if (!arrayUtil.isEmpty(variableGroupList)) {
      variableList = await getEmailTemplateVar(emailTemplate, variableGroupList);
    }

    functionReturn.success = true;
    functionReturn.result = {
      emailTemplate: emailTemplate,
      variableGroupList: variableGroupList,
      variableList: variableList,
    };
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplate', 'E001', '?', id, '');
    functionReturn.success = false;
    functionReturn.message = 'Error in get email template';
  }

  return functionReturn;
}

exports.getSelectedVarList = (html) => {

  let variableList = [];

  try {
    let $ = cheerio.load(html);

    $(".mention[data-value]").map(
      (index, element) => {
        let variable = {
          id: $(element).attr('data-id'),
          variableHolder: $(element).attr('data-value')
        };

        variableList.push(variable);
      }
    )
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getSelectedVarList', 'E002', '?', html, '');
  }

  return variableList;
}

const getEmailTemplateVar = async (emailTemplate, variableGroupList) => {

  let variableList = [];

  try {

    let templateVarList = await db[reqContext.getTenantCode()].TemplateVariable.findAll({
      raw: true,
      where: {
        groupCode: variableGroupList,
      }
    });

    let subjectVariableList = exports.getSelectedVarList(emailTemplate.subject);
    let bodyVariableList = exports.getSelectedVarList(emailTemplate.bodyMessage);


    for (let variable of subjectVariableList) {
      let existingVar = variableList.find(elem => elem.id == variable.id);
      if (jsonUtil.isEmpty(existingVar)) {
        variableList.push(variable);
      }
    }

    for (let variable of bodyVariableList) {
      let existingVar = variableList.find(elem => elem.id == variable.id);
      if (jsonUtil.isEmpty(existingVar)) {
        variableList.push(variable);
      }
    }

    for (let variable of variableList) {
      let templateVar = templateVarList.find(elem => elem.id == variable.id);

      if (!jsonUtil.isEmpty(templateVar)) {
        variable.groupCode = templateVar.groupCode;
        variable.variableName = templateVar.variableName;
        variable.technicalName = templateVar.technicalName;
        variable.langKeyCode = templateVar.langKeyCode;
      }
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - getEmailTemplateVar', 'E003', '?', emailTemplate, '');
  }

  return variableList;
}


exports.replaceVariable = (html, variableList, convToText) => {

  let functionReturn = new FunctionReturn();

  try {

    let $ = cheerio.load(html, { decodeEntities: false, xmlMode: true });

    $(".mention[data-value]").map(
      (index, element) => {

        $(element).empty();
        $(element).removeAttr('class');

        let variableID = $(element).attr('data-id');
        let variableHolder = $(element).attr('data-value');

        let variable = variableList.find(elem => elem.id == variableID);
        if (!jsonUtil.isEmpty(variable)) {
          $(element).text(variable.replaceValue);
        }
        else {
          $(element).text('');
        }

      }
    )

    functionReturn.success = true;
    if (convToText) {
      functionReturn.result = $.text();
    }
    else {
      functionReturn.result = $.html();
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - replaceVariable', 'E004', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Error in replace variable';
  }

  return functionReturn;
}

// param = {
//  "subject",
//  "bodyMessage",
//  "toEmailList",
//  "ccEmailList",
//  "attachmentList"
//  "variableGroupList": [],
//  "senderDisplayName",
//  "variableList": [
//             {
//                 "id": template variable id,
//                 "variableHolder": template data-value,
//                 "groupCode",
//                 "variableName",
// 	               "replaceValue",
//             },            
//         ]
//  "transporter"
//}
exports.sendEmail = async (param) => {

  let functionReturn = new FunctionReturn();

  try {

    let subject = '';
    let bodyMessage = '';
    let emailFrom = {
      name: '',
      address: ''
    }

    // let emailAuthResult = exports.getEmailAuth(env[globalConstant.tenantCode.ipop].emailAuthSecretKey, env[globalConstant.tenantCode.ipop].emailAuthFile)

    // if (!emailAuthResult.success) {
    //   functionReturn.success = false;
    //   functionReturn.message = 'Email authentication error';
    //   return functionReturn;
    // }
    // let emailAuth = emailAuthResult.result;

    functionReturn = this.getEmailConfig();
    if (!functionReturn.success) {
      return functionReturn;
    }

    let emailConfig = functionReturn.result;

    let replaceVariableResult = exports.replaceVariable(param.subject, param.variableList, true);
    if (replaceVariableResult.success) {
      subject = replaceVariableResult.result;
    }

    replaceVariableResult = exports.replaceVariable(param.bodyMessage, param.variableList, false);
    if (replaceVariableResult.success) {
      bodyMessage = replaceVariableResult.result;
    }


    if (param.senderDisplayName) {
      emailFrom.name = param.senderDisplayName;
      // emailFrom = param.senderDisplayName + ' <' + emailConfig.senderAddress + '>';
    }
    else if (emailConfig.defaultSenderDisplayName) {
      emailFrom.name = emailConfig.defaultSenderDisplayName;
    }

    if (emailConfig.senderAddress) {
      emailFrom.address = emailConfig.senderAddress;
    }
    else {
      emailFrom.address = emailConfig.username;
    }

    let emailMessage = {
      from: emailFrom, //env[reqContext.getTenantCode()].email.senderAddress, // Sender address
      to: param.toEmailList,         // List of recipients
      cc: param.ccEmailList,
      subject: subject, // Subject line
      html: bodyMessage,
      attachments: param.attachmentList
    };

    if (emailConfig.service == globalConstant.emailService.smtp) {
      functionReturn = await sendEmail_SMTP({
        emailConfig: emailConfig,
        emailMessage: emailMessage,
        transporter: param.transporter
      })
    }
    else if (emailConfig.service == globalConstant.emailService.gmail) {
      functionReturn = await sendEmail_GMAIL({
        emailConfig: emailConfig,
        emailMessage: emailMessage,
        transporter: param.transporter
      })
    }
    else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
      functionReturn = await sendEmail_MICROSOFT_GRAPH({
        emailConfig: emailConfig,
        emailMessage: emailMessage
      })
    }

    // let transport = nodemailer.createTransport({
    //   host: emailConfig.host, //globalConstant.email.host,
    //   port: emailConfig.port, //587, //25,
    //   secure: emailConfig.secure,//false,
    //   auth: {
    //     user: emailConfig.username, //emailAuth.username,
    //     pass: emailConfig.password, //emailAuth.password
    //   },
    //   tls: { rejectUnauthorized: false }
    // });

    // let sendResult = await transport.sendMail(emailMessage);

    functionReturn.clear();
    functionReturn.success = true;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email - sendEmail', 'E005', '?', param.toEmailList, '');
    functionReturn.success = false;
    functionReturn.message = 'Send email error'
  }

  return functionReturn;
}

exports.getEmailConfig = () => {

  let functionReturn = new FunctionReturn();

  try {
    let emailConfig = env[reqContext.getTenantCode()].email;

    //If not config email on tenant, get from IPOP for default
    if (jsonUtil.isEmpty(emailConfig)) {
      emailConfig = env[globalConstant.tenantCode.ipop].email;
    }

    if (jsonUtil.isEmpty(emailConfig)) {
      functionReturn.success = false;
      functionReturn.message = 'Get email config error';
      return functionReturn;
    }

    let encryptedData = fs.readFileSync(emailConfig.authFile).toString()

    functionReturn = helper.decryptToJson(encryptedData, emailConfig.authSecretKey)
    if (!functionReturn.success) {
      functionReturn.message = 'Email authentication error'
      return functionReturn
    }

    let jsonData = functionReturn.result;
    if (emailConfig.authType == globalConstant.emailAuthType.userPassword) {
      emailConfig.username = jsonData.username;
      emailConfig.password = jsonData.password;
    }
    else if (emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      // if (emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
      if (emailConfig.service == globalConstant.emailService.gmail) {
        emailConfig.username = jsonData.user;
        emailConfig.clientId = jsonData.clientId;
        emailConfig.clientSecret = jsonData.clientSecret;
        emailConfig.refreshToken = jsonData.refreshToken;
      }
      else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
        emailConfig.clientId = jsonData.clientId;
        emailConfig.clientSecret = jsonData.clientSecret;
        emailConfig.resource = jsonData.resource;
        emailConfig.grantType = jsonData.grantType;
        emailConfig.tenantId = jsonData.tenantId;
        emailConfig.username = jsonData.username;
        emailConfig.tokenUrl = jsonData.tokenUrl;
        emailConfig.sendMailUrl = jsonData.sendMailUrl;
      }
    }

    functionReturn.clear();
    functionReturn.success = true;
    functionReturn.result = emailConfig;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getEmailConfig', '', '?', '', '')
    functionReturn.success = false
    functionReturn.message = 'Get email config error'
  }

  return functionReturn

}

// // param = {
// //   emailConfig
// // }
// // exports.getEmailAuth = (authSecretKey, authFile) => {
// exports.getEmailAuth = (param) => {

//   let functionReturn = new FunctionReturn()

//   try {
//     let emailAuthResult = {};
//     let encryptedData = fs.readFileSync(param.emailConfig.authFile).toString()

//     functionReturn = helper.decrypt(encryptedData, param.emailConfig.authSecretKey)
//     if (!functionReturn.success) {
//       functionReturn.message = 'Email authentication error'
//       return functionReturn
//     }

//     let jsonData = JSON.parse(functionReturn.result);
//     functionReturn.clear();

//     if (param.emailConfig.authType == globalConstant.emailAuthType.userPassword) {
//       emailAuthResult = {
//         username: jsonData.username,
//         password: jsonData.password
//       }
//     }
//     else if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
//       if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
//         emailAuthResult = {
//           user: jsonData.user,
//           clientId: jsonData.clientId,
//           clientSecret: jsonData.clientSecret,
//           refreshToken: jsonData.refreshToken
//         }
//       }
//     }

//     functionReturn.clear();
//     functionReturn.success = true
//     functionReturn.result = emailAuthResult

//   }
//   catch (error) {
//     helper.logMessage('error', error.stack, 'email/getEmailAuth', 'E006', '?', '', '')
//     functionReturn.success = false
//     functionReturn.message = 'Email authentication error'
//   }

//   return functionReturn
// }

// param = {
//   emailConfig,
//   emailMessage,
//   transporter
// }
const sendEmail_SMTP = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;

    if (!param.transporter) {
      transporter = await getTransporter_SMTP({
        emailConfig: param.emailConfig
      })
      // transporter = nodemailer.createTransport({
      //   host: param.emailConfig.host,
      //   port: param.emailConfig.port,
      //   secure: param.emailConfig.secure,
      //   auth: {
      //     user: param.emailConfig.username,
      //     pass: param.emailConfig.password,
      //   },
      //   tls: { rejectUnauthorized: false }
      // });
    }
    else {
      transporter = param.transporter;
    }

    let sendResult = await transporter.sendMail(param.emailMessage);
    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_SMTP', '', '?', '', sendResult);
    functionReturn.clear();
    functionReturn.success = true;
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_SMTP', '', '?', '', param.emailMessage.to);
    functionReturn.success = false;
    functionReturn.message = 'Send email error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   emailMessage,
//   transporter
// }
const sendEmail_GMAIL = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;

    if (!param.transporter) {

      transporter = await getTransporter_GMAIL({
        emailConfig: param.emailConfig
      });

      // let transportOption = {
      //   service: 'gmail',
      //   auth: {}
      // }

      // if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      //   transportOption.auth.type = 'OAuth2';
      //   if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
      //     transportOption.auth = {
      //       type: 'OAuth2',
      //       user: param.emailConfig.username,
      //       clientId: param.emailConfig.clientId,
      //       clientSecret: param.emailConfig.clientSecret,
      //       refreshToken: param.emailConfig.refreshToken
      //     }

      //     functionReturn = await getServiceToken({
      //       emailConfig: param.emailConfig
      //     });
      //     if (functionReturn.success) {
      //       if (functionReturn.result.accessToken) {
      //         transportOption.auth.accessToken = functionReturn.result.accessToken;
      //       }
      //     }
      //   }
      // }

      // transporter = nodemailer.createTransport(transportOption);

      // transporter.on('token', token => {

      //   updateServiceToken({
      //     service: 'gmail',
      //     authType: globalConstant.emailAuthType.oAuth2,
      //     user: token.user,
      //     accessToken: token.accessToken,
      //     tokenExpire: token.expires
      //   })

      //   helper.logMessage('info', 'A new gmail access token was generated', 'email/sendEmail_GMAIL', '', '?', '', '');
      //   helper.logMessage('info', token.user, 'email/sendEmail_GMAIL', '', '?', '', '');
      //   helper.logMessage('info', token.expires, 'email/sendEmail_GMAIL', '', '?', '', '');
      // });
    }
    else {
      transporter = param.transporter;
    }

    let sendResult = await transporter.sendMail(param.emailMessage);
    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_GMAIL', '', '?', '', sendResult);

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_GMAIL', '', '?', '', param.emailMessage.to);
    functionReturn.success = false;
    functionReturn.message = 'Send email error';

    // for(let tp of param.transporter.transporter._connections){

    // }
  }

  return functionReturn;
}

const getServiceToken = async (param) => {
  let functionReturn = new FunctionReturn();

  try {
    let accessToken = '';
    let expiredAtTimeStamp = null;
    let serviceToken = await db[reqContext.getTenantCode()].ServiceToken.findOne({
      attributes: [
        'accessToken',
        'expiredAtTimeStamp'
      ],
      raw: true,
      where: {
        serviceName: param.emailConfig.service,
        authType: param.emailConfig.authType,
        user: param.emailConfig.username
      },
      order: [
        ['expiredAtTimeStamp', 'DESC']
      ]
    });

    if (!jsonUtil.isEmpty(serviceToken)) {
      accessToken = serviceToken.accessToken;
      expiredAtTimeStamp = serviceToken.expiredAtTimeStamp;
    }

    functionReturn.success = true;
    functionReturn.result = {
      accessToken: accessToken,
      expiredAtTimeStamp: expiredAtTimeStamp
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getServiceToken', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get service token error';
  }

  return functionReturn;

}

const updateServiceToken = async (param) => {
  let functionReturn = new FunctionReturn();

  try {

    //Remove old token
    await db[reqContext.getTenantCode()].ServiceToken
      .destroy({
        where: {
          serviceName: param.service,
          authType: param.authType,
          user: param.user
        }
      });

    //Insert new token
    // let tokenExpire = parseInt(param.tokenExpire);
    await db[reqContext.getTenantCode()].ServiceToken.create({
      serviceName: param.service,
      authType: param.authType,
      user: param.user,
      accessToken: param.accessToken,
      expiredAtTimeStamp: param.tokenExpire
    });

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/updateServiceToken', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get service token error';
  }

  return functionReturn;

}

//Get own trasporter for pool connection
// param = {
//   poolConnection => true/false
// }
exports.getTransporter = async (param) => {

  let functionReturn = new FunctionReturn();

  try {
    let transporter = null;
    let notUseTransporter = false;
    functionReturn = this.getEmailConfig();
    if (!functionReturn.success) {
      return functionReturn;
    }

    let emailConfig = functionReturn.result;
    functionReturn.clear();

    if (emailConfig.service == globalConstant.emailService.smtp) {
      transporter = await getTransporter_SMTP({
        emailConfig: emailConfig,
        poolConnection: param.poolConnection
      })
    }
    else if (emailConfig.service == globalConstant.emailService.gmail) {
      transporter = await getTransporter_GMAIL({
        emailConfig: emailConfig,
        poolConnection: param.poolConnection
      })
    }
    else if (emailConfig.service == globalConstant.emailService.microsoftGraph) {
      notUseTransporter = true;
    }

    functionReturn.clear();
    if (transporter || notUseTransporter) {
      functionReturn.success = true;
      functionReturn.result = {
        transporter: transporter,
        notUseTransporter: notUseTransporter
      }
    }
    else {
      functionReturn.success = false;
      functionReturn.message = 'Cannot get email transporter';
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get transporter error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getTransporter_SMTP = async (param) => {

  let transporter = null;

  try {

    let transportOption = {
      host: param.emailConfig.host,
      port: param.emailConfig.port,
      secure: param.emailConfig.secure,
      auth: {
        user: param.emailConfig.username,
        pass: param.emailConfig.password,
      },
      tls: { rejectUnauthorized: false }
    }

    if (param.poolConnection) {
      transportOption.pool = true;

      if (param.emailConfig.poolMaxMessages) {
        transportOption.maxMessages = param.emailConfig.poolMaxMessages;
      }
      else {
        transportOption.maxMessages = 10;
      }
    }

    transporter = nodemailer.createTransport(transportOption);

    // transporter = nodemailer.createTransport({
    //   host: param.emailConfig.host,
    //   port: param.emailConfig.port,
    //   secure: param.emailConfig.secure,
    //   auth: {
    //     user: param.emailConfig.username,
    //     pass: param.emailConfig.password,
    //   },
    //   tls: { rejectUnauthorized: false }
    // });



  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter_SMTP', '', '?', '', '');
  }

  return transporter;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getTransporter_GMAIL = async (param) => {

  let transporter = null;
  let functionReturn = new FunctionReturn();

  try {

    let transportOption = {
      service: 'gmail',
      auth: {}
    }

    if (param.poolConnection) {
      transportOption.pool = true;

      if (param.emailConfig.poolMaxMessages) {
        transportOption.maxMessages = param.emailConfig.poolMaxMessages;
      }
      else {
        transportOption.maxMessages = 100;
      }
    }

    if (param.emailConfig.authType == globalConstant.emailAuthType.oAuth2) {
      transportOption.auth.type = 'OAuth2';
      if (param.emailConfig.authSubType == globalConstant.emailAuthSubType.oAuth2_3LO) {
        transportOption.auth = {
          type: 'OAuth2',
          user: param.emailConfig.username,
          clientId: param.emailConfig.clientId,
          clientSecret: param.emailConfig.clientSecret,
          refreshToken: param.emailConfig.refreshToken
        }

        if (!param.poolConnection) {
          functionReturn = await getServiceToken({
            emailConfig: param.emailConfig
          });
          if (functionReturn.success) {
            if (functionReturn.result.accessToken) {
              transportOption.auth.accessToken = functionReturn.result.accessToken;
            }
          }
        }
      }
    }

    transporter = nodemailer.createTransport(transportOption);

    transporter.on('token', token => {
      updateServiceToken({
        service: 'gmail',
        authType: globalConstant.emailAuthType.oAuth2,
        user: token.user,
        accessToken: token.accessToken,
        tokenExpire: token.expires
      })

      helper.logMessage('info', 'A new gmail access token was generated', 'email/sendEmail_GMAIL', '', '?', '', '');
      helper.logMessage('info', token.user, 'email/sendEmail_GMAIL', '', '?', '', '');
      helper.logMessage('info', token.expires, 'email/sendEmail_GMAIL', '', '?', '', '');
    });

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getTransporter_GMAIL', '', '?', '', '');
  }

  return transporter;
}

exports.closeTransporter = async (param) => {

  try {
    if (param.transporter) {
      param.transporter.close();
    }
  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/closeTransporter', '', '?', '', '');
  }
}


// param = {
//   emailConfig,
//   emailMessage,
// }
const sendEmail_MICROSOFT_GRAPH = async (param) => {

  let functionReturn = new FunctionReturn();

  try {

    let emailLog = '';

    functionReturn.clear();
    functionReturn = await getToken_MICROSOFT_GRAPH({
      emailConfig: param.emailConfig,
      emailMessage: param.emailMessage
    });
    if (!functionReturn.success) {
      return functionReturn;
    }

    let oAuthToken = functionReturn.result.oAuthToken;

    emailLog = 'To: '
    let toRecipients = [];
    for (let toEmail of param.emailMessage.to) {
      toRecipients.push({
        emailAddress: {
          address: toEmail
        }
      })

      emailLog += toEmail + ',';
    }

    emailLog += ' CC: '
    let ccRecipients = [];
    for (let ccEmail of param.emailMessage.cc) {
      ccRecipients.push({
        emailAddress: {
          address: ccEmail
        }
      })

      emailLog += ccEmail + ',';
    }

    let attachments = [];
    for (let attachment of param.emailMessage.attachments) {

      let contentBytes = Buffer.from(attachment.content).toString("base64");

      attachments.push({
        '@odata.type': '#microsoft.graph.fileAttachment',
        name: attachment.filename,
        contentType: attachment.contentType,
        contentBytes: contentBytes
      })
    }


    let msgPayload = {
      //Ref: https://learn.microsoft.com/en-us/graph/api/resources/message#properties
      message: {
        subject: param.emailMessage.subject,
        body: {
          contentType: 'HTML',
          content: param.emailMessage.html
        },
        toRecipients: toRecipients, //[{ emailAddress: { address: 'chairith.ar@pinno.io' } }]
        ccRecipients: ccRecipients,
        attachments: attachments
      },
      saveToSentItems: "false"
    };


    let sendResponse = await axios({ // Send Email using Microsoft Graph
      method: 'post',
      url: param.emailConfig.sendMailUrl,
      headers: {
        'Authorization': "Bearer " + oAuthToken,
        'Content-Type': 'application/json'
      },
      data: msgPayload
    })

    helper.logMessage('info', 'Send mail Result', 'email/sendEmail_MICROSOFT_GRAPH', '', '?', '', emailLog);

    functionReturn.clear();
    functionReturn.success = true;

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/sendEmail_MICROSOFT_GRAPH', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Send email error';
  }

  return functionReturn;
}

// param = {
//   emailConfig,
//   poolConnection => true/false
// }
const getToken_MICROSOFT_GRAPH = async (param) => {

  let tokenExpireOffsetMinute = 10;
  let functionReturn = new FunctionReturn();

  try {

    let isGetNewToken = true;
    let oAuthToken = '';

    functionReturn.clear();
    functionReturn = await getServiceToken({
      emailConfig: param.emailConfig
    });
    if (functionReturn.success) {

      let serviceToken = functionReturn.result;
      if (functionReturn.result.accessToken && serviceToken.expiredAtTimeStamp) {
        let expireAt = moment.unix(serviceToken.expiredAtTimeStamp);
        // console.log(expireAt)

        let checkExpireAt = moment().add(tokenExpireOffsetMinute, 'minutes');
        if (checkExpireAt.isBefore(expireAt)) {
          isGetNewToken = false;
          oAuthToken = functionReturn.result.accessToken;

          helper.logMessage('info', 'MS Graph email use existing token', 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
        }
      }

    }

    if (isGetNewToken || !oAuthToken) {
      let oAuthresponse = await axios({ // Get OAuth token to connect as OAuth client
        method: 'post',
        url: param.emailConfig.tokenUrl,
        data: new URLSearchParams({
          client_id: param.emailConfig.clientId,
          client_secret: param.emailConfig.clientSecret,
          resource: param.emailConfig.resource,
          grant_type: param.emailConfig.grantType
        }).toString()
      })

      let oAuthTokenData = oAuthresponse.data;
      oAuthToken = oAuthresponse.data.access_token;

      await updateServiceToken({
        service: param.emailConfig.service,
        authType: param.emailConfig.authType,
        user: param.emailConfig.username,
        accessToken: oAuthToken,
        tokenExpire: oAuthTokenData.expires_on
      })

      helper.logMessage('info', 'MS Graph email a new token was generated', 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
      // console.log(oAuthToken)
    }

    functionReturn.clear();
    functionReturn.success = true;
    functionReturn.result = {
      oAuthToken: oAuthToken
    }

  }
  catch (error) {
    helper.logMessage('error', error.stack, 'email/getToken_MICROSOFT_GRAPH', '', '?', '', '');
    functionReturn.success = false;
    functionReturn.message = 'Get email token error';
  }

  return functionReturn;
}

// exports.sendEmailGSuite = async (param) => {

//   try {

//     // let gsuite = require(env[reqContext.getTenantCode()].testGSuite);

//     // let t = "test";
//     // let privateKey = "-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC4iLU96Nvw07n7\\nVOls/c5+Ew+vqJXkioHdxfVatLpeCB2HB9yia0tzQyqy9yddKAh1OF9RAfewe/QI\\n7qReKhevNKrsWYCTCd6iCSUVT9ODBejJwloGw8mW3q1m/2hqJqT+hZ/WnT6nXSrz\\nbmNnew4h1H1CW+OUXLLdqt6rE/DtVRuKB8mQihJZjsZ69tFfE4B7Vh3YFwUvqXV+\\nE8iVm8sOFpVNhN1fPdrCF8+p1ZIUz69fuGHsHeXsgazXrBkK+/ddpTGBTS4wbJqx\\nC3wACJl+LmtUsFN2pQVns/Jm5n072pvTeGB1Nxk6jh7bQ9DNm2O+B7tbZ0mYqG16\\naVfTsT7jAgMBAAECggEAIgRJbMUtLiLJiPQpJ4dN9l2rKZVpNDz4HZqtVPA13rme\\nP9MKMAKZYQEDsQPwhLKphHpEz9kOAMGIxdDACf+2Z/zMeU8ybWiHWtVWuawCcIe5\\nVt/12oNi+OXJj1ALvm2rQqP9SAGqmA2Lql4yAtRjUYcrI/1uYV4JNuWVsHG3mvgh\\neVcg3wzNYidc0T7uQA+XbUO+Piq6omiWTtpx3QHH2j1l/vBGB4ZRzsZXlphjuRfN\\nt2U8OPeFxazntqbto3Eb0zcuQpIq5V03StVfXeSryV8pMGWbr0BL5HUZeSL8zld3\\nT0mImX/6VT7WBhdtzgVAiK2eT7P/McK1MeUU3JhiWQKBgQD5o8kNM3SjJg91t3gQ\\nNPgOo/N8g8/P3v0i9GBk316P9NUNEnYHNS1TwihHrjly1KtbZRuoYMuBHIFcfl2+\\nMEh2YMFZBMeFCpSwf83zdhBF26rLxXo7JkQS2yXz3UepBQuGKtlNTI2V5d++qEzf\\nuXEet3Iz5zIEzbcPrmm3lae0JwKBgQC9PEk93/ut0cXmpqOoVGKc0X2jFwSBYqi0\\ncu0pBr+o/bl22PZcymIKFLhdeffTsmj3q3eryZWYAQrbv35H/LIe7vfGkI8fdpN6\\nOMUgNqYi5W8pqnzOJqJb3rsWtfDWLYWVNVQK2f3VLyZJNYpNHrILmfsH5xho4o0I\\nAXocbKEo5QKBgQDnWC9zumG26AifsLzlWBEhkDKPC6BEJYQ1Jn9GO/JoOh5OlPMo\\nTtGIs3+cngrDLe73LcXpznoJVp9TVhANtrUQby3/DvzPgDS3NFlp69m8w4uOd52E\\nvzuKteiADGriabh6R69FgVIcvgERsOo80p/QNXTyQKkL5pBlSd7SsS/PNQKBgCrL\\niHDCx6MOjqfTxa0asFZwle4dFXrBOg/c8b9WdF+eSaQT+tsPNc670tno7F/muBBS\\nqbSi2P7QNYluq/tRrWKLfmNca9GcuktorUPUuAuqQVJ16NWiLRODsmG3caiuEMim\\nj8QIenwMtqbVwdog9/jhsMCfxYhqu6Q02U22T1f1AoGAJEWLcEGEK+k/3uSgLApJ\\n5payjU9csZ1nb0mEMUqdAvcHuJcuqNDuGFo6TDodSOJ/B2yDkusI7DckcsXO01BS\\nR46hRZd4TgvgkRyWTjqsO7llqEyr3iP+Q23apmVu9jLFvKNVRmUIczYLgGDvxRaf\\ngDNmFs+qD7Z6vloL8bNe26Q=\\n-----END PRIVATE KEY-----\\n";
//     // // let privateKey = "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC4iLU96Nvw07n7\nVOls/c5+Ew+vqJXkioHdxfVatLpeCB2HB9yia0tzQyqy9yddKAh1OF9RAfewe/QI\n7qReKhevNKrsWYCTCd6iCSUVT9ODBejJwloGw8mW3q1m/2hqJqT+hZ/WnT6nXSrz\nbmNnew4h1H1CW+OUXLLdqt6rE/DtVRuKB8mQihJZjsZ69tFfE4B7Vh3YFwUvqXV+\nE8iVm8sOFpVNhN1fPdrCF8+p1ZIUz69fuGHsHeXsgazXrBkK+/ddpTGBTS4wbJqx\nC3wACJl+LmtUsFN2pQVns/Jm5n072pvTeGB1Nxk6jh7bQ9DNm2O+B7tbZ0mYqG16\naVfTsT7jAgMBAAECggEAIgRJbMUtLiLJiPQpJ4dN9l2rKZVpNDz4HZqtVPA13rme\nP9MKMAKZYQEDsQPwhLKphHpEz9kOAMGIxdDACf+2Z/zMeU8ybWiHWtVWuawCcIe5\nVt/12oNi+OXJj1ALvm2rQqP9SAGqmA2Lql4yAtRjUYcrI/1uYV4JNuWVsHG3mvgh\neVcg3wzNYidc0T7uQA+XbUO+Piq6omiWTtpx3QHH2j1l/vBGB4ZRzsZXlphjuRfN\nt2U8OPeFxazntqbto3Eb0zcuQpIq5V03StVfXeSryV8pMGWbr0BL5HUZeSL8zld3\nT0mImX/6VT7WBhdtzgVAiK2eT7P/McK1MeUU3JhiWQKBgQD5o8kNM3SjJg91t3gQ\nNPgOo/N8g8/P3v0i9GBk316P9NUNEnYHNS1TwihHrjly1KtbZRuoYMuBHIFcfl2+\nMEh2YMFZBMeFCpSwf83zdhBF26rLxXo7JkQS2yXz3UepBQuGKtlNTI2V5d++qEzf\nuXEet3Iz5zIEzbcPrmm3lae0JwKBgQC9PEk93/ut0cXmpqOoVGKc0X2jFwSBYqi0\ncu0pBr+o/bl22PZcymIKFLhdeffTsmj3q3eryZWYAQrbv35H/LIe7vfGkI8fdpN6\nOMUgNqYi5W8pqnzOJqJb3rsWtfDWLYWVNVQK2f3VLyZJNYpNHrILmfsH5xho4o0I\nAXocbKEo5QKBgQDnWC9zumG26AifsLzlWBEhkDKPC6BEJYQ1Jn9GO/JoOh5OlPMo\nTtGIs3+cngrDLe73LcXpznoJVp9TVhANtrUQby3/DvzPgDS3NFlp69m8w4uOd52E\nvzuKteiADGriabh6R69FgVIcvgERsOo80p/QNXTyQKkL5pBlSd7SsS/PNQKBgCrL\niHDCx6MOjqfTxa0asFZwle4dFXrBOg/c8b9WdF+eSaQT+tsPNc670tno7F/muBBS\nqbSi2P7QNYluq/tRrWKLfmNca9GcuktorUPUuAuqQVJ16NWiLRODsmG3caiuEMim\nj8QIenwMtqbVwdog9/jhsMCfxYhqu6Q02U22T1f1AoGAJEWLcEGEK+k/3uSgLApJ\n5payjU9csZ1nb0mEMUqdAvcHuJcuqNDuGFo6TDodSOJ/B2yDkusI7DckcsXO01BS\nR46hRZd4TgvgkRyWTjqsO7llqEyr3iP+Q23apmVu9jLFvKNVRmUIczYLgGDvxRaf\ngDNmFs+qD7Z6vloL8bNe26Q=\n-----END PRIVATE KEY-----\n";
//     // let nodeMailerPrivateKey = privateKey.replace(/\\n/g, "\n");

//     // const transporter = nodemailer.createTransport({
//     //   host: 'smtp.gmail.com',
//     //   port: 465,
//     //   secure: true,
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'test-378@tokyo-dream-303202.iam.gserviceaccount.com',
//     //     serviceClient: '103111922186676319248',
//     //     privateKey: privateKey
//     //   }
//     // });

//     // const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com', //gsuite.client_email,
//     //     serviceClient: gsuite.client_id,
//     //     privateKey: gsuite.private_key
//     //   }
//     // });

//     // //With refresh token from google oauth playground
//     // const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com',
//     //     clientId: '577258180606-18cg5a0a06qmrbov2dg1h5apg1epqkor.apps.googleusercontent.com',
//     //     clientSecret: 'skkW7rW0IKF0W9r4vC4FvgjG',
//     //     // refreshToken: '1//04lLudBcCSrXKCgYIARAAGAQSNwF-L9IrotbJGUbUZX7T7IIhGGpb-hULmSVxm5ju84SqdgMXOa09Y9bd4YIbsi6OI6zD2xGXe1E'
//     //     refreshToken: '1//04nBRkbhxON1zCgYIARAAGAQSNwF-L9Ir5mfrH772qbcy3CxBfk4ja0pelGKThYpSMc7aQLvpltIieIDzkpZjLpi1DjXh1bn8MMw', //old
//     //     // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//     //   }
//     // });

//     //With published consent screen
//     // A Google Cloud Platform project with an OAuth consent screen configured for an
//     // external user type and a publishing status of "Testing" is issued a refresh token expiring in 7 days.
//     // https://developers.google.com/identity/protocols/oauth2
//     const transporter = nodemailer.createTransport({
//       service: 'gmail',
//       auth: {
//         type: 'OAuth2',
//         user: 'chairith@gmail.com',
//         clientId: '322636959057-4eldjtrkrvpshp6u4q6p602t6i369du2.apps.googleusercontent.com',
//         clientSecret: 'tiZ_TYmeKa3SIFN1_EjUKwvd',
//         refreshToken: '1//04GKiOKhYspCYCgYIARAAGAQSNwF-L9IrMrAEC4rPcDW_ECOEj3yV9pzcVW0TX6DhaJ5Zz-RGSI8KB_lgO3nKgnoBEDVV9RFoCKw',
//         accessToken: 'ya29.A0AfH6SMDl73ZPNIOBYlhHoz_wiN7NVjQra9REtNVJrc-V-SU_JTK5A8eiqwVUEPu_oAWDS3r9DA3teub9jU9i3eCmDfRzxIDUQasP0qnnHieai5sESnZ-a3X6SpImZPU8WDwNooFyIZtuw3y1bstupkIJ9zheTw',
//         // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//       }
//     });

//     //End With published consent screen

//     // //************************************** */
//     // //THAILIFE ACCOUNT
//     //  //With refresh token from google oauth playground
//     //  const transporter = nodemailer.createTransport({
//     //   service: 'gmail',
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'no-reply-hr4u@thailife.com',
//     //     clientId: '372108937521-nhq8v6ahbkjgq93gao0apq26319esen0.apps.googleusercontent.com',
//     //     clientSecret: 'qGOdb03v1GCEOjXgggko3_zA',
//     //     refreshToken: '1//04BbfXAOxcxpzCgYIARAAGAQSNwF-L9Ird1JjsfqgIdQXfxpqlqgxkochZe1xMU-N6UQbavSl4H1AD3-9pwIUuBCysBlWbveqy08',
//     //     // accessToken: 'ya29.a0AfH6SMA0QXpyum-k82_iVbdeEmcouoiM5XjuiL6t5x_Q8rxLAVp68_bRDyFS36c_iaO9CzoghlLYdA7mSy8z6VGt9s9iiOU22sGjgx3O5xancmDuuIj_SwkCY0IR7wyv-34T8d54k69j6REuUQw9TBtPczWPTVUP19gSM29mRpk',
//     //   }
//     // });
//     // //************************************** */
//     // //END THAILIFE ACCOUNT

//     // let transporter = nodemailer.createTransport({
//     //   host: 'smtp.gmail.com',
//     //   port: 465,
//     //   secure: true,
//     //   auth: {
//     //     type: 'OAuth2',
//     //     user: 'chairith@gmail.com'
//     //   }
//     // });

//     // transporter.set('oauth2_provision_cb', (user, renew, callback) => {
//     //   // let accessToken = userTokens[user];
//     //   let accessToken = ''
//     //   if (!accessToken) {
//     //     return callback(new Error('Unknown user'));
//     //   } else {
//     //     return callback(null, accessToken);
//     //   }
//     // });

//     // await transporter.verify();
//     // await transporter.sendMail({
//     //   // from: 'test-378@tokyo-dream-303202.iam.gserviceaccount.com',
//     //   to: 'chairith@hotmail.com', //'jongkol.suw@thailife.com', //
//     //   subject: 'test gsuite email not consent',
//     //   text: 'hello world'
//     // });

//     transporter.on('token', token => {
//       console.log(token)
//       console.log('A new access token was generated');
//       console.log('User: %s', token.user);
//       console.log('Access Token: %s', token.accessToken);
//       console.log('Expires: %s', new Date(token.expires));
//       console.log('expire timestatmp %s', token.expires)
//     });

//     const message = {
//       to: param.to,         // List of recipients
//       cc: param.cc,
//       subject: param.subject, // Subject line
//       html: param.html,
//       attachments: param.attachments
//     };

//     // await transporter.sendMail(
//     //   message,
//     //   (err, info) => {
//     //     console.log(info)
//     //     console.log(info.envelope);
//     //     console.log(info.messageId);
//     //   }
//     // )

//     // console.log(transporter.transporter.auth.oauth2.accessToken)
//     // console.log(transporter.transporter.auth.oauth2.expires)

//     console.log('sent')
//   }
//   catch (error) {
//     console.log(error)
//   }

//   console.log("finish")
// }
[File Ends] email.js


<-- File Content Ends

